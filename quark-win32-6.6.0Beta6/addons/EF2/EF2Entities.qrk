QQRKSRC1
// EF2 Entities file for Quark

//$Header: /cvsroot/quark/runtime/addons/EF2/EF2Entities.qrk,v 1.3 2008/05/14 20:38:39 cdunde Exp $
// ----------- REVISION HISTORY ------------
//$Log: EF2Entities.qrk,v $
//Revision 1.3  2008/05/14 20:38:39  cdunde
//Fixed basic lighting in all games and a few other small typo errors.
//
//Revision 1.2  2008/03/12 09:32:17  cdunde
//Removed all unrelated game stuff when copied from STVEF.
//
//Revision 1.1  2008/03/09 20:31:03  cdunde
//Pulled entities out of the EF2 and FAKK2 game Data.qrk files.
//Game addons should never dump anything into their Data.qrk files.
//Also fixed their worldspawn music to work now.
//
//

{
  QuArKProtected = "1"
  Description = "EF2 Entities"

  Toolbox Folders.qtx =
  {
    Toolbox = "New map items..."
    Root = "EF2 Entities.qtxfolder"
    EF2 Entities.qtxfolder =
    {
      ;desc = "Created from EF2 source .cpp game files."
      char_* entities.qtxfolder =
      {
        ;desc = "Game play characters."
        char_borg_drone-female:e =
        {
          model = "models/char/borg_drone-female.tik"
          angles = "0 180 0"
          origin = "0 0 -64"
          ;desc = "Female Borg Drone with no attachments."
        }
        char_dancer-m9-f1-neutral:e =
        {
          model = "models/char/dancer-m9-f1-neutral.tik"
          angles = "0 180 0"
          origin = "0 0 -64"
          ;desc = "Gatiata - Dancer for M9"
        }
      }
      func_* entities.qtxfolder =
      {
        func_beam:e =
        {
          angle = "360"
          origin = "0 0 0"
          _color = "1 1 1"
          ;desc = "Creates a beam effect from the origin to the target's origin."
        }
        func_camera:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Camera used for cinematic sequences."
        }
        func_door:b =
        {
          angle = "360"
          ;incl = "defpoly"
          ;desc = "For making doors."
        }
        func_rotatingdoor:b =
        {
          angle = "360"
          ;incl = "defpoly"
          ;desc = "For making rotating doors."
        }
         func_earthquake:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Causes an earthquake."
        }
        func_emitter:b =
        {
          angle = "360"
          ;incl = "defpoly"
          ;desc = "Emitter to use."
        }
         func_exploder:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Spawns an explosion when triggered. Triggers any targets."
        }
        func_explodeobject:b =
        {
          debrismodel = ""
          angle = "360"
          ;incl = "defpoly"
          ;desc = "Spawns different kinds of debris when triggered."
        }
        func_explodingwall:b =
        {
          angle = "360"
          ;incl = "defpoly"
          ;desc = "Blows up on activation or when attacked."
        }
        func_multi_exploder:b =
        {
          angle = "360"
          ;incl = "defpoly"
          ;desc = "Spawns an explosion when triggered. Triggers any targets."
        }
        func_fallingrock:b =
        {
          angle = "360"
          ;incl = "defpoly"
          ;desc = "Creates a rock that begins falling and bounces along a path."
        }
        func_fulcrum:b =
        {
          angle = "360"
          ;incl = "defpoly"
          ;desc = "This creates a fulcrum when you stand on it."
        }
        func_group:b =
        {
          angle = "360"
          ;incl = "defpoly"
          ;desc = "Used to group brushes together just for editor convenience."
        }
        func_pushobject:b =
        {
          angle = "360"
          ;incl = "defpoly"
          ;desc = "Pushable object."
        }
        func_rain:b =
        {
          angle = "360"
          ;incl = "defpoly"
          ;desc = "This creates a raining effect in the brush."
        }
        func_remove:b =
        {
          angle = "360"
          ;incl = "defpoly"
          ;desc = "Used for lighting and such."
        }
        func_teleportdest:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Point trigger_teleport at these."
        }
        func_runthrough:b =
        {
          angle = "360"
          ;incl = "defpoly"
          ;desc = "Trigger field the player runs through and spawn .tik models."
        }
        func_sinkobject:b =
        {
          angle = "360"
          ;incl = "defpoly"
          ;desc = "Creates an object which gradually sinks downward when stepped on."
        }
        func_spawn:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Spawn entity to use for .tik files."
        }
        func_randomspawn:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Randomly spawns an entity for .tik files."
        }
        func_respawn:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "When the spawned is killed, this will get triggered."
        }
        func_spawnchain:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Tries to spawn something out of the sight of players."
        }
        func_spawnoutofsight:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Will only spawn something out of sight of its targets."
        }
        func_throwobject:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "This is an object you can pickup and throw at people."
        }
        func_useanim:b =
        {
          angle = "360"
          ;incl = "defpoly"
          ;desc = "Used to place the player into a specific animation."
        }
        func_useobject:b =
        {
          angle = "360"
          ;incl = "defpoly"
          ;desc = "Used to place the player into a specific sequence."
        }
      }
      info_* entities.qtxfolder =
      {
        info_grav_pathnode:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Gravity path."
        }
        info_helpernode:e =
        {
          animactive = "1"
          coveractive = "1"
          angle = "360"
          origin = "0 0 0"
          ;desc = "Helper node."
        }
        info_null:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Used as a positional target for spotlights, etc."
        }
        info_notnull:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Used as a positional target for lightning."
        }
        info_pathnode:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Navigate Path Node."
        }
        info_player_deathmatch:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Potential spawning position for deathmatch games."
        }
        info_player_intermission:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Viewing point in between deathmatch levels."
        }
        info_player_start:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "The normal starting point for a level."
        }
        info_splinepath:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Spline Path Node."
        }
        info_waypoint:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Used as a positioning device for objects."
        }
        info_waypointnode_callvolume:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Used as a positioning device for objects."
        }
        info_waypointnode_patrolwaypointnode:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Used as a positioning device for objects."
        }
        info_waypointnode_position:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Used as a positioning device for objects."
        }
        info_waypointnode_waypointnode:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Used as a positioning device for objects."
        }
      }
      misc_* entities.qtxfolder =
      {
        misc_model:e =
        {
          angle = "360"
          origin = "0 0 0"
        }
      }
      other entities.qtxfolder =
      {
        detail:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        light:e =
        {
          ;desc = "Non-displayed light."
          light = "300"
          _color = "1 1 1"
          angles = "0 0 0"
          origin = "0 0 0"
        }
        worldspawn:b =
        {
          farplane_cull = "1"
          ;desc = "Every map should have exactly one worldspawn."
        }
      }
      portal_* entities.qtxfolder =
      {
        portal_camera:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Used to target a portal_surface."
        }
        portal_surface:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Used to show a view from the targeted portal_camera."
        }
      }
      puzzle_* entities.qtxfolder =
      {
        puzzle_object:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Puzzle object, basic framework for all the puzzles."
        }
      }
      script_* entities.qtxfolder =
      {
        script_door:b =
        {
          angle = "360"
          ;incl = "defpoly"
          ;desc = "Used to script doors."
        }
        script_model:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Used to script models."
        }
        script_object:b =
        {
          angle = "360"
          ;incl = "defpoly"
          ;desc = "Used to script objects."
        }
        script_origin:e =
        {
          angle = "360"
          origin = "0 0 0"
          ;desc = "Used to script origins."
        }
        script_skyorigin:b =
        {
          angle = "360"
          ;incl = "defpoly"
          ;desc = "Used to script skyorigin."
        }
      }
      sound_* entities.qtxfolder =
      {
        sound_randomspeaker:e =
        {
          angle = "360"
          origin = "0 0 0"
        }
        sound_speaker:e =
        {
          angle = "360"
          origin = "0 0 0"
        }
      }
      trigger_* entities.qtxfolder =
      {
        trigger_camerause:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_changelevel:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_damagetargets:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_EntryAndExit:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_exit:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_givepowerup:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_groupevent:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_hurt:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_ladder:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_levelinteraction:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_multiple:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_music:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_once:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_push:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_pushany:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_pushobject:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_relay:e =
        {
          angle = "360"
          origin = "0 0 0"
        }
        trigger_reverb:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_secret:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_setvariable:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_teleport:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_use:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_useonce:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_volume:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_volume_callvolume:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
        trigger_worktrigger:b =
        {
          angle = "360"
          ;incl = "defpoly"
        }
      }
    }
  }
  Entity Forms.fctx =
  {
    // Definition of includes

    t_commonspecifics:incl =
    {
      target: =
      {
        txt = "&"
        hint = "Name of the entity that this one targets."
      }
      targetname: =
      {
        txt = "&"
        hint = "Name of this entity, used as a target by another entity."
            $0D"Click the 'Help Book' above for more possible detail."
      }
      wait: =
      {
        txt = "&"
        hint = "override the default wait before respawning."$0D
               "-1 = never respawn automatically,"$0D
               "which can be used with targeted spawning."
      }
      random: =
      {
        txt = "&"
        hint = "random number of plus or minus seconds varied from the respawn time."
      }
      count: =
      {
        txt = "&"
        hint = "override quantity or duration on most items."
      }
    }

    t_modelbrowser:incl =
    {
      hint ="Use this to select any .tik file you want."$0D
            "You must extract the folder with the .tik files"$0D
            "from the .pk3 file and put it in your 'base' folder."
            $0D"Click the 'Help Book' above for more possible detail."
      Typ = "EP"
      BasePath = "$Game\base"
      CutPath = "$Game\?\"
      DefExt = "tik"
      DirSep = "/"
    }

    t_soundbrowser:incl =
    {
      hint ="Use this to select any .wav; *.mp3 file you want."$0D
            "You must extract the folder with the .wav; *.mp3 files"$0D
            "from the .pk3 file and put it in your 'base' folder."
            $0D"Click the 'Help Book' above for more possible detail."
      Typ = "EP"
      BasePath = "$Game\base"
      CutPath = "$Game\?\"
      DefExt = "wav; *.mp3"
      DirSep = "/"
    }

    t_musicbrowser:incl =
    {
      hint ="Use this to select any .mus file you want."$0D
            "You must extract the folder with the .mus files"$0D
            "from the .pk3 file and put it in your 'base' folder."
            $0D"Click the 'Help Book' above for more possible detail."
      Typ = "EP"
      BasePath = "$Game\base"
      CutPath = "$Game\?\"
      DefExt = "mus"
      DirSep = "/"
    }

  //  Entity forms start here

    char_borg_drone-female:form =
    {
      help = "Female Borg Drone with no attachments."
      bbox = '-16 -16 0 16 16 64'
      target: =
      {
        txt = "&"
        hint = "Name of the entity that this one targets."
      }
      targetname: =
      {
        txt = "&"
        hint = "Name of this entity, used as a target by another entity."
      }
      model: =
      {
        txt = "&"
        hint = "Game play character."
      }
    }

    char_dancer-m9-f1-neutral:form =
    {
      help = "Gatiata - Dancer for M9"
      bbox = '-16 -16 0 16 16 64'
      target: =
      {
        txt = "&"
        hint = "Name of the entity that this one targets."
      }
      targetname: =
      {
        txt = "&"
        hint = "Name of this entity, used as a target by another entity."
      }
      model: =
      {
        txt = "&"
        hint = "Game play character."
      }
      animations: =
      {
        txt = "&"
        hint = "Available animations."
      }
    }

    func_beam:form =
    {
      help = "This creates a beam effect from the origin to the target's origin. If no"
          $0D"target is specified, uses angles and projects beam out from there."
      $0D"START_ON - Starts the beam on."
      $0D"PERSIST - Keeps the last few beams around and fades them out over the life of the beam."
      $0D"WAVE - Make the beam follow a sin wave pattern."
      $0D"NOISE - Use a more computationally expensive random effect, but the results are smoother."
      $0D22"target"$22" Name of the entity that this one targets."
      $0D22"targetname"$22" Name of this entity, used as a target by another entity."
      $0D"      If the targetname is set, it will use the target specified as the endpoint of the beam."
      $0D22"model"$22" Specifies the model to use as the beam."
      $0D"      If the model field is not set, then a renderer generated beam will be created"
      $0D"      using the color, minoffset, maxoffset, scale, and subdivisions fields."
      $0D22"overlap"$22" Specifies the amount of overlap each beam link should have."
      $0D"      Use this to fill in the cracks when using electric on beams. (Default is 0)"
      $0D22"minoffset"$22" Minimum amount of electrical variation. (Default is 0)"
      $0D22"maxoffset"$22" Maximum amount of electrical variation. (Default is 5)"
      $0D22"_color"$22" Vector specifiying the red,green, and blue components. (Default is '1 1 1')"
      $0D22"alpha"$22" Alpha of the beam. (Default is 1.0)"
      $0D22"damage"$22" Amount of damage the beam inflicts if beam hits someone. (Default is 0)"
      $0D22"angles"$22" Sets the angle of the beam if no target is specified."
      $0D22"life"$22" Sets the life of the beam for use with the persist spawnflag."
      $0D"      This is how long a beam will be displayed."
      $0D22"numsegments"$22" Number of segments in a beam. (Default is 4)"
      $0D22"delay"$22" Delay between beam updates. (i.e. slows the effect of the beam down)"
      $0D22"shader"$22" Set the shader of the beam."
      $0D22"scale"$22" Set the width of the beam."
      bbox = '-8 -8 -8 8 8 8'
      spawnflags: =
      {
        typ = "X1"
        cap = "START_ON"
        hint = "Starts the beam on."
      }
      spawnflags: =
      {
        typ = "X2"
        cap = "PERSIST"
        hint = "Keeps the last few beams around and fades them out over the life of the beam."
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "WAVE"
        hint = "Make the beam follow a sin wave pattern."
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "NOISE"
        hint = "Use a more computationally expensive random effect, but the results are smoother."
      }
      t_commonspecifics = !
      model: =
      {
        t_modelbrowser = !
        txt = "&"
        hint = "Specifies the model to use as the beam."
            $0D"Click the 'Help Book' above for more detail."
      }
      overlap: =
      {
        txt = "&"
        hint = "Specifies the amount of overlap each beam link should have. Use this to fill"
            $0D"in the cracks when using electric on beams. (Default is 0)"
      }
      minoffset: =
      {
        txt = "&"
        hint = "Minimum amount of electrical variation (Default is 0)"
      }
      maxoffset: =
      {
        txt = "&"
        hint = "Maximum amount of electrical variation. (Default is 5)"
      }
      _color: =
      {
        txt = "&"
        Typ = "LN"
        hint = "Vector specifiying the red, green, and blue components. (Default is '1 1 1')"
      }
      alpha: =
      {
        txt = "&"
        hint = "Alpha of the beam. (Default is 1.0)"
      }
      damage: =
      {
        txt = "&"
        hint = "Amount of damage the beam inflicts if beam hits someone. (Default is 0)"
      }
      angles: =
      {
        txt = "&"
        hint = "Sets the angle of the beam if no target is specified."
      }
      life: =
      {
        txt = "&"
        hint = "Sets the life of the beam for use with the persist spawnflag."
            $0D"This is how long a beam will be displayed."
      }
      numsegments: =
      {
        txt = "&"
        hint = "Number of segments in a beam. (Default is 4)"
      }
      delay: =
      {
        txt = "&"
        hint = "Delay between beam updates."
            $0D"(i.e. slows the effect of the beam down)"
      }
      shader: =
      {
        txt = "&"
        hint = "Set the shader of the beam."
      }
      scale: =
      {
        txt = "&"
        hint = "Set the width of the beam."
      }
    }
    info_splinepath:form =
    {
      help = "Spline Path Node"
       $0D22"angles"$22" camera will use that orientation."
       $0D22"loop"$22" set a loop node."
       $0D22"triggertarget"$22" when node is reached fire these targets."
       $0D22"thread"$22" fire this thread when node is reached."
       $0D22"speed"$22" speed multiplier for this segment, normally each"
         $0D"           segment will take 1 second to traverse,"
         $0D"           use 2 for double speed and 0.5 for half speed."
      bbox = '-8 -8 -8 8 8 8'
      spawnflags: =
      {
        typ = "X128"
        cap = "LADYBUG"
      }
      angles: =
      {
        txt = "&"
        hint = "Camera will use that orientation."
      }
      loop: =
      {
        txt = "&"
        hint = "Set a loop node."
      }
      triggertarget: =
      {
        txt = "&"
        hint = "When node is reached fire these targets."
      }
      thread: =
      {
        txt = "&"
        hint = "Fire this thread when node is reached."
      }
      speed: =
      {
        txt = "&"
        hint = "speed multiplier for this segment, normally each"
            $0D"segment will take 1 second to traverse, use 2 for double speed"
            $0D"and 0.5 for half speed"
      }
    }
    func_camera:form =
    {
      help = "Camera used for cinematic sequences."
      $0D"ORBIT - tells the camera to create a circular path around the object it points to."
      $0D"    It the camera points to a path, it will loop when it gets to the end of the path."
      $0D"START_ON - causes the camera to be moving as soon as it is spawned."
      $0D"AUTOMATIC - causes the camera to be switched to automatically when the player is within a certain radius,"
      $0D"    if 'thread' is specified, that thread will be triggered when the camers is activated."
      $0D"NO_TRACE - when the camera is in automatic mode, it will try to trace to"
      $0D"    the player before switching automatically, this turns off that feature."
      $0D"NO_WATCH - if this is an automatic camera, the camera will automatically watch the player unless this is set,"
      $0D"    camera's 'score' will be affected by how close to the middle of the camera the player is."
      $0D"LEVEL_EXIT - if the camera is being used, the level exit state will be set."
      $0D22"target"$22" points to the target to orbit or follow."
      $0D"      If it points to a path, the camera will follow the path."
      $0D22"speed"$22" specifies how fast to move on the path or orbit. (default 1)"
      $0D22"fov"$22" specifies fov of camera, default 90."
      $0D"      If fov is less than 3 than an auto-fov feature is assumed."
      $0D"      The fov will then specify the ratio to be used to"
      $0D"      keep a watched entity zoomed in and on the screen."
      $0D22"follow_yaw"$22" specifies yaw of the follow camera, default 0."
      $0D22"follow_distance"$22" the distance to follow or orbit if the target is not a path. (default 128)"
      $0D22"orbit_height"$22" specifies height of camera from origin for orbiting, default 128"
      $0D22"nextcamera"$22" a link to the next camera in a chain of cameras."
      $0D22"thread"$22" a thread label that will be fired when the camera is looked through."
      $0D22"auto_state"$22" if specified, denotes the state the player must be"
      $0D"      in for the camera to engage any number of states can be specified"
      $0D"      and only the first few letters need be specified as well a state"
      $0D"      of 'pipe' would mean that any player state that started with"
      $0D"      'pipe' would trigger this camera."
      $0D22"auto_radius"$22" the radius, in which the camera will automatically turn on. (default 512)"
      $0D22"auto_starttime"$22" how long it takes for the camera to be switched to. (default 0.2)"
      $0D22"auto_stoptime"$22" how long it takes for the camera to switch back to the player. (default 0.2)"
      $0D22"auto_maxfov"$22" Sets the maximum FOV that should be used when automatically calculating FOV. (default 90)"
      bbox = '-8 -8 0 8 8 16'
      spawnflags: =
      {
        typ = "X1"
        cap = "ORBIT"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X2"
        cap = "START_ON"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "AUTOMATIC"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "NO_TRACE"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "NO_WATCH"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X32"
        cap = "LEVEL_EXIT"
        hint = "Click 'Help' for detail."
      }
      t_commonspecifics = !
      speed: =
      {
        txt = "&"
        hint = "specifies how fast to move on the path or orbit. (default 1)"
      }
      fov: =
      {
        txt = "&"
        hint = "specifies fov of camera, default 90."
            $0D"if fov is less than 3 than an auto-fov feature is assumed. The fov will then"
            $0D"specify the ratio to be used to keep a watched entity zoomed in and on the screen"
      }
      follow_yaw: =
      {
        txt = "&"
        hint = "specifies yaw of the follow camera, default 0."
      }
      follow_distance: =
      {
        txt = "&"
        hint = "the distance to follow or orbit if the"
            $0D"target is not a path. (default 128)"
      }
      orbit_height: =
      {
        txt = "&"
        hint = "specifies height of camera from origin for orbiting, default 128."
      }
      nextcamera: =
      {
        txt = "&"
        hint = "a link to the next camera in a chain of cameras."
      }
      thread: =
      {
        txt = "&"
        hint = "a thread label that will be fired when the camera is looked through."
      }
      auto_state: =
      {
        txt = "&"
        hint = "if specified, denotes the state the player must be in for the camera to engage"
            $0D"any number of states can be specified and only the first few letters need be specified as well"
            $0D"a state of 'pipe' would mean that any player state that started with 'pipe' would trigger this"
            $0D"camera"
      }
      auto_radius: =
      {
        txt = "&"
        hint = "the radius, in which the camera will automatically turn on. (default 512)"
      }
      auto_starttime: =
      {
        txt = "&"
        hint = "how long it takes for the camera to be switched to. (default 0.2)"
      }
      auto_stoptime: =
      {
        txt = "&"
        hint = "how long it takes for the camera to switch"
            $0D"back to the player. (default 0.2)"
      }
      auto_maxfov: =
      {
        txt = "&"
        hint = "Sets the maximum FOV that should be used when"
            $0D"automatically calculating FOV. (default 90)"
      }
    }
    func_rotatingdoor:form =
    {
      help = "If two doors touch, they are assumed to be connected and operate as a unit."
      $0D"START_OPEN - causes the door to move to its destination when spawned, and operate in reverse."
      $0D"      It is used to temporarily or permanently close off an area"
      $0D"      when triggered (not usefull for touch or takedamage doors)."
      $0D"OPEN_DIRECTION - indicates which direction to open when START_OPEN is set."
      $0D"DOOR_DONT_LINK - is for when you have two doors that are touching"
      $0D"      but you want to operate independently."
      $0D"NOT_PLAYERS"
      $0D"NOT_MONSTERS"
      $0D"TOGGLE - causes the door to wait in both the start"
      $0D"      and end states for a trigger event."
      $0D"AUTO_OPEN - causes the door to open when a player is near instead of waiting for the player to use the door."
      $0D"TARGETED - door is only operational from triggers or script."
      $0D22"targetname"$22" if set, no touch field will be spawned and a remote button or trigger field activates the door."
      $0D22"message"$22" is printed when the door is touched if it is a trigger door and it hasn't been fired yet."
      $0D22"openangle"$22" how wide to open the door."
      $0D22"health"$22" if set, door must be shot open."
      $0D22"time"$22" move time (0.3 default)."
      $0D22"wait"$22" wait before returning (3 default, -1 = never return)"
      $0D22"dmg"$22" damage to inflict when blocked (0 default)"
      $0D22"key"$22" The item needed to open this door (default nothing)"
      $0D22"sound_stop"$22" Specify the sound that plays when the door stops moving (default global door_stop)"
      $0D22"sound_move"$22" Specify the sound that plays when the door opens or closes (default global door_moving)"
      $0D22"sound_message"$22" Specify the sound that plays when the door displays a message"
      $0D22"sound_locked"$22" Specify the sound that plays when the door is locked"
      $0D22"angle"$22" determines the opening direction. point toward the middle of the door (away from the hinge)"
      spawnflags: =
      {
        typ = "X1"
        cap = "START_OPEN"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X2"
        cap = "OPEN_DIRECTION"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "DOOR_DONT_LINK"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "NOT_MONSTERS"
      }
      spawnflags: =
      {
        typ = "X32"
        cap = "TOGGLE"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X64"
        cap = "AUTO_OPEN"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X128"
        cap = "TARGETED"
        hint = "Click 'Help' for detail."
      }
      t_commonspecifics = !
      message: =
      {
        txt = "&"
        hint = "is printed when the door is touched if it is"
            $0D"a trigger door and it hasn't been fired yet."
      }
      openangle: =
      {
        txt = "&"
        hint = "how wide to open the door"
      }
      angle: =
      {
        txt = "&"
        hint = "determines the opening direction. point toward the middle of the door (away from the hinge)"
      }
      health: =
      {
        txt = "&"
        hint = "if set, door must be shot open."
      }
      time: =
      {
        txt = "&"
        hint = "move time (0.3 default)."
      }
      wait: =
      {
        txt = "&"
        hint = "wait before returning (3 default, -1 = never return)"
      }
      dmg: =
      {
        txt = "&"
        hint = "damage to inflict when blocked (0 default)"
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to open this door (default nothing)"
      }
      sound_stop: =
      {
        txt = "&"
        hint = "Specify the sound that plays when the door"
            $0D"stops moving (default global door_stop)"
        t_soundbrowser = !
      }
      sound_move: =
      {
        txt = "&"
        hint = "Specify the sound that plays when the door"
            $0D"opens or closes (default global door_moving)"
        t_soundbrowser = !
      }
      sound_message: =
      {
        txt = "&"
        hint = "Specify the sound that plays when the door displays a message"
        t_soundbrowser = !
      }
      sound_locked: =
      {
        txt = "&"
        hint = "Specify the sound that plays when the door is locked"
        t_soundbrowser = !
      }
    }
    func_door:form =
    {
      help = "If two doors touch, they are assumed to be connected and operate as a unit."
      $0D"START_OPEN - causes the door to move to its destination when spawned, and operate in reverse."
      $0D"DOOR_DONT_LINK - is for when you have two doors that are touching"
      $0D"      but you want to operate independently."
      $0D"NOT_PLAYERS"
      $0D"NOT_MONSTERS"
      $0D"TOGGLE - causes the door to wait in both the start and end states for a trigger event."
      $0D"      and end states for a trigger event."
      $0D"AUTO_OPEN - causes the door to open when a player is near instead of waiting for the player to use the door."
      $0D"TARGETED - door is only operational from triggers or script."
      $0D22"targetname"$22" if set, no touch field will be spawned and a remote button or trigger field activates the door."
      $0D22"message"$22" is printed when the door is touched if it is a trigger door and it hasn't been fired yet."
      $0D22"extraTriggerSize"$22" The extra size for the door trigger (defaults to 0 0 0)"
      $0D22"health"$22" if set, door must be shot open."
      $0D22"speed"$22" move speed (100 default)"
      $0D22"time"$22" move time (0.3 default)."
      $0D22"wait"$22" wait before returning (3 default, -1 = never return)"
      $0D22"lip"$22" lip remaining at end of move (8 default)"
      $0D22"dmg"$22" damage to inflict when blocked (0 default)"
      $0D22"key"$22" The item needed to open this door (default nothing)"
      $0D22"sound_stop"$22" Specify the sound that plays when the door stops moving (default global door_stop)"
      $0D22"sound_move"$22" Specify the sound that plays when the door opens or closes (default global door_moving)"
      $0D22"sound_message"$22" Specify the sound that plays when the door displays a message"
      $0D22"sound_locked"$22" Specify the sound that plays when the door is locked"
      $0D22"angle"$22" determines the opening direction. point toward the middle of the door (away from the hinge)"
      spawnflags: =
      {
        typ = "X1"
        cap = "START_OPEN"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "DOOR_DONT_LINK"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "NOT_MONSTERS"
      }
      spawnflags: =
      {
        typ = "X32"
        cap = "TOGGLE"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X64"
        cap = "AUTO_OPEN"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X128"
        cap = "TARGETED"
        hint = "Click 'Help' for detail."
      }
      t_commonspecifics = !
      message: =
      {
        txt = "&"
        hint = "is printed when the door is touched if it is"
            $0D"a trigger door and it hasn't been fired yet."
      }
      angle: =
      {
        txt = "&"
        hint = "determines the opening direction. point toward"
            $0D"the middle of the door (away from the hinge)"
      }
      health: =
      {
        txt = "&"
        hint = "if set, door must be shot open."
      }
      speed: =
      {
        txt = "&"
        hint = "move speed (100 default)"
      }
      time: =
      {
        txt = "&"
        hint = "move time (1/speed default, overides speed)"
      }
      wait: =
      {
        txt = "&"
        hint = "wait before returning (3 default, -1 = never return)"
      }
      lip: =
      {
        txt = "&"
        hint = "lip remaining at end of move (8 default)"
      }
      dmg: =
      {
        txt = "&"
        hint = "damage to inflict when blocked (0 default)"
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to open this door (default nothing)"
      }
      extraTriggerSize: =
      {
        txt = "&"
        hint = "The extra size for the door trigger (defaults to 0 0 0)"
      }
      sound_stop: =
      {
        txt = "&"
        hint = "Specify the sound that plays when the door"
            $0D"stops moving (default global door_stop)"
        t_soundbrowser = !
      }
      sound_move: =
      {
        txt = "&"
        hint = "Specify the sound that plays when the door"
            $0D"opens or closes (default global door_moving)"
        t_soundbrowser = !
      }
      sound_message: =
      {
        txt = "&"
        hint = "Specify the sound that plays when the door displays a message"
        t_soundbrowser = !
      }
      sound_locked: =
      {
        txt = "&"
        hint = "Specify the sound that plays when the door is locked"
        t_soundbrowser = !
      }
    }
    script_door:form =
    {
      help = "if two doors touch, they are assumed to be connected and operate"
       " as a unit."$0D"TOGGLE causes the door to wait in both the start and e"
       "nd states for a trigger event."$0D"DOOR_DONT_LINK is for when you have"
       " two doors that are touching but you want to operate independently."$0D
       "START_OPEN causes the door to move to its destination when spawned, an"
       "d operate in reverse. It is used to temporarily or permanently close o"
       "ff an area when triggered (not usefull for touch or takedamage doors)."
       $0D"OPEN_DIRECTION indicates which direction to open when START_OPEN is"
       " set."$0D"AUTO_OPEN causes the door to open when a player is near inst"
       "ead of waiting for the player to use the door."$0D"TARGETED door is on"
       "ly operational from triggers or script"$0D22"message"$22" is printed w"
       "hen the door is touched if it is a trigger door and it hasn't been fir"
       "ed yet"$0D22"angle"$22" determines the opening direction. point toward"
       " the middle of the door (away from the hinge)"$0D22"targetname"$22" ta"
       "rgetname of the door"$0D22"health"$22" if set, door must be shot open"$0D
       $22"speed"$22" move speed (100 default)"$0D22"wait"$22" wait before ret"
       "urning (3 default, -1 = never return)"$0D22"dmg"$22" damage to inflict"
       " when blocked (0 default)"$0D22"key"$22" The item needed to open this "
       "door (default nothing)"$0D22"openpercentage"$22" The percentage amount"
       " of the length of the door to open"$0D22"targeted"$22" Sets the door t"
       "o targeted mode -- Meaning it must be triggered from another entity"$0D
       $22"toggle"$22" Makes the door stay in its current state until forced t"
       "o change"$0D22"sound_stop"$22" Specify the sound that plays when the d"
       "oor stops moving (default global door_stop)"$0D22"sound_move"$22" Spec"
       "ify the sound that plays when the door opens or closes (default global"
       " door_moving)"$0D22"sound_message"$22" Specify the sound that plays wh"
       "en the door displays a message"$0D22"sound_locked"$22" Specify the sou"
       "nd that plays when the door is locked"
      spawnflags: =
      {
        typ = "X1"
        cap = "START_OPEN"
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "DOOR_DONT_LINK"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "NOT_MONSTERS"
      }
      spawnflags: =
      {
        typ = "X64"
        cap = "AUTO_OPEN"
      }
      t_commonspecifics = !
      message: =
      {
        txt = "&"
        hint = "is printed when the door is touched if it is a trigger door and it hasn't been fired yet"
      }
      angle: =
      {
        txt = "&"
        hint = "determines the opening direction. point toward the middle of the door (away from the hinge)"
      }
      health: =
      {
        txt = "&"
        hint = "if set, door must be shot open"
      }
      speed: =
      {
        txt = "&"
        hint = "move speed (100 default)"
      }
      wait: =
      {
        txt = "&"
        hint = "wait before returning (3 default, -1 = never return)"
      }
      dmg: =
      {
        txt = "&"
        hint = "damage to inflict when blocked (0 default)"
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to open this door (default nothing)"
      }
      openpercentage: =
      {
        txt = "&"
        hint = "The percentage amount of the length of the door to open"
      }
      targeted: =
      {
        txt = "&"
        hint = "Sets the door to targeted mode -- Meaning it must be triggered from another entity"
      }
      toggle: =
      {
        txt = "&"
        hint = "Makes the door stay in its current state until forced to change"
      }
      sound_stop: =
      {
        t_soundbrowser = !
        txt = "&"
        hint = "Specify the sound that plays when the door stops moving (default global door_stop)"
      }
      sound_move: =
      {
        t_soundbrowser = !
        txt = "&"
        hint = "Specify the sound that plays when the door opens or closes (default global door_moving)"
      }
      sound_message: =
      {
        t_soundbrowser = !
        txt = "&"
        hint = "Specify the sound that plays when the door displays a message"
      }
      sound_locked: =
      {
        t_soundbrowser = !
        txt = "&"
        hint = "Specify the sound that plays when the door is locked"
      }
    }
    func_earthquake:form =
    {
      help = "NO_RAMPUP"
      $0D"NO_RAMPDOWN"
      $0D22"duration"$22" is the duration of the earthquake. Default is 0.8 seconds."
      $0D22"magnitude"$22" severity of the quake.  Default 1.0"
      bbox = '-8 -8 -8 8 8 8'
      spawnflags: =
      {
        typ = "X1"
        cap = "NO_RAMPUP"
      }
      spawnflags: =
      {
        typ = "X2"
        cap = "NO_RAMPDOWN"
      }
      t_commonspecifics = !
      duration: =
      {
        txt = "&"
        hint = "is the duration of the earthquake. Default is 0.8 seconds."
      }
      magnitude: =
      {
        txt = "&"
        hint = "severity of the quake. Default 1.0"
      }
    }
    func_exploder:form =
    {
      help = "Spawns an explosion when triggered. Triggers any targets."$0D22"d"
       "mg"$22" specifies how much damage to cause. Default indicates 120."$0D
       $22"key"$22" The item needed to activate this. (default nothing)"$0D22"t"
       "hread"$22" name of thread to trigger. This can be in a different scrip"
       "t file as well"$0D"by using the '::' notation."
      bbox = '0 0 0 8 8 8'
      t_commonspecifics = !
      dmg: =
      {
        txt = "&"
        hint = "specifies how much damage to cause. Default indicates 120."
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
      thread: =
      {
        txt = "&"
        hint = "name of thread to trigger. This can be in a different script file as well"
            $0D"by using the '::' notation."
      }
    }
    func_multi_exploder:form =
    {
      help = "Spawns an explosion when triggered. Triggers any targets."
          $0D"    size of brush determines where explosions will occur."
      $0D"MULTI_USE - allows the func_multi_exploder to be used more than once."
      $0D"RANDOM_TIME - adjusts the wait between each explosion by the random factor."
      $0D"VISIBLE - allows you to make the trigger visible."
      $0D"RANDOM_SCALE - scale explosions randomly. size will be between 0.25 and 1 times scale."
      $0D22"dmg"$22" specifies how much damage to cause from each explosion. (Default 120)"
      $0D22"delay"$22" delay before exploding (Default 0 seconds)"
      $0D22"duration"$22" how long to explode for (Default 1 second)"
      $0D22"wait"$22" time between each explosion (default 0.25 seconds)"
      $0D22"random"$22" random factor (default 0.25)"
      $0D22"key"$22" The item needed to activate this. (default nothing)"
      $0D22"thread"$22" name of thread to trigger.  This can be in a different"
      $0D"      script file as well by using the '::' notation."
      $0D22"health"$22" makes the object damageable."
      $0D22"scale"$22" set the maximum size for spawned debris and explosions."
      spawnflags: =
      {
        typ = "X1"
        cap = "MULTI_USE"
        hint = "allows the func_multi_exploder to be used more than once."
      }
      spawnflags: =
      {
        typ = "X2"
        cap = "RANDOM_TIME"
        hint = "adjusts the wait between each explosion by the random factor."
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "VISIBLE"
        hint = "allows you to make the trigger visible."
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "RANDOM_SCALE"
        hint = "scale explosions randomly. size will be between 0.25 and 1 times scale."
      }
      t_commonspecifics = !
      dmg: =
      {
        txt = "&"
        hint = "specifies how much damage to cause from each explosion. (Default 120)"
      }
      delay: =
      {
        txt = "&"
        hint = "delay before exploding (Default 0 seconds)"
      }
      duration: =
      {
        txt = "&"
        hint = "how long to explode for (Default 1 second)"
      }
      wait: =
      {
        txt = "&"
        hint = "time between each explosion (default 0.25 seconds)"
      }
      random: =
      {
        txt = "&"
        hint = "random factor (default 0.25)"
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
      thread: =
      {
        txt = "&"
        hint = "name of thread to trigger. This can be in a different script file as well"
            $0D"by using the '::' notation."
      }
      health: =
      {
        txt = "&"
        hint = "makes the object damageable."
      }
      scale: =
      {
        txt = "&"
        hint = "set the maximum size for spawned debris and explosions."
      }
    }
    func_explodeobject:form =
    {
      help = "Spawns an explosion when triggered. Triggers any targets."
          $0D"    size of brush determines where explosions and debris will be spawned."
      $0D"MULTI_USE - allows the func_explodeobject to be used more than once."
      $0D"RANDOM_TIME - adjusts the wait between each explosion by the random factor."
      $0D"VISIBLE - allows you to make the trigger visible."
      $0D"RANDOM_SCALE - scale explosions and debris randomly. size will be between 0.25 and 1 times scale."
      $0D"NO_EXPLOSIONS - if checked no explosions will be created."
      $0D"METAL_DEBRIS - automatically spawn metal debris, no need for debrismodel to be set."
      $0D"ROCK_DEBRIS - automatically spawn rock debris, no need for debrismodel to be set."
      $0D"NOTSOLID - debris is not solid."
      $0D22"killtarget"$22" name of the entity that this one will kill."
      $0D22"dmg"$22" specifies how much damage to cause from each explosion. (Default 120)"
      $0D22"delay"$22" delay before exploding (Default 0 seconds)"
      $0D22"duration"$22" how long to explode for (Default 1 second)"
      $0D22"wait"$22" time between each explosion (default 0.25 seconds)"
      $0D22"random"$22" random factor (default 0.25)"
      $0D22"health"$22" if specified, object must be damaged to trigger"
      $0D22"key"$22" The item needed to activate this. (default nothing)"
      $0D22"severity"$22" how violent the debris should be ejected from the object( default 1.0 )"
      $0D22"debrismodel"$22" What kind of debris to spawn (default nothing)"
      $0D"      other valid tiki files include: "$22"efx/glass_debris-lg.tik efx/glass_debris-sml.tik"$22
      $0D22"amount"$22" how much debris to spawn for each explosion (default 4)"
      $0D22"thread"$22" name of thread to trigger.  This can be in a different"
      $0D"      script file as well by using the '::' notation."
      $0D22"scale"$22" set the maximum size for spawned debris and explosions."
      $0D22"doexplosion"$22" specifies to use an explosion (can also specify explosion model and explosion radius)"
      $0D"      (can also specify explosion model and explosion radius)"
      spawnflags: =
      {
        typ = "X1"
        cap = "MULTI_USE"
        hint = "allows the func_explodeobject to be used more than once."
      }
      spawnflags: =
      {
        typ = "X2"
        cap = "RANDOM_TIME"
        hint = "adjusts the wait between each explosion by the random factor."
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "VISIBLE"
        hint = "allows you to make the trigger visible."
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "RANDOM_SCALE"
        hint = " scale explosions and debris randomly. size will be between 0.25 and 1 times scale."
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "NO_EXPLOSIONS"
        hint = "if checked no explosions will be created."
      }
      spawnflags: =
      {
        typ = "X32"
        cap = "METAL_DEBRIS"
        hint = "automatically spawn metal debris, no need for debrismodel to be set."
      }
      spawnflags: =
      {
        typ = "X64"
        cap = "ROCK_DEBRIS"
        hint = "automatically spawn rock debris, no need for debrismodel to be set."
      }
      spawnflags: =
      {
        typ = "X128"
        cap = "NOTSOLID"
        hint = "debris is not solid."
      }
      t_commonspecifics = !
      killtarget: =
      {
        txt = "&"
        hint = "Name of the entity that this one will kill."
      }
      dmg: =
      {
        txt = "&"
        hint = "specifies how much damage to cause from each explosion. (Default 120)"
      }
      delay: =
      {
        txt = "&"
        hint = "delay before exploding (Default 0 seconds)"
      }
      duration: =
      {
        txt = "&"
        hint = "how long to explode for (Default 1 second)"
      }
      wait: =
      {
        txt = "&"
        hint = "time between each explosion (default 0.25 seconds)"
      }
      random: =
      {
        txt = "&"
        hint = "random factor (default 0.25)"
      }
      health: =
      {
        txt = "&"
        hint = "if specified, object must be damaged to trigger"
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
      severity: =
      {
        txt = "&"
        hint = "how violent the debris should be ejected from the object( default 1.0 )"
      }
      debrismodel: =
      {
        typ = "C"
        txt = "&"
        hint = "What kind of debris to spawn (default nothing)"
        items =
            "nothing" $0D
            "glass" $0D
            "concrete_lg" $0D
            "concrete_med-nail" $0D
            "concrete_sml" $0D
            "concrete_sml-brown" $0D
            "glass_debris-lg" $0D
            "glass_debris-sml" $0D
            "metal_container" $0D
            "metal_container-med" $0D
            "metal_container-wide" $0D
            "metal_debris-lg1" $0D
            "metal_debris-lg" $0D
            "metal_debris-med" $0D
            "metal_debris-med-brown" $0D
            "metal_debris-sml" $0D
            "metal_pipe" $0D
            "training_hoop" $0D
            "training_target"
        values =
            "nothing" $0D
            "efx/glass_debris-lg.tik efx/glass_debris-sml.tik" $0D  // All three
            "efx/concrete_lg.tik" $0D                               // coding ways
            "models/efx/concrete_med-nail.tik" $0D                  // will work
            "models/efx/concrete_sml.tik" $0D
            "models/efx/concrete_sml-brown.tik" $0D
            "models/efx/glass_debris-lg.tik" $0D
            "models/efx/glass_debris-sml.tik" $0D
            "models/efx/metal_container.tik" $0D
            "models/efx/metal_container-med.tik" $0D
            "models/efx/metal_container-wide.tik" $0D
            "models/efx/metal_debris-lg1.tik" $0D
            "models/efx/metal_debris-lg.tik" $0D
            "models/efx/metal_debris-med.tik" $0D
            "models/efx/metal_debris-med-brown.tik" $0D
            "models/efx/metal_debris-sml.tik" $0D
            "models/efx/metal_pipe.tik" $0D
            "models/efx/training_hoop.tik" $0D
            "models/efx/training_target.tik"
      }
      debrismodel: =
      {
        t_modelbrowser = !
      }
      amount: =
      {
        txt = "&"
        hint = "how much debris to spawn for each explosion (default 4)"
      }
      thread: =
      {
        txt = "&"
        hint = "name of thread to trigger. This can be in a different script file as well"
            $0D"by using the '::' notation."
      }
      scale: =
      {
        txt = "&"
        hint = "set the maximum size for spawned debris and explosions."
      }
      doexplosion: =
      {
        txt = "&"
        hint = "specifies to use an explosion"
            $0D"(can also specify explosion model and explosion radius)"
      }
    }
    info_grav_pathnode:form =
    {
      help = "HEADNODE - Set to signify the head of the path."
      $0D"FORCE - Set if you want un-fightable gravity. ( i.e. can't go backwards )"
      $0D"PULL_UPWARDS - Set if you want the gravnodes to pull you upwards also."
      $0D22"radius"$22" radius of the effect of the pull. (Default is 256)"
      $0D22"speed"$22" speed of the pull. (Use negative for a repulsion) (Default is 100)"
      bbox = '-16 -16 0 16 16 32'
      spawnflags: =
      {
        typ = "X1"
        cap = "HEADNODE"
        hint = "Set to signify the head of the path."
      }
      spawnflags: =
      {
        typ = "X2"
        cap = "FORCE"
        hint = "Set if you want un-fightable gravity. (Default is 256)"
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "PULL_UPWARDS"
        hint = "Set if you want the gravnodes to pull you upwards also."
      }
      radius: =
      {
        txt = "&"
        hint = "Radius of the effect of the pull. (Default is 256)"
      }
      speed: =
      {
        txt = "&"
        hint = "Speed of the pull. (Use negative for a repulsion) (Default is 100)"
      }
    }
    info_helpernode:form =
    {
      help = "FLEE - Marks this spot as a safe destination for the AI when they flee."
      $0D"      Additional Commands for FLEE type Nodes:"
      $0D"None at this time."
      $0D"WORK - Marks this spot as a good place for the AI to work at."
      $0D"      The AI will turn to match the angles of helper node, so make sure to angle it appropriately."
      $0D"      The AI will also run the animation you specify with the 'setnodeanim' event and execute the"
      $0D"      thread you specify with the 'setnodethread' event."
      $0D"      Additional Commands for WORK type Nodes:"
      $0D22"setnodeanim"$22" sets the animation that the AI will run while on this node."
      $0D22"setnodeentrythread"$22" sets the thread that the AI will call when they arrive at this node."
      $0D22"setnodeexitthread"$22" sets the thread that the AI will call when they leave the node."
      $0D22"wait"$22" sets the time at this work node."
      $0D22"waitrandom"$22" sets a random waittime from 1 to the time specified."
      $0D22"waitforanim"$22" sets the actor to work until his animation is completed."
      $0D"ANIM - Allows you to specify a 'special' animation to be played at this location."
      $0D"      For example, if you have a 'dive through window' animation that you would like "
      $0D"      played as the AI moves through the node, you can specify it here."
      $0D"      Additional Commands for ANIM type Nodes:"
      $0D22"setnodeanim"$22" Sets the animation that the AI will run while on this node."
      $0D22"animcount"$22" Number of times the anim can be played."
      $0D22"animtarget"$22" TargetName for a specific entity you wish to be animated."
      $0D22"animactive"$22" Sets if the animation component is active."
      $0D"      1 is true ( default )"
      $0D"      0 is false"
      $0D"      if animactive is 0, then actors will not change animations at the node"
      $0D"COVER - Marks this spot as a good place for the AI to use as cover."
      $0D"      The AI will turn to match the angles of the helper node, so make sure to angle it appropriately."
      $0D"      The AI will also use the cover according to the information you specify in the setcovertype and setcoverdir events."
      $0D"      Additional Commands for COVER type Nodes:"
      $0D22"setcovertype"$22" Sets the type of cover at this spot. Valid values are ( crate , wall )"
      $0D22"setcoverdir"$22" Sets the direction that the AI can fire from"
      $0D"      ( Based Relative to the direction the node is facing )"
      $0D"      valid values are ( left , right, all )"
      $0D22"coveractive"$22" Sets if the cover component is active."
      $0D"      1 is true ( default )"
      $0D"      0 is false"
      $0D"      if coveractive is 0, then actors will not use it for cover."
      $0D"PATROL - Marks a position in a patrol path.  To be of any value, though, patrol helper nodes must be chained together."
      $0D"      If you want a full circuit, then you must connect all nodes together.  Any nodes CANNOT be cross linked together."
      $0D"      I know, I know, it sucks, but unfortunately, due to limits with targetname, it is the way it must be."
      $0D"      If you do not make a circuit, the AI will stand idle at the last node until it decides to do something else."
      $0D"      Additional Commands for PATROL type Nodes:"
      $0D22"wait"$22" Makes the AI pause at this node for the specifed amount of time."
      $0D22"waitrandom"$22" Makes the AI pause for a random amount of time. (up to a max of the amount specified )"
      $0D22"waitforanim"$22" Makes the AI pause long enough to complete his animation."
      $0D"SNIPER - Marks a position as a good sniping position."
      $0D"      Additional Commands for SNIPER type Nodes:"
      $0D22"wait"$22" Specifies a maximum time the AI will sit at this Node."
      $0D22"attacktarget"$22" Specifies a target to kill -- If not specified, will try and snipe any enemies in view."
      $0D22"maxkills"$22" Specifies the maximum number of kills at this Node."
      $0D"CUSTOM - Marks the node as a custom helper node.  Must be used in conjunction with the customtype command."
      $0D"COMBAT - Marks the node as a general place to do combat."
      bbox = '-16 -16 0 16 16 16'
      spawnflags: =
      {
        typ = "X1"
        cap = "FLEE"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X2"
        cap = "WORK"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "ANIM"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "COVER"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "PATROL"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X32"
        cap = "SNIPER"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X64"
        cap = "CUSTOM"
        hint = "Click 'Help' for detail."
      }
      spawnflags: =
      {
        typ = "X128"
        cap = "COMBAT"
        hint = "Click 'Help' for detail."
      }
      setnodeanim: =
      {
        txt = "&"
        hint = "Sets the animation that the AI will run while on this node."
      }
      setnodeentrythread: =
      {
        txt = "&"
        hint = "Sets the thread that the AI will call when they arrive at this node."
      }
      setnodeexitthread: =
      {
        txt = "&"
        hint = "Sets the thread that the AI will call when they leave the node."
      }
      wait: =
      {
        txt = "&"
        hint = "Sets the time at this work node."
      }
      waitrandom: =
      {
        txt = "&"
        hint = "Sets a random waittime from 1 to the time specified."
      }
      waitforanim: =
      {
        Typ = "X1"
        Txt = "waitforanim"
        hint = "for 'WORK' type - Sets the actor to work until his animation is completed."
            $0D"for 'PATROL' type - Makes the AI pause long enough to complete his animation."
      }
      setnodeanim: =
      {
        txt = "&"
        hint = "Sets the animation that the AI will run while on this node."
      }
      animcount: =
      {
        txt = "&"
        hint = "Number of times the anim can be played."
      }
      animtarget: =
      {
        txt = "&"
        hint = "TargetName for a specific entity you wish to be animated."
      }
      animactive: =
      {
        typ = "C"
        txt = "&"
        hint = "Sets if the animation component is active."
            $0D"Click the 'Help Book' above for more detail."
        items =
            "true" $0D
            "false"
        values =
            "1" $0D
            "0"
      }
      setcovertype: =
      {
        Typ = "C"
        txt = "&"
        hint = "Click 'Help' for detail."
        items =
            "crate" $0D
            "wall"
        values =
            "crate" $0D
            "wall"
      }
      setcoverdir: =
      {
        Typ = "C"
        txt = "&"
        hint = "Click 'Help' for detail."
        items =
            "left" $0D
            "right" $0D
            "all"
        values =
            "left" $0D
            "right" $0D
            "all"
      }
      coveractive: =
      {
        Typ = "C"
        txt = "&"
        hint = "Click 'Help' for detail."
        items =
            "true" $0D
            "false"
        values =
            "1" $0D
            "0"
      }
      wait: =
      {
        txt = "&"
        hint = "Makes the AI pause at this node for the specifed amount of time."
      }
      waitrandom: =
      {
        txt = "&"
        hint = "Makes the AI pause for a random amount of time."
            $0D"(up to a max of the amount specified )"
      }
      wait: =
      {
        txt = "&"
        hint = "Specifies a maximum time the AI will sit at this Node."
      }
      attacktarget: =
      {
        txt = "&"
        hint = "Specifies a target to kill -- "
            $0D"If not specified, will try and snipe any enemies in view."
      }
      maxkills: =
      {
        txt = "&"
        hint = "Specifies the maximum number of kills at this Node."
      }
    }
    detail:form =
    {
      help = "Used to fake detail brushes, convenient for grouping"
      t_commonspecifics = !
    }
    func_group:form =
    {
      help = "Used to group brushes together just for editor convenience."
      t_commonspecifics = !
      type: =
      {
        txt = "&"
        hint = "group type."
      }
    }
    func_remove:form =
    {
      help = "Used for lighting and such."
      t_commonspecifics = !
    }
    misc_model:form =
    {
      help = $22"model"$22" arbitrary .tik file to display"
      bbox = '0 0 0 0 0 0'
      t_commonspecifics = !
      model: =
      {
        t_modelbrowser = !
        txt = "&"
        hint = "arbitrary .tik file to display"
      }
    }
    info_null:form =
    {
      help = "Used as a positional target for spotlights, etc."
      bbox = '-4 -4 -4 4 4 4'
    }
    info_notnull:form =
    {
      help = "Used as a positional target for lightning."
      bbox = '-4 -4 -4 4 4 4'
    }
    func_explodingwall:form =
    {
      help = "Blows up on activation or when attacked."
          $0D"    size of brush determines where explosions will occur."
      $0D"RANDOMANGLES - is set, object randomly spins while in the air."
      $0D"LANDSHATTER - is set, object shatters when it hits the ground."
      $0D"NOT_PLAYERS - is set, the trigger does not respond to players."
      $0D"MONSTERS - is set, the trigger will respond to monsters."
      $0D"PROJECTILES - is set, the trigger will respond to projectiles (rockets, grenades, etc.)."
      $0D"INVISIBLE - is set, these are invisible and not solid until triggered."
      $0D"ACCUMALATIVE - is set, damage is accumlative not threshold."
      $0D"TWOSTAGE - is set, object can be shattered once it lands on the ground."
      $0D22"explosions"$22" number of explosions to spawn ( default 1 )"
      $0D22"land_angles"$22" The angles you want this piece to"
      $0D"      orient to when it lands on the ground."
      $0D22"land_radius"$22" The distance of the ground the piece"
      $0D"      should be when on the ground ( default 16 )"
      $0D22"anglespeed"$22" Speed at which pieces rotate ( default 100 )"
      $0D"      if RANDOMANGLES ( default is 600 )"
      $0D22"key"$22" The item needed to activate this. (default nothing)"
      $0D22"base_velocity"$22" The speed that the debris will have when triggered.  (default 0 0 280)"
      $0D22"random_velocity"$22" The variation of the velocity."
      $0D"      x & y will be from -n < X,Y < n and z is 0 <= Z < n."
      $0D"      (default 140 140 140)"
      spawnflags: =
      {
        typ = "X1"
        cap = "RANDOMANGLES"
        hint = "is set, object randomly spins while in the air."
      }
      spawnflags: =
      {
        typ = "X2"
        cap = "LANDSHATTER"
        hint = "is set, object shatters when it hits the ground."
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
        hint = "is set, the trigger does not respond to players."
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "MONSTERS"
        hint = "is set, the trigger will respond to monsters."
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "PROJECTILES"
        hint = "is set, the trigger will respond to projectiles"
            $0D"(rockets, grenades, etc.)."
      }
      spawnflags: =
      {
        typ = "X32"
        cap = "INVISIBLE"
        hint = "is set, these are invisible and not solid until triggered."
      }
      spawnflags: =
      {
        typ = "X64"
        cap = "ACCUMALATIVE"
        hint = "is set, damage is accumlative not threshold."
      }
      spawnflags: =
      {
        typ = "X128"
        cap = "TWOSTAGE"
        hint = "is set, object can be shattered once it lands on the ground."
      }
      t_commonspecifics = !
      explosions: =
      {
        txt = "&"
        hint = "number of explosions to spawn ( default 1 )"
      }
      land_angles: =
      {
        txt = "&"
        hint = "The angles you want this piece to"
            $0D"orient to when it lands on the ground."
      }
      land_radius: =
      {
        txt = "&"
        hint = "The distance of the ground the piece"
            $0D"should be when on the ground ( default 16 )"
      }
      anglespeed: =
      {
        txt = "&"
        hint = "Speed at which pieces rotate ( default 100 )"
            $0D"if RANDOMANGLES ( default is 600 )"
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
      base_velocity: =
      {
        txt = "&"
        hint = "The speed that the debris will have when triggered."
            $0D"(default 0 0 280)"
      }
      random_velocity: =
      {
        txt = "&"
        hint = "The variation of the velocity."
            $0D"x & y will be from -n < X,Y < n and z is 0 <= Z < n."
            $0D"(default 140 140 140)"
      }
    }
    trigger_teleport:form =
    {
      help = "Touching this entity will teleport players to the targeted objec"
       "t."$0D22"key"$22" The item needed to activate this. (default nothing)"$0D
       $22"teleportthread"$22" The thread that is run when the player is telep"
       "orted"$0D"If NOT_PLAYERS is set, the teleporter does not teleport play"
       "ers"$0D"If NOT_MONSTERS is set, the teleporter does not teleport monst"
       "ers"$0D"If NOT_PROJECTILES is set, the teleporter does not teleport pr"
       "ojectiles (rockets, grenades, etc.)"$0D"If NO_EFFECTS is set, the spec"
       "ial effect will not happen and the teleport will be instant"$0D"If FAS"
       "T_EFFECTS is set, the teleport will be instant, and the effects will a"
       "ppear"
      spawnflags: =
      {
        typ = "X1"
        cap = "VISIBLE"
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "NOT_MONSTERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "NOT_PROJECTILES"
      }
      spawnflags: =
      {
        typ = "X32"
        cap = "NO_EFFECTS"
      }
      spawnflags: =
      {
        typ = "X64"
        cap = "FAST_EFFECTS"
      }
      t_commonspecifics = !
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
      teleportthread: =
      {
        txt = "&"
        hint = "The thread that is run when the player is teleported"
      }
    }
    func_teleportdest:form =
    {
      help = "Point trigger_teleport at these."
      bbox = '-32 -32 0 32 32 8'
      t_commonspecifics = !
    }
    func_useanim:form =
    {
      help = "This object allows you to place the player into a specific animation"
          $0D"   for the purposes of using an object within the world."
          $0D"This object should point at a func_useanimdest which contains specific"
          $0D"   information about how the player is supposed to be posed."
      $0D"VISIBLE - if this is checked the trigger itself will be visible."
      $0D"TOUCHABLE - if this is set we can activate the trigger by standing in it."
      $0D"CONTINUOUS - if this is checked the thing will re-trigger continously,"
      $0D"      otherwise it waits until the player has left the trigger field."
      $0D22"triggertarget"$22" what to trigger when used."
      $0D22"count"$22" how many times this should trigger (default -1, infinite)"
      $0D22"thread"$22" thread to fire when used"
      $0D22"delay"$22" how long it takes to be re-triggered ( default 3 seconds )"
      $0D22"key"$22" item needed to activate this"
      spawnflags: =
      {
        typ = "X1"
        cap = "VISIBLE"
        hint = "if this is checked the trigger itself will be visible."
      }
      spawnflags: =
      {
        typ = "X2"
        cap = "TOUCHABLE"
        hint = "if this is set we can activate the trigger by standing in it."
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "CONTINUOUS"
        hint = "if this is checked the thing will re-trigger continously,"
            $0D"otherwise it waits until the player has left the trigger field."
      }
      t_commonspecifics = !
      count: =
      {
        txt = "&"
        hint = "how many times this should trigger (default -1, infinite)"
      }
      thread: =
      {
        txt = "&"
        hint = "thread to fire when used."
      }
      triggertarget: =
      {
        txt = "&"
        hint = "what to trigger when used."
      }
      delay: =
      {
        txt = "&"
        hint = "how long it takes to be re-triggered ( default 3 seconds )"
      }
      key: =
      {
        txt = "&"
        hint = "item needed to activate this."
      }
    }
    func_useobject:form =
    {
      help = "Allows you to setup a special object that places the player into a specific state"
          $0D"   sequence.  Primarily used for levers and cranks."
          $0D"Object starts out in the 'start' animation, when used the following occurs:"
          $0D"   It is determined whether or not the player is in the right position to activate"
          $0D"   the object, if it is, the player is moved to the exact offset and angle specified"
          $0D"   by 'offset' and 'yaw_offset'.  The right position is determined by a dot product"
          $0D"   with 'offset' and 'yaw_offset'.  The 'cone' parameter controls the cone in which the"
          $0D"   object can be triggered. Once the player is in the right position, the player is placed"
          $0D"   into 'state' and the 'move' animation is played. Once the player animation ends, the"
          $0D"   'move_thread' will be called.  If the use button is continued to be held down and count"
          $0D"   is not finite, the animation will be continued to be played until the use key is held"
          $0D"   down.  Once the use key is let go, the 'stop' animation will be played on the lever and"
          $0D"   the 'stop_thread' will be called."
      $0D"MULTI-STATE - the object has two different states and must be used each time to set the state"
      $0D"      when multi state is active, the reset_thread is called instead of stop_thread.  All UseObjects"
      $0D"      have two states on and off.  When reset_time is set, the object will automatically return to the"
      $0D"      off state after a preset amount of time.  When multi-state is set this must be done manually."
      $0D""
      $0D22"triggertarget"$22" target to trigger when finished animating, if reset_time is set,"
      $0D"      target will be fired again when resetting."
      $0D22"activate"$22" turns the useobject on."
      $0D22"deactivate"$22" turns the useobject off."
      $0D22"offset"$22" vector offset of where the player should stand."
      $0D22"state"$22" state to go into when used."
      $0D22"state_backwards"$22" what state to use when reversing the object."
      $0D22"yaw_offset"$22" what direction the player should be facing when using the object."
      $0D22"cone"$22" the cone in which the object can be used."
      $0D22"count"$22" how many times this should trigger (default -1, infinite)"
      $0D22"move_thread"$22" thread that is fired when the object has cycled one animation."
      $0D22"stop_thread"$22" thread that is fired when the object has finished animating."
      $0D22"reset_thread"$22" thread that is fired when the object is resetting itself."
      $0D22"reset_time"$22" the time it takes for the object to reset, (default 0, it doesn't)"
      $0D22"damage_type"$22" if set, can be triggered by using a weapon to activate it."
      $0D"      If set to 'all', any damage will activate it."
      spawnflags: =
      {
        typ = "X1"
        cap = "MULTI-STATE"
        hint = "Click the 'Help Book' above for more detail."
      }
      t_commonspecifics = !
      move_thread: =
      {
        txt = "&"
        hint = "will be called. If the use button is continued to be held down and count"
            $0D"is not finite, the animation will be continued to be played until the use key is held"
            $0D"down. Once the use key is let go, the 'stop' animation will be played on the lever and"
            $0D"the 'stop_thread' will be called."
      }
      activate: =
      {
        txt = "&"
        hint = "turns the useobject on."
      }
      deactivate: =
      {
        txt = "&"
        hint = "turns the useobject off."
      }
      offset: =
      {
        txt = "&"
        hint = "vector offset of where the player should stand."
      }
      state: =
      {
        txt = "&"
        hint = "state to go into when used."
      }
      state_backwards: =
      {
        txt = "&"
        hint = "what state to use when reversing the object."
      }
      yaw_offset: =
      {
        txt = "&"
        hint = "what direction the player should be facing when using the object."
      }
      cone: =
      {
        txt = "&"
        hint = "the cone in which the object can be used."
      }
      count: =
      {
        txt = "&"
        hint = "how many times this should trigger (default -1, infinite)"
      }
      move_thread: =
      {
        txt = "&"
        hint = "thread that is fired when the object has cycled one animation."
      }
      stop_thread: =
      {
        txt = "&"
        hint = "thread that is fired when the object has finished animating."
      }
      reset_thread: =
      {
        txt = "&"
        hint = "thread that is fired when the object is resetting itself."
      }
      reset_time: =
      {
        txt = "&"
        hint = "the time it takes for the object to reset, (default 0, it doesn't)"
      }
      triggertarget: =
      {
        txt = "&"
        hint = "target to trigger when finished animating, if reset_time is set,"
            $0D"target will be fired again when resetting."
      }
      damage_type: =
      {
        txt = "&"
        hint = "If set, can be triggered by using a weapon to activate it."
            $0D"If set to 'all', any damage will activate it."
      }
      action_type: =
      {
        txt = "&"
        hint = "- sets the type of action to perform (for icon display)."
      }
    }
    info_waypoint:form =
    {
      help = "Used as a positioning device for objects."
      bbox = '-8 -8 -8 8 8 8'
    }
    func_pushobject:form =
    {
      help = "Pushable object."
      $0D22"dmg"$22" how much damage to cause when blocked.  (default 2)"
      $0D22"pushsound"$22" Sound to play when object is pushed (default is none)"
      t_commonspecifics = !
      type: =
      {
        txt = "&"
        hint = "group type."
      }
      dmg: =
      {
        txt = "&"
        hint = "how much damage to cause when blocked. (default 2)"
      }
      pushsound: =
      {
        txt = "&"
        hint = "Sound to play when object is pushed (default is none)"
        t_soundbrowser = !
      }
    }
    func_fallingrock:form =
    {
      help = "Creates a rock that, when triggered, begins falling and bounces along"
          $0D"     a path specified by targetname. Use info_waypoint for the path."
      $0D"AUTO_RESET - when done falling, automatically return to the start."
      $0D"NO_RANDOMNESS - don't use any randomness when making the rocks fall."
      $0D"REMOVE_ON_GROUND - remove the rocks when done."
      $0D22"targetname"$22" the path to follow."
      $0D22"dmg"$22" how much damage to cause creatures it hits (default 20)."
      $0D22"speed"$22" how fast to move (default 200)."
      $0D22"wait"$22" how long to wait before falling when triggered (default 0)."
      $0D22"noise"$22" sound to play when rock touches the world."
      spawnflags: =
      {
        typ = "X1"
        cap = "AUTO_RESET"
      }
      spawnflags: =
      {
        typ = "X2"
        cap = "NO_RANDOMNESS"
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "REMOVE_ON_GROUND"
      }
      t_commonspecifics = !
      dmg: =
      {
        txt = "&"
        hint = "how much damage to cause creatures it hits (default 20)."
      }
      speed: =
      {
        txt = "&"
        hint = "how fast to move (default 200)."
      }
      wait: =
      {
        txt = "&"
        hint = "how long to wait before falling when triggered (default 0)."
      }
      noise: =
      {
        txt = "&"
        hint = "sound to play when rock touches the world."
        t_soundbrowser = !
      }
    }
    func_emitter:form =
    {
      help = $22"emitter"$22" - Name of emitter to use."
      t_commonspecifics = !
      emitter: =
      {
        txt = "&"
        hint = "Name of emitter to use."
      }
    }
    func_rain:form =
    {
      help = "This creates a raining effect in the brush."
      $0D22"emitter"$22" Name of emitter to use for the rain."
      t_commonspecifics = !
      emitter: =
      {
        txt = "&"
        hint = "Name of emitter to use for the rain."
      }
    }
    info_pathnode:form =
    {
      help = "Navigate Path Node."
      $0D"FLEE - Marks the node as a safe place to flee to.  Actor will be removed when it reaches a flee node and is not visible to a player."
      $0D"DUCK - Marks the node as a good place to duck behind during weapon fire."
      $0D"COVER - Marks the node as a good place to hide behind during weapon fire."
      $0D"DOOR - Marks the node as a door node.  If an adjacent node has DOOR marked as well, the actor will only use the path if the door in between them is unlocked."
      $0D"JUMP - Marks the node as one to jump from when going to the node specified by target."
      $0D"LADDER - Marks the node as a good place to climb."
      $0D"ACTION - Marks the node for action."
      $0D"WORK - Marks the node as one that the Actor can do work (Animate) from."
      $0D"HIBERNATE - Marks the node as one that the Actor can go into hibernation ( Basically an AI Active Sleep ) at."
      bbox = '-24 -24 0 24 24 32'
      spawnflags: =
      {
        typ = "X1"
        cap = "FLEE"
        hint = "Marks the node as a safe place to flee to."
            $0D"Click the 'Help Book' above for more detail."
      }
      spawnflags: =
      {
        typ = "X2"
        cap = "DUCK"
        hint = "Marks the node as a good place to duck behind during weapon fire."
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "COVER"
        hint = "Marks the node as a good place to hide behind during weapon fire."
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "DOOR"
        hint = "Marks the node as a door node."
            $0D"Click the 'Help Book' above for more detail."
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "JUMP"
        hint = "Marks the node as one to jump from when going to the node specified by target."
      }
      spawnflags: =
      {
        typ = "X32"
        cap = "LADDER"
        hint = "Marks the node as a good place to climb."
      }
      spawnflags: =
      {
        typ = "X64"
        cap = "ACTION"
        hint = "Marks the node for action."
      }
      spawnflags: =
      {
        typ = "X128"
        cap = "WORK"
        hint = "Marks the node as one that the Actor can do work (Animate) from."
      }
      spawnflags: =
      {
        typ = "X256"
        cap = "HIBERNATE"
        hint = "Marks the node as one that the Actor can go into hibernation."
            $0D"Click the 'Help Book' above for more detail."
      }
    }
    func_throwobject:form =
    {
      help = "This is an object you can pickup and throw at people."
      bbox = '-16 -16 0 16 16 32'
      t_commonspecifics = !
    }
    info_player_start:form =
    {
      help = "The normal starting point for a level."$0D22"angle"$22" - the di"
       "rection the player should face"$0D22"thread"$22" - the thread that sho"
       "uld be called when spawned at this position"
      bbox = '-16 -16 0 16 16 96'
      angle: =
      {
        txt = "&"
        hint = "- the direction the player should face"
      }
      thread: =
      {
        txt = "&"
        hint = "- the thread that should be called when spawned at this position"
      }
    }
    info_player_deathmatch:form =
    {
      help = "potential spawning position for deathmatch games"$0D22"angle"$22
       " - the direction the player should face"$0D22"thread"$22" - the thread"
       " that should be called when spawned at this position"$0D22"spawnpoint_"
       "type"$22" - the named type of this spawnpoint"
      bbox = '-16 -16 0 16 16 96'
      angle: =
      {
        txt = "&"
        hint = "- the direction the player should face"
      }
      thread: =
      {
        txt = "&"
        hint = "- the thread that should be called when spawned at this position"
      }
      spawnpoint_type: =
      {
        txt = "&"
        hint = "- the named type of this spawnpoint"
      }
    }
    info_player_intermission:form =
    {
      help = "viewing point in between deathmatch levels"
      bbox = '-16 -16 0 16 16 96'
    }
    portal_surface:form =
    {
      help = "The portal surface nearest this entity will show a view from the"
       " targeted portal_camera, or a mirror view if untargeted."
      bbox = '-8 -8 -8 8 8 8'
      t_commonspecifics = !
    }
    portal_camera:form =
    {
      help = "The target for a portal_surface. You can set either angles or ta"
       "rget another entity to determine the direction of view."$0D22"roll"$22
       " an angle modifier to orient the camera around the target vector;"
      bbox = '-8 -8 -8 8 8 8'
      spawnflags: =
      {
        typ = "X1"
        cap = "slowrotate"
      }
      spawnflags: =
      {
        typ = "X2"
        cap = "fastrotate"
      }
      t_commonspecifics = !
      roll: =
      {
        txt = "&"
        hint = "an angle modifier to orient the camera around the target vector;"
      }
    }
    puzzle_object:form =
    {
      help = "Puzzle object is the basic framework for all the puzzles. It communicates"
      $0D"with the script through events and threads to process the puzzle state."
      $0D"All logic for the puzzle object exists in the script."
      $0D"The puzzle object contains four threads, which are ItemUsed, Solved, Canceled and Failed."
      $0D"These are explained in the Key Value Pairs section. The Puzzle object also contains an"
      $0D"item used string. This allows the level designer to specify the item the player must"
      $0D"use to activate the puzzle."
      $0D22"model"$22" the tiki model to use for the puzzle object."
      $0D22"puzzleobject_opendistance"$22" the amount of distance the player should be before the puzzle opens."
      $0D22"puzzleobject_itemtouse"$22" the name of the item the player must use to execute the puzzle."
      $0D22"puzzleobject_itemusedthread"$22" the name of the thread called when the item is used."
      $0D22"puzzleobject_failedthread"$22" the name of the thread called when the puzzle fails."
      $0D22"puzzleobject_canceledthread"$22" the name of the thread called when the puzzle is canceled."
      $0D22"puzzleobject_solvedthread"$22" the name of the thread called when the puzzle is solved."
      bbox = '-16 -16 0 16 16 32'
      t_commonspecifics = !
      model: =
      {
        txt = "&"
        t_modelbrowser = !
      }
      puzzleobject_opendistance: =
      {
        txt = "&"
        hint = "Tthe amount of distance the player should be before the puzzle opens."
      }
      puzzleobject_itemtouse: =
      {
        txt = "&"
        hint = "the name of the item the player must use to execute the puzzle."
      }
      puzzleobject_itemusedthread: =
      {
        txt = "&"
        hint = "the name of the thread called when the item is used."
      }
      puzzleobject_failedthread: =
      {
        txt = "&"
        hint = "the name of the thread called when the puzzle fails."
      }
      puzzleobject_canceledthread: =
      {
        txt = "&"
        hint = "the name of the thread called when the puzzle is canceled."
      }
      puzzleobject_solvedthread: =
      {
        txt = "&"
        hint = "the name of the thread called when the puzzle is solved."
      }
    }
    script_object:form =
    {
      spawnflags: =
      {
        typ = "X1"
        cap = "NOT_SOLID"
      }
      t_commonspecifics = !
    }
    script_model:form =
    {
      bbox = '0 0 0 0 0 0'
      spawnflags: =
      {
        typ = "X1"
        cap = "NOT_SOLID"
      }
      spawnflags: =
      {
        typ = "X2"
        cap = "LIT_STATIC"
      }
      t_commonspecifics = !
      model: =
      {
        txt = "&"
        t_modelbrowser = !
      }
    }
    script_origin:form =
    {
      help = "Used as an alternate origin for objects. Bind the object to the "
       "script_origin"$0D"in order to simulate changing that object's origin."
      bbox = '-8 -8 -8 8 8 8'
      t_commonspecifics = !
    }
    script_skyorigin:form =
    {
      help = "Used to specify the origin of a portal sky"
      t_commonspecifics = !
    }
    func_spawn:form =
    {
      help = "Spawn entity to use for .tik files."
      $0D22"modelName"$22" The name of the .tik file you wish to spawn. (Required)"
      $0D22"spawnTargetName"$22" This will be the targetname of the spawned model. (default is null)"
      $0D22"spawnTarget"$22" This will be the target of the spawned model. (default is null)"
      $0D22"pickupThread"$22" passed on to the spawned model"
      $0D22"key"$22" The item needed to activate this. (default nothing)"
      $0D22"attackMode"$22" Attacking mode of the spawned actor (default 0)"
      bbox = '-8 -8 -8 8 8 8'
      t_commonspecifics = !
      modelName: =
      {
        txt = "&"
        hint = "The name of the TIKI file you wish to spawn. (Required)"
        t_modelbrowser = !
      }
      spawnTargetName: =
      {
        txt = "&"
        hint = "This will be the targetname of the spawned model. (default is null)"
      }
      spawnTarget: =
      {
        txt = "&"
        hint = "This will be the target of the spawned model. (default is null)"
      }
      pickupThread: =
      {
        txt = "&"
        hint = "passed on to the spawned model"
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
      attackMode: =
      {
        txt = "&"
        hint = "Attacking mode of the spawned actor (default 0)"
      }
    }
    func_randomspawn:form =
    {
      help = "Spawn entity to use for .tik files."
      $0D22"modelName"$22" The name of the .tik file you wish to spawn. (Required)"
      $0D22"key"$22" The item needed to activate this. (default nothing)"
      $0D22"min_time"$22" The minimum time between spawns (default 0.2 seconds)"
      $0D22"max_time"$22" The maximum time between spawns (default 1 seconds)"
      bbox = '-8 -8 -8 8 8 8'
      spawnflags: =
      {
        typ = "X1"
        cap = "START_OFF"
      }
      t_commonspecifics = !
      modelName: =
      {
        txt = "&"
        hint = "The name of the TIKI file you wish to spawn. (Required)"
        t_modelbrowser = !
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
      min_time: =
      {
        txt = "&"
        hint = "The minimum time between spawns (default 0.2 seconds)"
      }
      max_time: =
      {
        txt = "&"
        hint = "The maximum time between spawns (default 1 seconds)"
      }
    }
    func_respawn:form =
    {
      help = "When the thing that is spawned is killed, this func_respawn will get triggered."
      $0D22"modelName"$22" The name of the .tik file you wish to spawn. (Required)"
      $0D22"key"$22" The item needed to activate this. (default nothing)"
      bbox = '-8 -8 -8 8 8 8'
      t_commonspecifics = !
      modelName: =
      {
        txt = "&"
        hint = "The name of the TIKI file you wish to spawn. (Required)"
        t_modelbrowser = !
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
    }
    func_spawnoutofsight:form =
    {
      help = "Will only spawn something out of sight of the players."$0D"By de"
       "fault, that means doing a trace from the spawner to the player."$0D"Us"
       "e 'checkFOV' to indicate that it's OK to spawn as long as the spawner "
       "is not in the player's FOV."$0D22"modelName"$22" The name of the TIKI "
       "file you wish to spawn. (Required)"$0D22"spawnTargetName"$22" This wil"
       "l be the targetname of the spawned model. (default is null)"$0D22"spaw"
       "nTarget"$22" This will be the target of the spawned model. (default is"
       " null)"$0D22"key"$22" The item needed to activate this. (default nothi"
       "ng)"$0D22"checkFOV"$22" The spawner will check that if it is in the pl"
       "ayers' FOV"
      bbox = '-8 -8 -8 8 8 8'
      t_commonspecifics = !
      modelName: =
      {
        t_modelbrowser = !
        txt = "&"
        hint = "The name of the TIKI file you wish to spawn. (Required)"
      }
      spawnTargetName: =
      {
        txt = "&"
        hint = "This will be the targetname of the spawned model. (default is null)"
      }
      spawnTarget: =
      {
        txt = "&"
        hint = "This will be the target of the spawned model. (default is null)"
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
      checkFOV: =
      {
        txt = "&"
        hint = "The spawner will check that if it is in the players' FOV"
      }
    }
    func_spawnchain:form =
    {
      help = "Tries to spawn something out of the sight of players."
          $0D"    If it fails, it will trigger its targets."
      $0D22"modelName"$22" The name of the .tik file you wish to spawn. (Required)"
      $0D22"spawnTargetName"$22" This will be the targetname of the spawned model. (default is null)"
      $0D22"spawnTarget"$22" This will be the target of the spawned model. (default is null)"
      $0D22"key"$22" The item needed to activate this. (default nothing)"
      bbox = '-8 -8 -8 8 8 8'
      t_commonspecifics = !
      modelName: =
      {
        txt = "&"
        hint = "The name of the TIKI file you wish to spawn. (Required)"
        t_modelbrowser = !
      }
      spawnTargetName: =
      {
        txt = "&"
        hint = "This will be the targetname of the spawned model. (default is null)"
      }
      spawnTarget: =
      {
        txt = "&"
        hint = "This will be the target of the spawned model. (default is null)"
      }
      use_3rd_person_camera: =
      {
        txt = "&"
        hint = "Whether or not to check from the camera or character.(default false)"
      }
    }
    func_fulcrum:form =
    {
      help = "This creates a fulcrum that when you stand on it, it will rotate due to"
          $0D"    the weight exerted it will start rotating, when not standing on it,"
          $0D"    it will return to its rest position."
      $0D"X_AXIS_ONLY - only adjust the X axis."
      $0D"Y_AXIS_ONLY - only adjust the Y axis."
      $0D22"speed"$22" set the speed at which the fulcrum will operate (default is 48)"
      $0D22"resetspeed"$22" speed at whcih fulcrum resets, (default speed * 0.002)"
      $0D22"dampening"$22" dampen constant (default 0.95)"
      $0D22"limit"$22" limit the movement of the fulcrum (default 90 degrees)"
      $0D22"movesound"$22" sound to be played while fulcrum is moving"
      spawnflags: =
      {
        typ = "X1"
        cap = "X_AXIS_ONLY"
        hint = "only adjust the X axis."
      }
      spawnflags: =
      {
        typ = "X2"
        cap = "Y_AXIS_ONLY"
        hint = "only adjust the Y axis."
      }
      t_commonspecifics = !
      speed: =
      {
        txt = "&"
        hint = "set the speed at which the fulcrum will operate (default is 48)"
      }
      resetspeed: =
      {
        txt = "&"
        hint = "speed at whcih fulcrum resets, (default speed * 0.002)"
      }
      dampening: =
      {
        txt = "&"
        hint = "dampen constant (default 0.95)"
      }
      limit: =
      {
        txt = "&"
        hint = "limit the movement of the fulcrum (default 90 degrees)"
      }
      movesound: =
      {
        txt = "&"
        hint = "sound to be played while fulcrum is moving"
        t_soundbrowser = !
      }
    }
    func_runthrough:form =
    {
      help = "This is a trigger field that the player can run through and spawn .tik models at that position."
          $0D"    Used for releasing chaff from grass or butterflys from flower gardens"
      $0D22"speed"$22" speed at which you have to be moving to trigger ( default 100 )"
      $0D22"delay"$22" time between triggering ( default 0.1 )"
      $0D22"chance"$22" chance that the trigger will spawn something( default 0.5 )"
      $0D22"lip"$22" how far below the surface of the trigger we should spawn these things ( default 3 )"
      $0D22"offset"$22" vector offset oriented along velocity vector( default '0 0 0' )"
      $0D22"spawnmodel"$22" thing to spawn when triggered"
      t_commonspecifics = !
      speed: =
      {
        txt = "&"
        hint = "speed at which you have to be moving to trigger ( default 100 )"
      }
      delay: =
      {
        txt = "&"
        hint = "time between triggering ( default 0.1 )"
      }
      chance: =
      {
        txt = "&"
        hint = "chance that the trigger will spawn something( default 0.5 )"
      }
      lip: =
      {
        txt = "&"
        hint = "how far below the surface of the trigger we should spawn these things ( default 3 )"
      }
      offset: =
      {
        txt = "&"
        hint = "vector offset oriented along velocity vector( default '0 0 0' )"
      }
      spawnmodel: =
      {
        txt = "&"
        hint = "- thing to spawn when triggered"
        t_modelbrowser = !
      }
    }
    func_sinkobject:form =
    {
      help = "This creates an object which gradually sinks downward when stepped on."
      $0D" FALLAWAY - the sink object will progressively fall down faster and faster."
      $0D"NO_RESET - the sink object will not reset, only move downward."
      $0D22"delay"$22" delay between when object starts reacting towards weight (default 0 seconds)"
      $0D22"speed"$22" set the speed at which sinkobject sinks (default is 50)"
      $0D22"resetspeed"$22" speed at which sinkobject resets its position, (default speed * 0.1)"
      $0D22"dampening"$22" dampening constant to mitigate acceleration (default 0.95)"
      $0D22"limit"$22" limit the movement of the sinkobject how far down it should go (default 1000 units)"
      $0D22"resetdelay"$22" time between player gets off platform, and platform starts resetting itself."
      $0D22"sinksound"$22" sound to be played while platform is sinking."
      $0D22"resetsound"$22" sound to be played while platform is resetting."
      $0D22"active"$22" make the sink object active"
      $0D22"notactive"$22" make the sink object not active"
      spawnflags: =
      {
        typ = "X2"
        cap = "FALLAWAY"
        hint = "the sink object will progressively fall down faster and faster."
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "NO_RESET"
        hint = "the sink object will not reset, only move downward."
      }
      t_commonspecifics = !
      delay: =
      {
        txt = "&"
        hint = "delay between when object starts reacting towards weight (default 0 seconds)"
      }
      speed: =
      {
        txt = "&"
        hint = "set the speed at which sinkobject sinks (default is 50)"
      }
      resetspeed: =
      {
        txt = "&"
        hint = "speed at which sinkobject resets its position, (default speed * 0.1)"
      }
      dampening: =
      {
        txt = "&"
        hint = "dampening constant to mitigate acceleration (default 0.95)"
      }
      limit: =
      {
        txt = "&"
        hint = "limit the movement of the sinkobject how far down it should go (default 1000 units)"
      }
      resetdelay: =
      {
        txt = "&"
        hint = "time between player gets off platform, and platform starts resetting itself."
      }
      sinksound: =
      {
        txt = "&"
        hint = "sound to be played while platform is sinking."
        t_soundbrowser = !
      }
      resetsound: =
      {
        txt = "&"
        hint = "sound to be played while platform is resetting."
        t_soundbrowser = !
      }
      active: =
      {
        txt = "&"
        hint = "make the sink object active"
      }
      notactive: =
      {
        txt = "&"
        hint = "make the sink object not active"
      }
    }
    trigger_multiple:form =
    {
      help = "Variable sized repeatable trigger. Must be targeted at one or mo"
       "re entities."$0D22"delay"$22" if set, the trigger waits some time afte"
       "r activating before firing."$0D22"destructible"$22" if set, the trigge"
       "r will take damage and lose health."$0D22"triggerondamage"$22" if set,"
       " trigger will fire when ever it takes damage."$0D22"triggerondeath"$22
       " if set, trigger will fire when it dies. This forces destructible"$0D"t"
       "o be on, since it would otherwise never die."$0D22"instantdeath"$22" i"
       "f set, trigger will die when it takes damage of this type."$0D"To make"
       " a trigger fire every time it takes damage set triggerondamage to true"
       ". To make a"$0D"trigger fire everytime it takes damage and to eventual"
       "ly die, set triggerondamage"$0D"to true, destructible to true, and giv"
       "e it a health. To make a trigger that"$0D"triggers on death only, set "
       "triggerondeath to be true. This will also turn"$0D"on destructible. To"
       " make a trigger that triggers everytime it takes damage"$0D"and when i"
       "t dies, set both triggerondamage to be true and triggerondeath to"$0D"b"
       "e true."$0D22"thread"$22" name of thread to trigger. This can be in a "
       "different script file as well"$0D"by using the '::' notation."$0D22"an"
       "gle"$22" if set, the trigger will only fire when someone is facing the"
       $0D"direction of the angle."$0D22"cone"$22" the cone in which a directe"
       "d trigger can be triggered (default 60 degrees)"$0D22"wait"$22" : Seco"
       "nds between triggerings. (.2 default)"$0D22"cnt"$22" how many times it"
       " can be triggered (infinite default)"$0D22"triggerable"$22" turn trigg"
       "er on"$0D22"nottriggerable"$22" turn trigger off"$0D"If NOT_PLAYERS is"
       " set, the trigger does not respond to players"$0D"If MONSTERS is set, "
       "the trigger will respond to monsters"$0D"If PROJECTILES is set, the tr"
       "igger will respond to projectiles (rockets, grenades, etc.)"$0D"if SCR"
       "IPTSLAVE is set, the trigger will respond to script slaves"$0D22"messa"
       "ge"$22" set to text string"
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "MONSTERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "PROJECTILES"
      }
      spawnflags: =
      {
        typ = "X32"
        cap = "SCRIPTSLAVE"
      }
      t_commonspecifics = !
      delay: =
      {
        txt = "&"
        hint = "if set, the trigger waits some time after activating before firing."
      }
      destructible: =
      {
        txt = "&"
        hint = "if set, the trigger will take damage and lose health."
      }
      triggerondamage: =
      {
        txt = "&"
        hint = "if set, trigger will fire when ever it takes damage."
      }
      triggerondeath: =
      {
        txt = "&"
        hint = "if set, trigger will fire when it dies. This forces destructible"
            $0D"to be on, since it would otherwise never die."
      }
      instantdeath: =
      {
        txt = "&"
        hint = "if set, trigger will die when it takes damage of this type."
      }
      thread: =
      {
        txt = "&"
        hint = "name of thread to trigger. This can be in a different script file as well"
            $0D"by using the '::' notation."
      }
      angle: =
      {
        txt = "&"
        hint = "if set, the trigger will only fire when someone is facing the"
            $0D"direction of the angle."
      }
      cone: =
      {
        txt = "&"
        hint = "the cone in which a directed trigger can be triggered"
            $0D" (default 60 degrees)"
      }
      wait: =
      {
        txt = "&"
        hint = ": Seconds between triggerings. (.2 default)"
      }
      cnt: =
      {
        txt = "&"
        hint = "how many times it can be triggered (infinite default)"
      }
      triggerable: =
      {
        txt = "&"
        hint = "turn trigger on"
      }
      nottriggerable: =
      {
        txt = "&"
        hint = "turn trigger off"
      }
      message: =
      {
        txt = "&"
        hint = "set to text string"
      }
    }
    trigger_once:form =
    {
      help = "Variable sized trigger. Triggers once, then removes itself."$0D"Y"
       "ou must set the key 'target' to the name of another object in the"$0D"l"
       "evel that has a matching"$0D22"health"$22" if set, the trigger must be"
       " killed to activate it."$0D22"delay"$22" if set, the trigger waits som"
       "e time after activating before firing."$0D22"targetname"$22". If 'heal"
       "th' is set, the trigger must be killed to activate."$0D22"thread"$22" "
       "name of thread to trigger. This can be in a different script file as w"
       "ell"$0D"by using the '::' notation."$0D22"killtarget"$22" if set, any "
       "objects that have a matching 'target' will be"$0D"removed when the tri"
       "gger is fired."$0D22"angle"$22" if set, the trigger will only fire whe"
       "n someone is facing the"$0D"direction of the angle."$0D22"cone"$22" th"
       "e cone in which a directed trigger can be triggered (default 60 degree"
       "s)"$0D22"key"$22" The item needed to activate this. (default nothing)"$0D
       $22"triggerable"$22" turn trigger on"$0D22"nottriggerable"$22" turn tri"
       "gger off"$0D"If NOTOUCH is set, trigger will not respond to touch"$0D"I"
       "f NOT_PLAYERS is set, the trigger does not respond to players"$0D"If M"
       "ONSTERS is set, the trigger will respond to monsters"$0D"If PROJECTILE"
       "S is set, the trigger will respond to projectiles (rockets, grenades, "
       "etc.)"$0D"If SCRIPTSLAVE is set, the trigger will respond to script sl"
       "aves"$0D22"message"$22" set to text string"
      spawnflags: =
      {
        typ = "X1"
        cap = "NOTOUCH"
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "MONSTERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "PROJECTILES"
      }
      spawnflags: =
      {
        typ = "X32"
        cap = "SCRIPTSLAVE"
      }
      t_commonspecifics = !
      health: =
      {
        txt = "&"
        hint = "if set, the trigger must be killed to activate it."
      }
      delay: =
      {
        txt = "&"
        hint = "if set, the trigger waits some time after activating before firing."
      }
      thread: =
      {
        txt = "&"
        hint = "name of thread to trigger. This can be in a different script file as well"
            $0D"by using the '::' notation."
      }
      killtarget: =
      {
        txt = "&"
        hint = "if set, any objects that have a matching 'target' will be"
            $0D"removed when the trigger is fired."
      }
      angle: =
      {
        txt = "&"
        hint = "if set, the trigger will only fire when someone is facing the"
            $0D"direction of the angle."
      }
      cone: =
      {
        txt = "&"
        hint = "the cone in which a directed trigger can be triggered (default 60 degrees)"
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
      triggerable: =
      {
        txt = "&"
        hint = "turn trigger on"
      }
      nottriggerable: =
      {
        txt = "&"
        hint = "turn trigger off"
      }
      message: =
      {
        txt = "&"
        hint = "set to text string"
      }
    }
    trigger_relay:form =
    {
      help = "This fixed size trigger cannot be touched, it can only be fired "
       "by other events."$0D"It can contain killtargets, targets, delays, and "
       "messages."$0D"If NOT_PLAYERS is set, the trigger does not respond to e"
       "vents triggered by players"$0D"If MONSTERS is set, the trigger will re"
       "spond to events triggered by monsters"$0D"If PROJECTILES is set, the t"
       "rigger will respond to events triggered by projectiles (rockets, grena"
       "des, etc.)"
      bbox = '-8 -8 -8 8 8 8'
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "MONSTERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "PROJECTILES"
      }
      t_commonspecifics = !
    }
    trigger_secret:form =
    {
      help = "Secret counter trigger. Automatically sets and increments script"
       " variables"$0D"level.total_secrets and level.found_secrets."$0D22"mess"
       "age"$22" set to text string"$0D22"key"$22" The item needed to activate"
       " this. (default nothing)"$0D22"angle"$22" if set, the trigger will onl"
       "y fire when someone is facing the"$0D"direction of the angle."$0D22"co"
       "ne"$22" the cone in which a directed trigger can be triggered (default"
       " 60 degrees)"$0D22"thread"$22" name of thread to trigger. This can be "
       "in a different script file as well"$0D"by using the '::' notation. (de"
       "faults to 'global/universal_script.scr::secret')"$0D22"triggerable"$22
       " turn trigger on"$0D22"nottriggerable"$22" turn trigger off"$0D"If NOT"
       "OUCH is set, trigger will not respond to touch"$0D"If NOT_PLAYERS is s"
       "et, the trigger does not respond to players"$0D"If MONSTERS is set, th"
       "e trigger will respond to monsters"$0D"If PROJECTILES is set, the trig"
       "ger will respond to projectiles (rockets, grenades, etc.)"
      spawnflags: =
      {
        typ = "X1"
        cap = "NOTOUCH"
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "MONSTERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "PROJECTILES"
      }
      t_commonspecifics = !
      message: =
      {
        txt = "&"
        hint = "set to text string"
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
      angle: =
      {
        txt = "&"
        hint = "if set, the trigger will only fire when someone is facing the"
            $0D"direction of the angle."
      }
      cone: =
      {
        txt = "&"
        hint = "the cone in which a directed trigger can be triggered (default 60 degrees)"
      }
      thread: =
      {
        txt = "&"
        hint = "name of thread to trigger. This can be in a different script file as well"
            $0D"by using the '::' notation. (defaults to 'global/universal_script.scr::secret')"
      }
      triggerable: =
      {
        txt = "&"
        hint = "turn trigger on"
      }
      nottriggerable: =
      {
        txt = "&"
        hint = "turn trigger off"
      }
    }
    trigger_setvariable:form =
    {
      help = "Sets a variable specified by 'variable' and 'value'."$0D"Variabl"
       "e is assumed to be of the 'global' variety unless LEVEL is set."$0D"Va"
       "riable sized trigger. Triggers once by default."$0D"You must set the k"
       "ey 'target' to the name of another object in the"$0D"level that has a "
       "matching"$0D22"variable"$22" - variable to set"$0D22"value"$22" - valu"
       "e to set in variable, value can also be one of the following reserved"$0D
       "tokens."$0D"- 'increment' - add one to the variable"$0D"- 'decrement' "
       "- subtract one from the variable"$0D"- 'toggle' - if 1, then zero. If "
       "zero then 1."$0D22"health"$22" if set, the trigger must be killed to a"
       "ctivate it."$0D22"delay"$22" if set, the trigger waits some time after"
       " activating before firing."$0D22"targetname"$22". If 'health' is set, "
       "the trigger must be killed to activate."$0D22"thread"$22" name of thre"
       "ad to trigger. This can be in a different script file as well"$0D"by u"
       "sing the '::' notation."$0D22"killtarget"$22" if set, any objects that"
       " have a matching 'target' will be"$0D"removed when the trigger is fire"
       "d."$0D22"angle"$22" if set, the trigger will only fire when someone is"
       " facing the"$0D"direction of the angle."$0D22"cone"$22" the cone in wh"
       "ich a directed trigger can be triggered (default 60 degrees)"$0D22"key"
       $22" The item needed to activate this. (default nothing)"$0D22"triggera"
       "ble"$22" turn trigger on"$0D22"nottriggerable"$22" turn trigger off"$0D
       "If NOTOUCH is set, trigger will not respond to touch"$0D"if LEVEL is s"
       "et, variable will be a level variable otherwise it will be a game vari"
       "able"$0D"If NOT_PLAYERS is set, the trigger does not respond to player"
       "s"$0D"If MONSTERS is set, the trigger will respond to monsters"$0D"If "
       "PROJECTILES is set, the trigger will respond to projectiles (rockets, "
       "grenades, etc.)"$0D22"message"$22" set to text string"
      spawnflags: =
      {
        typ = "X1"
        cap = "NOTOUCH"
      }
      spawnflags: =
      {
        typ = "X2"
        cap = "LEVEL"
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "MONSTERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "PROJECTILES"
      }
      t_commonspecifics = !
      variable: =
      {
        txt = "&"
        hint = "- variable to set"
      }
      value: =
      {
        txt = "&"
        hint = "- value to set in variable, value can also be one of the following reserved"
            $0D"tokens."
            $0D"- 'increment' - add one to the variable"
            $0D"- 'decrement' - subtract one from the variable"
            $0D"- 'toggle' - if 1, then zero. If zero then 1."
      }
      health: =
      {
        txt = "&"
        hint = "if set, the trigger must be killed to activate it."
      }
      delay: =
      {
        txt = "&"
        hint = "if set, the trigger waits some time after activating before firing."
      }
      thread: =
      {
        txt = "&"
        hint = "name of thread to trigger. This can be in a different script file as well"
            $0D"by using the '::' notation."
      }
      killtarget: =
      {
        txt = "&"
        hint = "if set, any objects that have a matching 'target' will be"
            $0D"removed when the trigger is fired."
      }
      angle: =
      {
        txt = "&"
        hint = "if set, the trigger will only fire when someone is facing the"
            $0D"direction of the angle."
      }
      cone: =
      {
        txt = "&"
        hint = "the cone in which a directed trigger can be triggered (default 60 degrees)"
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
      triggerable: =
      {
        txt = "&"
        hint = "turn trigger on"
      }
      nottriggerable: =
      {
        txt = "&"
        hint = "turn trigger off"
      }
      message: =
      {
        txt = "&"
        hint = "set to text string"
      }
    }
    trigger_push:form =
    {
      help = "Pushes entities as if they were caught in a heavy wind."$0D22"sp"
       "eed"$22" indicates the rate that entities are pushed (default 1000)."$0D
       $22"angle"$22" indicates the direction the wind is blowing (-1 is up, -"
       "2 is down)"$0D22"key"$22" The item needed to activate this. (default n"
       "othing)"$0D22"target"$22" if target is set, then a velocity will be ca"
       "lculated based on speed"$0D22"triggerable"$22" turn trigger on"$0D22"n"
       "ottriggerable"$22" turn trigger off"$0D"If NOT_PLAYERS is set, the tri"
       "gger does not push players"$0D"If NOT_MONSTERS is set, the trigger wil"
       "l not push monsters"$0D"If NOT_PROJECTILES is set, the trigger will no"
       "t push projectiles (rockets, grenades, etc.)"
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "NOT_MONSTERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "NOT_PROJECTILES"
      }
      t_commonspecifics = !
      speed: =
      {
        txt = "&"
        hint = "indicates the rate that entities are pushed (default 1000)."
      }
      angle: =
      {
        txt = "&"
        hint = "indicates the direction the wind is blowing (-1 is up, -2 is down)"
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
      triggerable: =
      {
        txt = "&"
        hint = "turn trigger on"
      }
      nottriggerable: =
      {
        txt = "&"
        hint = "turn trigger off"
      }
    }
    trigger_pushany:form =
    {
      help = "Pushes entities as if they were caught in a heavy wind."$0D22"sp"
       "eed"$22" indicates the rate that entities are pushed (default 1000)."$0D
       $22"angles"$22" indicates the direction of the push"$0D22"key"$22" The "
       "item needed to activate this. (default nothing)"$0D22"target"$22" if t"
       "arget is set, then a velocity will be calculated based on speed"$0D22"t"
       "riggerable"$22" turn trigger on"$0D22"nottriggerable"$22" turn trigger"
       " off"$0D"If NOT_PLAYERS is set, the trigger does not push players"$0D"I"
       "f NOT_MONSTERS is set, the trigger will not push monsters"$0D"If NOT_P"
       "ROJECTILES is set, the trigger will not push projectiles (rockets, gre"
       "nades, etc.)"
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "NOT_MONSTERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "NOT_PROJECTILES"
      }
      t_commonspecifics = !
      speed: =
      {
        txt = "&"
        hint = "indicates the rate that entities are pushed (default 1000)."
      }
      angles: =
      {
        txt = "&"
        hint = "indicates the direction of the push"
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
      triggerable: =
      {
        txt = "&"
        hint = "turn trigger on"
      }
      nottriggerable: =
      {
        txt = "&"
        hint = "turn trigger off"
      }
    }
    sound_speaker:form =
    {
      help = "play a sound when it is used"$0D"AMBIENT-ON specifies an ambient"
       " sound that starts on"$0D"AMBIENT-OFF specifies an ambient sound that "
       "starts off"$0D"TOGGLE specifies that the speaker toggles on triggering"
       $0D"if (AMBIENT-?) is not set, then the sound is sent over explicitly t"
       "his creates more net traffic"$0D22"volume"$22" how loud 0-4 (1 default"
       " full volume, ambients do not respond to volume)"$0D22"noise"$22" soun"
       "d to play"$0D22"channel"$22" channel on which to play sound"$0D"(0 aut"
       "o, 1 weapon, 2 voice, 3 item, 4 body, 8 don't use PHS) (voice is defau"
       "lt)"$0D22"key"$22" The item needed to activate this. (default nothing)"
       $0D22"thread"$22" name of thread to trigger. This can be in a different"
       " script file as well"$0D"by using the '::' notation."$0D"Normal sounds"
       " play each time the target is used."$0D"Ambient Looped sounds have a v"
       "olume 1, and the use function toggles it on/off."$0D"If NOT_PLAYERS is"
       " set, the trigger does not respond to players"$0D"If MONSTERS is set, "
       "the trigger will respond to monsters"$0D"If PROJECTILES is set, the tr"
       "igger will respond to projectiles (rockets, grenades, etc.)"
      bbox = '-8 -8 -8 8 8 8'
      spawnflags: =
      {
        typ = "X1"
        cap = "AMBIENT-ON"
      }
      spawnflags: =
      {
        typ = "X2"
        cap = "AMBIENT-OFF"
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "MONSTERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "PROJECTILES"
      }
      spawnflags: =
      {
        typ = "X32"
        cap = "TOGGLE"
      }
      t_commonspecifics = !
      volume: =
      {
        txt = "&"
        hint = "how loud 0-4 (1 default full volume, ambients do not respond to volume)"
      }
      noise: =
      {
        txt = "&"
        hint = "sound to play"
        t_soundbrowser = !
      }
      channel: =
      {
        txt = "&"
        hint = "channel on which to play sound"
            $0D"(0 auto, 1 weapon, 2 voice, 3 item, 4 body, 8 don't use PHS) (voice is default)"
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
      thread: =
      {
        txt = "&"
        hint = "name of thread to trigger. This can be in a different script file as well"
            $0D"by using the '::' notation."
      }
    }
    sound_randomspeaker:form =
    {
      help = "play a sound at random times"$0D22"mindelay"$22" minimum delay b"
       "etween sound triggers (default 3)"$0D22"maxdelay"$22" maximum delay be"
       "tween sound triggers (default 10)"$0D22"chance"$22" chance that sound "
       "will play when fired (default 1)"$0D22"volume"$22" how loud 0-4 (1 def"
       "ault full volume)"$0D22"noise"$22" sound to play"$0D22"channel"$22" ch"
       "annel on which to play sound"$0D"(0 auto, 1 weapon, 2 voice, 3 item, 4"
       " body, 8 don't use PHS) (voice is default)"$0D22"key"$22" The item nee"
       "ded to activate this. (default nothing)"$0D"Normal sounds play each ti"
       "me the target is used."$0D"If NOT_PLAYERS is set, the trigger does not"
       " respond to players"$0D"If MONSTERS is set, the trigger will respond t"
       "o monsters"$0D"If PROJECTILES is set, the trigger will respond to proj"
       "ectiles (rockets, grenades, etc.)"
      bbox = '-8 -8 -8 8 8 8'
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "MONSTERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "PROJECTILES"
      }
      t_commonspecifics = !
      mindelay: =
      {
        txt = "&"
        hint = "minimum delay between sound triggers (default 3)"
      }
      maxdelay: =
      {
        txt = "&"
        hint = "maximum delay between sound triggers (default 10)"
      }
      chance: =
      {
        txt = "&"
        hint = "chance that sound will play when fired (default 1)"
      }
      volume: =
      {
        txt = "&"
        hint = "how loud 0-4 (1 default full volume)"
      }
      noise: =
      {
        txt = "&"
        hint = "sound to play"
        t_soundbrowser = !
      }
      channel: =
      {
        txt = "&"
        hint = "channel on which to play sound"
            $0D"(0 auto, 1 weapon, 2 voice, 3 item, 4 body, 8 don't use PHS) (voice is default)"
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
    }
    trigger_changelevel:form =
    {
      help = "When the player touches this, he gets sent to the map listed in "
       "the 'map' variable."$0D"Unless the NO_INTERMISSION flag is set, the vi"
       "ew will go to the info_intermission"$0D"spot and display stats."$0D22"s"
       "pawnspot"$22" name of the spawn location to start at in next map."$0D22
       "key"$22" The item needed to activate this. (default nothing)"$0D22"thr"
       "ead"$22" This defaults to 'LevelComplete' and should point to a thread"
       " that is called just"$0D"before the level ends."$0D22"triggerable"$22" "
       "turn trigger on"$0D22"nottriggerable"$22" turn trigger off"$0D"If NOT_"
       "PLAYERS is set, the trigger does not respond to players"$0D"If MONSTER"
       "S is set, the trigger will respond to monsters"$0D"If PROJECTILES is s"
       "et, the trigger will respond to projectiles (rockets, grenades, etc.)"
      spawnflags: =
      {
        typ = "X1"
        cap = "NO_INTERMISSION"
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "MONSTERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "PROJECTILES"
      }
      t_commonspecifics = !
      spawnspot: =
      {
        txt = "&"
        hint = "name of the spawn location to start at in next map."
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
      thread: =
      {
        txt = "&"
        hint = "This defaults to 'LevelComplete' and should point to a thread that is called just"
            $0D"before the level ends."
      }
      triggerable: =
      {
        txt = "&"
        hint = "turn trigger on"
      }
      nottriggerable: =
      {
        txt = "&"
        hint = "turn trigger off"
      }
    }
    trigger_use:form =
    {
      help = "Activates targets when 'used' by an entity"$0D22"key"$22" The it"
       "em needed to activate this. (default nothing)"$0D22"thread"$22" name o"
       "f thread to trigger. This can be in a different script file as well"$0D
       "by using the '::' notation."$0D22"triggerable"$22" turn trigger on"$0D
       $22"nottriggerable"$22" turn trigger off"$0D"If NOT_PLAYERS is set, the"
       " trigger does not respond to players"$0D"If MONSTERS is set, the trigg"
       "er will respond to monsters"
      spawnflags: =
      {
        typ = "X1"
        cap = "VISIBLE"
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "MONSTERS"
      }
      t_commonspecifics = !
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
      thread: =
      {
        txt = "&"
        hint = "name of thread to trigger. This can be in a different script file as well"
            $0D"by using the '::' notation."
      }
      triggerable: =
      {
        txt = "&"
        hint = "turn trigger on"
      }
      nottriggerable: =
      {
        txt = "&"
        hint = "turn trigger off"
      }
    }
    trigger_useonce:form =
    {
      help = "Activates targets when 'used' by an entity, but only once"$0D22"k"
       "ey"$22" The item needed to activate this. (default nothing)"$0D22"thre"
       "ad"$22" name of thread to trigger. This can be in a different script f"
       "ile as well"$0D"by using the '::' notation."$0D22"triggerable"$22" tur"
       "n trigger on"$0D22"nottriggerable"$22" turn trigger off"$0D"If NOT_PLA"
       "YERS is set, the trigger does not respond to players"$0D"If MONSTERS i"
       "s set, the trigger will respond to monsters"
      spawnflags: =
      {
        typ = "X1"
        cap = "VISIBLE"
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "MONSTERS"
      }
      t_commonspecifics = !
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
      thread: =
      {
        txt = "&"
        hint = "name of thread to trigger. This can be in a different script file as well"
            $0D"by using the '::' notation."
      }
      triggerable: =
      {
        txt = "&"
        hint = "turn trigger on"
      }
      nottriggerable: =
      {
        txt = "&"
        hint = "turn trigger off"
      }
    }
    trigger_hurt:form =
    {
      help = $22"damage"$22" amount of damage to cause. (default 10)"$0D22"key"
       $22" The item needed to activate this. (default nothing)"$0D22"damagety"
       "pe"$22" what kind of damage should be given to the player. (default CR"
       "USH)"$0D22"triggerable"$22" turn trigger on"$0D22"nottriggerable"$22" "
       "turn trigger off"$0D"If NOT_PLAYERS is set, the trigger does not hurt "
       "players"$0D"If NOT_MONSTERS is set, the trigger does not hurt monsters"
       $0D"If PROJECTILES is set, the trigger will hurt projectiles (rockets, "
       "grenades, etc.)"
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "NOT_MONSTERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "PROJECTILES"
      }
      t_commonspecifics = !
      damage: =
      {
        txt = "&"
        hint = "amount of damage to cause. (default 10)"
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
      damagetype: =
      {
        txt = "&"
        hint = "what kind of damage should be given to the player. (default CRUSH)"
      }
      triggerable: =
      {
        txt = "&"
        hint = "turn trigger on"
      }
      nottriggerable: =
      {
        txt = "&"
        hint = "turn trigger off"
      }
    }
    trigger_damagetargets:form =
    {
      help = $22"damage"$22" amount of damage to cause. If no damage is specif"
       "ied, objects"$0D"are damaged by the current health+1"$0D22"key"$22" Th"
       "e item needed to activate this. (default nothing)"$0D"if a trigger_dam"
       "agetargets is shot at and the SOLID flag is set,"$0D"the damage is pas"
       "sed on to the targets"$0D22"triggerable"$22" turn trigger on"$0D22"not"
       "triggerable"$22" turn trigger off"$0D"If NOT_PLAYERS is set, the trigg"
       "er does not hurt players"$0D"If NOT_MONSTERS is set, the trigger does "
       "not hurt monsters"$0D"If PROJECTILES is set, the trigger will hurt pro"
       "jectiles (rockets, grenades, etc.)"
      spawnflags: =
      {
        typ = "X1"
        cap = "SOLID"
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "NOT_MONSTERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "PROJECTILES"
      }
      t_commonspecifics = !
      damage: =
      {
        txt = "&"
        hint = "amount of damage to cause. If no damage is specified, objects"
            $0D"are damaged by the current health+1"
      }
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
      triggerable: =
      {
        txt = "&"
        hint = "turn trigger on"
      }
      nottriggerable: =
      {
        txt = "&"
        hint = "turn trigger off"
      }
    }
    trigger_camerause:form =
    {
      help = "Activates 'targeted' camera when 'used'"$0D"If activated, toggle"
       "s through cameras"$0D22"key"$22" The item needed to activate this. (de"
       "fault nothing)"$0D22"thread"$22" name of thread to trigger. This can b"
       "e in a different script file as well"$0D"by using the '::' notation."$0D
       $22"triggerable"$22" turn trigger on"$0D22"nottriggerable"$22" turn tri"
       "gger off"$0D"If NOT_PLAYERS is set, the trigger does not respond to pl"
       "ayers"$0D"If MONSTERS is set, the trigger will respond to monsters"
      spawnflags: =
      {
        typ = "X1"
        cap = "VISIBLE"
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "MONSTERS"
      }
      t_commonspecifics = !
      key: =
      {
        txt = "&"
        hint = "The item needed to activate this. (default nothing)"
      }
      thread: =
      {
        txt = "&"
        hint = "name of thread to trigger. This can be in a different script file as well"
            $0D"by using the '::' notation."
      }
      triggerable: =
      {
        txt = "&"
        hint = "turn trigger on"
      }
      nottriggerable: =
      {
        txt = "&"
        hint = "turn trigger off"
      }
    }
    trigger_exit:form =
    {
      help = "When the player touches this, an exit icon will be displayed in "
       "his hud."$0D"This is to inform him that he is near an exit."$0D22"trig"
       "gerable"$22" turn trigger on"$0D22"nottriggerable"$22" turn trigger of"
       "f"
      t_commonspecifics = !
      triggerable: =
      {
        txt = "&"
        hint = "turn trigger on"
      }
      nottriggerable: =
      {
        txt = "&"
        hint = "turn trigger off"
      }
    }
    trigger_music:form =
    {
      help = "Variable sized repeatable trigger to change the music mood."$0D22
       "delay"$22" if set, the trigger waits some time after activating before"
       " firing."$0D22"current"$22" can be used to set the current mood"$0D22"f"
       "allback"$22" can be used to set the fallback mood"$0D22"altcurrent"$22
       " can be used to set the current mood of the opposite face, if multiFac"
       "eted"$0D22"altfallback"$22" can be used to set the fallback mood of th"
       "e opposite face, if multiFaceted"$0D22"edgeTriggerable"$22" trigger on"
       "ly fires when entering a trigger"$0D22"multiFaceted"$22" if 1, then tr"
       "igger is North/South separate triggerable"$0D"if 2, then trigger East/"
       "West separate triggerable"$0D22"thread"$22" name of thread to trigger."
       " This can be in a different script file as well"$0D"by using the '::' "
       "notation."$0D22"wait"$22" : Seconds between triggerings. (1.0 default)"
       $0D22"cnt"$22" how many times it can be triggered (infinite default)"$0D
       $22"oneshot"$22" make this a one time trigger"$0D22"triggerable"$22" tu"
       "rn trigger on"$0D22"nottriggerable"$22" turn trigger off"$0D"If NOT_PL"
       "AYERS is set, the trigger does not respond to players"$0D"If MONSTERS "
       "is set, the trigger will respond to monsters"$0D"If PROJECTILES is set"
       ", the trigger will respond to projectiles (rockets, grenades, etc.)"$0D
       "NORMAL, ACTION, SUSPENSE, MYSTERY, and SURPRISE are the moods that can"
       " be triggered"
      spawnflags: =
      {
        typ = "X1"
        cap = "NORMAL"
      }
      spawnflags: =
      {
        typ = "X2"
        cap = "ACTION"
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "MONSTERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "PROJECTILES"
      }
      spawnflags: =
      {
        typ = "X32"
        cap = "SUSPENSE"
      }
      spawnflags: =
      {
        typ = "X64"
        cap = "MYSTERY"
      }
      spawnflags: =
      {
        typ = "X128"
        cap = "SURPRISE"
      }
      t_commonspecifics = !
      delay: =
      {
        txt = "&"
        hint = "if set, the trigger waits some time after activating before firing."
      }
      current: =
      {
        txt = "&"
        hint = "can be used to set the current mood"
      }
      fallback: =
      {
        txt = "&"
        hint = "can be used to set the fallback mood"
      }
      altcurrent: =
      {
        txt = "&"
        hint = "can be used to set the current mood of the opposite face, if multiFaceted"
      }
      altfallback: =
      {
        txt = "&"
        hint = "can be used to set the fallback mood of the opposite face, if multiFaceted"
      }
      edgeTriggerable: =
      {
        txt = "&"
        hint = "trigger only fires when entering a trigger"
      }
      multiFaceted: =
      {
        txt = "&"
        hint = "if 1, then trigger is North/South separate triggerable"
            $0D"if 2, then trigger East/West separate triggerable"
      }
      thread: =
      {
        txt = "&"
        hint = "name of thread to trigger. This can be in a different script file as well"
            $0D"by using the '::' notation."
      }
      wait: =
      {
        txt = "&"
        hint = "Seconds between triggerings. (1.0 default)"
      }
      cnt: =
      {
        txt = "&"
        hint = "how many times it can be triggered (infinite default)"
      }
      oneshot: =
      {
        txt = "&"
        hint = "make this a one time trigger"
      }
      triggerable: =
      {
        txt = "&"
        hint = "turn trigger on"
      }
      nottriggerable: =
      {
        txt = "&"
        hint = "turn trigger off"
      }
    }
    trigger_reverb:form =
    {
      help = "Variable sized repeatable trigger to change the reverb level in "
       "the game"$0D22"delay"$22" if set, the trigger waits some time after ac"
       "tivating before firing."$0D22"reverbtype"$22" what kind of reverb shou"
       "ld be used"$0D22"reverblevel"$22" how much of the reverb effect should"
       " be applied"$0D22"altreverbtype"$22" what kind of reverb should be use"
       "d"$0D22"altreverblevel"$22" how much of the reverb effect should be ap"
       "plied"$0D22"edgeTriggerable"$22" trigger only fires when entering a tr"
       "igger"$0D22"multiFaceted"$22" if 1, then trigger is North/South separa"
       "te triggerable"$0D"if 2, then trigger East/West separate triggerable"$0D
       $22"thread"$22" name of thread to trigger. This can be in a different s"
       "cript file as well"$0D"by using the '::' notation."$0D22"wait"$22" : S"
       "econds between triggerings. (1.0 default)"$0D22"cnt"$22" how many time"
       "s it can be triggered (infinite default)"$0D22"oneshot"$22" make this "
       "a one time trigger"$0D22"triggerable"$22" turn trigger on"$0D22"nottri"
       "ggerable"$22" turn trigger off"$0D"If NOT_PLAYERS is set, the trigger "
       "does not respond to players"$0D"If MONSTERS is set, the trigger will r"
       "espond to monsters"$0D"If PROJECTILES is set, the trigger will respond"
       " to projectiles (rockets, grenades, etc.)"
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "MONSTERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "PROJECTILES"
      }
      t_commonspecifics = !
      delay: =
      {
        txt = "&"
        hint = "if set, the trigger waits some time after activating before firing."
      }
      reverbtype: =
      {
        txt = "&"
        hint = "what kind of reverb should be used"
      }
      reverblevel: =
      {
        txt = "&"
        hint = "how much of the reverb effect should be applied"
      }
      altreverbtype: =
      {
        txt = "&"
        hint = "what kind of reverb should be used"
      }
      altreverblevel: =
      {
        txt = "&"
        hint = "how much of the reverb effect should be applied"
      }
      edgeTriggerable: =
      {
        txt = "&"
        hint = "trigger only fires when entering a trigger"
      }
      multiFaceted: =
      {
        txt = "&"
        hint = "if 1, then trigger is North/South separate triggerable"
            $0D"if 2, then trigger East/West separate triggerable"
      }
      thread: =
      {
        txt = "&"
        hint = "name of thread to trigger. This can be in a different script file as well"
            $0D"by using the '::' notation."
      }
      wait: =
      {
        txt = "&"
        hint = ": Seconds between triggerings. (1.0 default)"
      }
      cnt: =
      {
        txt = "&"
        hint = "how many times it can be triggered (infinite default)"
      }
      oneshot: =
      {
        txt = "&"
        hint = "make this a one time trigger"
      }
      triggerable: =
      {
        txt = "&"
        hint = "turn trigger on"
      }
      nottriggerable: =
      {
        txt = "&"
        hint = "turn trigger off"
      }
    }
    trigger_pushobject:form =
    {
      help = "Special trigger that can only be triggered by a push object."$0D
       $22"triggername"$22" if set, trigger only responds to objects with a ta"
       "rgetname the same as triggername."$0D22"cnt"$22" how many times it can"
       " be triggered (default 1, use -1 for infinite)"
      t_commonspecifics = !
      triggername: =
      {
        txt = "&"
        hint = "if set, trigger only responds to objects with a targetname the same as triggername."
      }
      cnt: =
      {
        txt = "&"
        hint = "how many times it can be triggered (default 1, use -1 for infinite)"
      }
    }
    trigger_givepowerup:form =
    {
      help = "Variable sized repeatable trigger to give a powerup to the playe"
       "r"$0D22"oneshot"$22" makes this triggerable only once"$0D22"powerupnam"
       "e"$22" sets the name of the powerup to give to the player"$0D"If NOT_P"
       "LAYERS is set, the trigger does not respond to players"$0D"If MONSTERS"
       " is set, the trigger will respond to monsters"
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "MONSTERS"
      }
      t_commonspecifics = !
      oneshot: =
      {
        txt = "&"
        hint = "makes this triggerable only once"
      }
      powerupname: =
      {
        txt = "&"
        hint = "sets the name of the powerup to give to the player"
      }
    }
    trigger_worktrigger:form =
    {
      help = "Trigger will be used to tell the AI how to do 'work'.  When the "
       $0D"AI activates trigger, the thread you specifiy will execute.  The AI"
       $0D" will also play the Animation you set in the trigger."
       $0D22"triggerable"$22" turn trigger on"$0D
       $22"nottriggerable"$22" turn trigger off"$0D22"setworkanim"$22
       " make this a one time trigger"
      t_commonspecifics = !
      triggerable: =
      {
        txt = "&"
        hint = "turn trigger on"
      }
      nottriggerable: =
      {
        txt = "&"
        hint = "turn trigger off"
      }
      setworkanim: =
      {
        txt = "&"
        hint = "Sets the animation the Actor will use when 'working'"
      }
    }
    trigger_levelinteraction:form =
    {
      help = "Trigger that will be damaged by the AI to fire off a 'level_interaction'"
       $0D" thread for example, a boss that shoots crates and knocks them over onto players"
       $0D22"triggerable"$22" turn trigger on"$0D
       $22"nottriggerable"$22" turn trigger off"$0D22"health"$22
       " should be set so that the trigger can take damage"
      t_commonspecifics = !
      triggerable: =
      {
        txt = "&"
        hint = "turn trigger on"
      }
      nottriggerable: =
      {
        txt = "&"
        hint = "turn trigger off"
      }
      health: =
      {
        txt = "&"
        hint = "should be set so that the trigger can take damage"
      }
    }
    trigger_groupevent:form =
    {
      help = "Variable sized repeatable trigger.  Must be targeted at one or more entities."
       $0D22"oneshot"$22" makes this triggerable only once"
       $0D22"powerupnam"$22" sets the name of the powerup to give to the player"
       $0D22"health"$22" the trigger must be killed to activate each time."
       $0D22"delay"$22" the trigger waits some time after activating before firing."
       $0D22"thread"$22" name of thread to trigger.  This can be in a different script file as well by using the '::' notation."
       $0D22"angle"$22" the trigger will only fire when someone is facing the direction of the angle."
       $0D22"cone"$22" the cone in which a directed trigger can be triggered (default 60 degrees)"
       $0D22"wait"$22"  : Seconds between triggerings. (.2 default)"
       $0D22"cnt"$22" how many times it can be triggered (infinite default)"
       $0D22"triggerable"$22" turn trigger on"
       $0D22"nottriggerable"$22" turn trigger off"
       $0D22"setpassevent"$22"  Sets the event you wish to pass to the group."
       $0D22"setgroupnumber"$22" Sets the number of the group you wish to pass the event to."
       $0D22"message"$22" set to text string"
       $0D"If NOT_PLAYERS is set, the trigger does not respond to players"
       $0D"If MONSTERS is set, the trigger will respond to monsters"
       $0D"If PROJECTILES is set, the trigger will respond to projectiles (rockets, grenades, etc.)"
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "MONSTERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "PROJECTILES"
      }
      t_commonspecifics = !
      health: =
      {
        txt = "&"
        hint = "if set, the trigger must be killed to activate each time."
      }
      delay: =
      {
        txt = "&"
        hint = "if set, the trigger waits some time after activating before firing."
      }
      thread: =
      {
        txt = "&"
        hint = "name of thread to trigger. This can be in a different script file as well"
            $0D"by using the '::' notation."
      }
      angle: =
      {
        txt = "&"
        hint = "if set, the trigger will only fire when someone is facing the"
            $0D"direction of the angle."
      }
      cone: =
      {
        txt = "&"
        hint = "the cone in which a directed trigger can be triggered (default 60 degrees)"
      }
      wait: =
      {
        txt = "&"
        hint = ": Seconds between triggerings. (.2 default)"
      }
      cnt: =
      {
        txt = "&"
        hint = "how many times it can be triggered (infinite default)"
      }
      triggerable: =
      {
        txt = "&"
        hint = "turn trigger on"
      }
      nottriggerable: =
      {
        txt = "&"
        hint = "turn trigger off"
      }
      setpassevent: =
      {
        txt = "&"
        hint = "Sets the event you wish to pass to the group."
      }
      setgroupnumber: =
      {
        txt = "&"
        hint = "Sets the number of the group you wish to pass the event to."
      }
      message: =
      {
        txt = "&"
        hint = "set to text string"
      }
    }
    trigger_volume_callvolume:form =
    {
      help = "Allows you to specify a list of actors that are required to be inside this"
       $0D"volume before the thread fires.  This is a good utility if you need to 'herd'"
       $0D"a group of actors into one spot for an event to occur ( Such as Teammates and"
       $0D"Lifts ).  When the player enters this trigger, a flag is set on all the actors"
       $0D"in the required list that notifies them that the player is in the volume.  The AI"
       $0D"for those actors is then responsible for getting them into the volume.  Once"
       $0D"all the required actors that are still in the level ( in case some were killed or"
       $0D"otherwise removed ) the specified thread will fire"
      t_commonspecifics = !
    }
    trigger_EntryAndExit:form =
    {
      help = "Triggers entryThread when entity enters the trigger, calls thread while inside,"
       $0D"and calls exitThread when entity leaves the trigger."
       $0D"Key Value Pairs:"
       $0D22"thread"$22" <ThreadName>"
       $0D22"entryThread"$22" <EntryThreadName>"
       $0D22"exitThread"$22" <ExitThreadName>"
       $0D"If NOT_PLAYERS is set, the trigger does not respond to players"
       $0D"If MONSTERS is set, the trigger will respond to monsters"
       $0D"If PROJECTILES is set, the trigger will respond to projectiles (rockets, grenades, etc.)"
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "MONSTERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "PROJECTILES"
      }
      t_commonspecifics = !
      thread: =
      {
        txt = "&"
        hint = "<ThreadName>"
      }
      entryThread: =
      {
        txt = "&"
        hint = "<EntryThreadName>"
      }
      exitThread: =
      {
        txt = "&"
        hint = "<ExitThreadName>"
      }
    }
    trigger_volume:form =
    {
      help = "Triggers entryThread when entity enters the trigger, calls thread while inside,"
       $0D"and calls exitThread when entity leaves the trigger."
       $0D"Key Value Pairs:"
       $0D22"thread"$22" <ThreadName>"
       $0D22"entryThread"$22" <EntryThreadName>"
       $0D22"exitThread"$22" <ExitThreadName>"
       $0D"If NOT_PLAYERS is set, the trigger does not respond to players"
       $0D"If MONSTERS is set, the trigger will respond to monsters"
       $0D"If PROJECTILES is set, the trigger will respond to projectiles (rockets, grenades, etc.)"
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "MONSTERS"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "PROJECTILES"
      }
      t_commonspecifics = !
      thread: =
      {
        txt = "&"
        hint = "<ThreadName>"
      }
      entryThread: =
      {
        txt = "&"
        hint = "<EntryThreadName>"
      }
      exitThread: =
      {
        txt = "&"
        hint = "<ExitThreadName>"
      }
    }
    trigger_ladder:form =
    {
      help = "Tells any entity that touches it that it is on a ladder"
       $0D"Angle/Angles specifies the direction away from the ladder"
       $0D"If NOT_PLAYERS is set, the trigger does not respond to players"
       $0D"If MONSTERS is set, the trigger will respond to monsters"
      spawnflags: =
      {
        typ = "X4"
        cap = "NOT_PLAYERS"
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "MONSTERS"
      }
      t_commonspecifics = !
    }
    info_waypointnode_waypointnode:form =
    {
      help = "Used as a positioning device for objects."
      bbox = '-12 -12 0 12 12 12'
    }
    light:form =
    {
      help = "Non-displayed light. If it targets another entity it will become a spot light."
          $0D"The light is only added if the trace is clear."
      $0D"LINEAR - if set, it will be a linear light."
      $0D"NO_ENTITIES - if set, this light will only affect the world, not entities."
      $0D"ENTITY_TRACE - if set, a trace is done betwee the light and the entity."
      $0D"SUN - if set, the light basically acts like a sun. (infinite distance away, no falloff, etc.)"
      $0D"DYNAMIC - if set, the light can be dynamicly changed on & off."
      $0D"      Dynamic light stuff:"
      $0D"        "$22"minlight"$22" - the intensity of the light. (default 0)"
      $0D"        "$22"group_name"$22" - specifies the dynamic light group name for this light."
      $0D"LENSFLARE - if set, the light will always have a lensflare attached to it."
      $0D"NO_WORLD - if set, the light will not affect the world."
      $0D22"no_entity_light"$22" this light will not effect entities, just the world."
      $0D22"spherical_ambient"$22" (try 0.50)"
      $0D22"dot_product_weight"$22" (try 0.50)"
      $0D22"light"$22" the intensity of the light. (default 300)"
      $0D22"brightness"$22" (try 0.75)"
      $0D22"_color"$22" the color of the light."
      $0D22"falloff"$22" if linear, specify the linear falloff. (defaults to 1)"
      $0D22"falloff_curvature"$22" (try 0.50)"
      $0D22"falloff_end_dist"$22" (try 368)"
      $0D22"falloff_start_dist"$22" (try 200)"
      $0D22"radius"$22" make this a spot light of the given radius."
      $0D22"angles"$22" make this a spot light centered on angles."
      $0D22"spot_angle"$22" if this is a spot light, what angle to use. (default 45)"
      $0D22"angle_penumbra"$22" (try 80)"
      $0D22"angle_hotspot"$22" (try 30)"
      $0D22"entity_trace"$22" trace between the entity and the light."
      bbox = '-8 -8 -8 8 8 8'
      spawnflags: =
      {
        typ = "X1"
        cap = "LINEAR"
        hint = "If set, it will be a linear light."
      }
      spawnflags: =
      {
        typ = "X2"
        cap = "NO_ENTITIES"
        hint = "If set, this light will only affect the world, not entities."
      }
      spawnflags: =
      {
        typ = "X4"
        cap = "ENTITY_TRACE"
        hint = "If set, a trace is done betwee the light and the entity."
      }
      spawnflags: =
      {
        typ = "X8"
        cap = "SUN"
        hint = "If set, the light basically acts like a sun."
            $0D"(infinite distance away, no falloff, etc.)"
      }
      spawnflags: =
      {
        typ = "X16"
        cap = "DYNAMIC"
        hint = "If set, the light can be dynamicly changed on & off."
      }
      spawnflags: =
      {
        typ = "X32"
        cap = "LENSFLARE"
        hint = "If set, the light will always have a lensflare attached to it."
      }
      spawnflags: =
      {
        typ = "X64"
        cap = "NO_WORLD"
        hint = "If set, the light will not affect the world."
      }
      t_commonspecifics = !
      minlight: =
      {
        txt = "&"
        hint = "the intensity of the light. (default 0)"
      }
      group_name: =
      {
        txt = "&"
        hint = "specifies the dynamic light group name for this light."
      }
      no_entity_light: =
      {
        txt = "&"
        hint = "This light will not effect entities, just the world."
      }
      spherical_ambient: =
      {
        txt = "&"
        hint = "(try 0.50)"
      }
      dot_product_weight: =
      {
        txt = "&"
        hint = "(try 0.50)"
      }
      light: =
      {
        txt = "&"
        hint = "The intensity of the light. (default 300)"
      }
      brightness: =
      {
        txt = "&"
        hint = "(try 0.75)"
      }
      _color: =
      {
        txt = "&"
        hint = "constantLight color"
      }
      _color: =
      {
        Typ = "LN"
        txt = "&"
        hint = "Click here to pick the light color."
      }
      falloff: =
      {
        txt = "&"
        hint = "If linear, specify the linear falloff. (defaults to 1)"
      }
      falloff_curvature: =
      {
        txt = "&"
        hint = "(try 0.50)"
      }
      falloff_end_dist: =
      {
        txt = "&"
        hint = "(try 368)"
      }
      falloff_start_dist: =
      {
        txt = "&"
        hint = "(try 200)"
      }
      radius: =
      {
        txt = "&"
        hint = "Make this a spot light of the given radius."
      }
      angles: =
      {
        txt = "&"
        hint = "Make this a spot light centered on angles."
      }
      spot_angle: =
      {
        txt = "&"
        hint = "If this is a spot light, what angle to use. (default 45)"
      }
      angle_penumbra: =
      {
        txt = "&"
        hint = "(try 80)"
      }
      angle_hotspot: =
      {
        txt = "&"
        hint = "(try 30)"
      }
      entity_trace: =
      {
        txt = "&"
        hint = "Trace between the entity and the light."
      }
    }
    info_waypointnode_patrolwaypointnode:form =
    {
      help = "Used as a positioning device for objects."
      bbox = '-12 -12 0 12 12 12'
    }
    info_waypointnode_callvolume:form =
    {
      help = "Used as a positioning device for objects."
      bbox = '-12 -12 0 12 12 12'
    }
    info_waypointnode_position:form =
    {
      help = "Used as a positioning device for objects."
      bbox = '-12 -12 0 12 12 12'
    }
    worldspawn:form =
    {
      help = "Every map should have exactly one worldspawn."
      $0D22"soundtrack"$22" the soundtrack to use on the map."
        $0D"    Path to .mus files."
        $0D"    (e.g. 'music\intro.mus')"
        $0D"    To 'pick' a file it must be extracted"
        $0D"    from the game .pk3 file first."
      $0D22"gravity"$22" 800 is default gravity."
      $0D22"skipthread"$22" thread that is activated to skip this level. (if cinematic)"
      $0D22"nextmap"$22" map to goto when player exits."
      $0D22"message"$22" text to print at user logon."
      $0D22"script"$22" script to run on start of map."
      $0D22"watercolor"$22" view color when underwater."
      $0D22"wateralpha"$22" view alpha when underwater."
      $0D22"lavacolor"$22" view alpha when in lava."
      $0D22"lavaalpha"$22" view alpha when in lava."
      $0D22"farplane_color"$22" color to fade to when the far clip plane is on."
      $0D22"farplane_cull"$22" whether or not the far plane should cull, default is yes."
      $0D22"farplane_fog"$22" whether or not to use fog with farplane."
      $0D22"farplane"$22" distance from the viewer that the far clip plane is."
      $0D22"ambientlight"$22" ambient lighting to be applied to all entities."
      $0D22"ambient"$22" ambient lighting to be applied to all entities, use _color to specify color."
      $0D22"suncolor"$22" color of the sun in the level."
      $0D22"sunlight"$22" intensity of the sun in the level."
      $0D22"sundirection"$22" direction of the sun in the level."
      $0D22"sunflare"$22" worldspace position of the sun flare."
      $0D22"sunflare_inportalsky"$22" whether or not the flare is in the portal sky."
      $0D22"lightmapdensity"$22" default lightmap density to be used for all surfaces."
      $0D22"skyalpha"$22" initial value of the sky's alpha, defaults to 1."
      spawnflags: =
      {
        typ = "X1"
        cap = "CINEMATIC"
        hint = "Only used for the world."
      }
      soundtrack: =
      {
        t_musicbrowser = !
        txt = "&"
        hint = "the soundtrack to use on the map"
      }
      soundtrack: =
      { typ="C"
        txt="music"
        items=
          "ai_prototype"$0D
          "credits"$0D
          "dm_attrexian1"$0D
          "dm_borgurvish"$0D
          "dm_bridwag"$0D
          "dm_ctf_station"$0D
          "dm_de_as"$0D
          "dm_ef2-dm1"$0D
          "dm_gullie"$0D
          "dm_idryll2"$0D
          "dm_kw"$0D
          "dm_p1"$0D
          "dm_quarterdeck"$0D
          "dm_sewer"$0D
          "dm_t2"$0D
          "dm_t4mobius"$0D
          "dm_trophonius"$0D
          "ent-exterior"$0D
          "igm1"$0D
          "igm2"$0D
          "igm3"$0D
          "igm4"$0D
          "igm5"$0D
          "igm6"$0D
          "igm7"$0D
          "igm8"$0D
          "intro"$0D
          "m0"$0D
          "m10l1-romulan_installation"$0D
          "m10l2-romulan_installation"$0D
          "m10l2a-romulan_installation"$0D
          "m10l2b-romulan_installation"$0D
          "m11l1a-drull_ruins3"$0D
          "m11l1b-drull_ruins3"$0D
          "m11l2a-drull_ruins3"$0D
          "m11l2bdrull_ruins3"$0D
          "m11l3a-drull_ruins3_boss"$0D
          "m11l3b-drull_ruins3_boss"$0D
          "m12"$0D
          "m1l1-borg_sphere"$0D
          "m1l2-borg_sphere"$0D
          "m1l3-borg_boss"$0D
          "m2l0-sfa"$0D
          "m2l1-sfa"$0D
          "m2l2-sfa"$0D
          "m2l3-sfa"$0D
          "m3l1a-forever"$0D
          "m3l1b-forever"$0D
          "m3l2-forever"$0D
          "m4l1a-attrexian_station"$0D
          "m4l1b-attrexian_station"$0D
          "m4l2a-attrexian_station"$0D
          "m4l2b-attrexian_station"$0D
          "m4l2c-attrexian_station"$0D
          "m5l1a"$0D
          "m5l1b"$0D
          "m5l1c"$0D
          "m5l2a"$0D
          "m5l2b"$0D
          "m5l2c"$0D
          "m6l0"$0D
          "m6l1-drull_ship"$0D
          "m6l1"$0D
          "m6l1_bridge"$0D
          "m6l1_decks"$0D
          "m6l2"$0D
          "m7l1-attrexian_colony"$0D
          "m7l1b-attrexian_colony"$0D
          "m7l2a-attrexian_colony"$0D
          "m7l2b-attrexian_colony"$0D
          "m8l1a"$0D
          "m8l1b"$0D
          "m8l2a"$0D
          "m8l2b"$0D
          "m9l1a-klingon_base"$0D
          "m9l1b-klingon_base"$0D
          "m9l2-klingon_base"$0D
          "test"$0D
          "training1"$0D
          "training2"$0D
          "training3"$0D
          "training4"$0D
          "training_weapon"$0D
        values=
          "music/ai_prototype.mus"$0D
          "music/credits.mus"$0D
          "music/dm_attrexian1.mus"$0D
          "music/dm_borgurvish.mus"$0D
          "music/dm_bridwag.mus"$0D
          "music/dm_ctf_station.mus"$0D
          "music/dm_de_as.mus"$0D
          "music/dm_ef2-dm1.mus"$0D
          "music/dm_gullie.mus"$0D
          "music/dm_idryll2.mus"$0D
          "music/dm_kw.mus"$0D
          "music/dm_p1.mus"$0D
          "music/dm_quarterdeck.mus"$0D
          "music/dm_sewer.mus"$0D
          "music/dm_t2.mus"$0D
          "music/dm_t4mobius.mus"$0D
          "music/dm_trophonius.mus"$0D
          "music/ent-exterior.mus"$0D
          "music/igm1.mus"$0D
          "music/igm2.mus"$0D
          "music/igm3.mus"$0D
          "music/igm4.mus"$0D
          "music/igm5.mus"$0D
          "music/igm6.mus"$0D
          "music/igm7.mus"$0D
          "music/igm8.mus"$0D
          "music/intro.mus"$0D
          "music/m0.mus"$0D
          "music/m10l1-romulan_installation.mus"$0D
          "music/m10l2-romulan_installation.mus"$0D
          "music/m10l2a-romulan_installation.mus"$0D
          "music/m10l2b-romulan_installation.mus"$0D
          "music/m11l1a-drull_ruins3.mus"$0D
          "music/m11l1b-drull_ruins3.mus"$0D
          "music/m11l2a-drull_ruins3.mus"$0D
          "music/m11l2bdrull_ruins3.mus"$0D
          "music/m11l3a-drull_ruins3_boss.mus"$0D
          "music/m11l3b-drull_ruins3_boss.mus"$0D
          "music/m12.mus"$0D
          "music/m1l1-borg_sphere.mus"$0D
          "music/m1l2-borg_sphere.mus"$0D
          "music/m1l3-borg_boss.mus"$0D
          "music/m2l0-sfa.mus"$0D
          "music/m2l1-sfa.mus"$0D
          "music/m2l2-sfa.mus"$0D
          "music/m2l3-sfa.mus"$0D
          "music/m3l1a-forever.mus"$0D
          "music/m3l1b-forever.mus"$0D
          "music/m3l2-forever.mus"$0D
          "music/m4l1a-attrexian_station.mus"$0D
          "music/m4l1b-attrexian_station.mus"$0D
          "music/m4l2a-attrexian_station.mus"$0D
          "music/m4l2b-attrexian_station.mus"$0D
          "music/m4l2c-attrexian_station.mus"$0D
          "music/m5l1a.mus"$0D
          "music/m5l1b.mus"$0D
          "music/m5l1c.mus"$0D
          "music/m5l2a.mus"$0D
          "music/m5l2b.mus"$0D
          "music/m5l2c.mus"$0D
          "music/m6l0.mus"$0D
          "music/m6l1-drull_ship.mus"$0D
          "music/m6l1.mus"$0D
          "music/m6l1_bridge.mus"$0D
          "music/m6l1_decks.mus"$0D
          "music/m6l2.mus"$0D
          "music/m7l1-attrexian_colony.mus"$0D
          "music/m7l1b-attrexian_colony.mus"$0D
          "music/m7l2a-attrexian_colony.mus"$0D
          "music/m7l2b-attrexian_colony.mus"$0D
          "music/m8l1a.mus"$0D
          "music/m8l1b.mus"$0D
          "music/m8l2a.mus"$0D
          "music/m8l2b.mus"$0D
          "music/m9l1a-klingon_base.mus"$0D
          "music/m9l1b-klingon_base.mus"$0D
          "music/m9l2-klingon_base.mus"$0D
          "music/test.mus"$0D
          "music/training1.mus"$0D
          "music/training2.mus"$0D
          "music/training3.mus"$0D
          "music/training4.mus"$0D
          "music/training_weapon.mus"$0D
      }
      gravity: =
      {
        txt = "&"
        hint = "800 is default gravity"
      }
      skipthread: =
      {
        txt = "&"
        hint = "Thread that is activated to skip this level. (if cinematic)"
      }
      nextmap: =
      {
        txt = "&"
        hint = "Map to goto when player exits."
      }
      message: =
      {
        txt = "&"
        hint = "Text to print at user logon."
      }
      script: =
      {
        txt = "&"
        hint = "Script to run on start of map."
      }
      watercolor: =
      {
        txt = "&"
        Typ = "LN"
        hint = "View color when underwater."
      }
      wateralpha: =
      {
        txt = "&"
        Typ = "X1"
        hint = "View alpha when underwater."
      }
      lavacolor: =
      {
        txt = "&"
        Typ = "LN"
        hint = "View alpha when in lava."
      }
      lavaalpha: =
      {
        txt = "&"
        Typ = "X1"
        hint = "View alpha when in lava."
      }
      farplane_color: =
      {
        txt = "&"
        Typ = "LN"
        Hint = "Color to fade to when the far clip plane is on."
      }
      farplane_cull: =
      {
        typ = "C"
        txt = "&"
        hint = "Whether or not the far plane should cull, default is yes."
        items =
            "yes" $0D
            "no"
        values =
            "1" $0D
            "0"
      }
      farplane_fog: =
      {
        Txt = "farplane_fog"
        Typ = "X1"
        hint = "Whether or not to use fog with farplane."
      }
      farplane: =
      {
        txt = "&"
        hint = "Distance from the viewer that the far clip plane is."
      }
      ambientlight: =
      {
        Txt = "ambientlight"
        Typ = "X1"
        hint = "Ambient lighting to be applied to all entities."
      }
      ambient: =
      {
        txt = "&"
        Typ = "X1"
        hint = "Ambient lighting to be applied to all entities, use _color to specify color."
      }
      _color: =
      {
        txt = "&"
        Typ = "LN"
        hint = "Ambient lighting color."
      }
      suncolor: =
      {
        txt = "&"
        Typ = "LN"
        hint = "Color of the sun in the level."
      }
      sunlight: =
      {
        txt = "&"
        hint = "Intensity of the sun in the level."
      }
      sundirection: =
      {
        txt = "&"
        hint = "Direction of the sun in the level."
      }
      sunflare: =
      {
        txt = "&"
        hint = "Worldspace position of the sun flare."
      }
      sunflare_inportalsky: =
      {
        txt = "&"
        Typ = "X1"
        hint = "Whether or not the flare is in the portal sky."
      }
      lightmapdensity: =
      {
        txt = "&"
        hint = "Default lightmap density to be used for all surfaces."
      }
      skyalpha: =
      {
        txt = "&"
        hint = "Initial value of the sky's alpha, defaults to 1"
      }
    }
  }
}
