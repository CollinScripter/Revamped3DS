QQRKSRC1
// This file has been written by QuArK QuArK 6.4 alpha
// It's the text version of file: base.qrk

// Common Source Entities. last changes august/5/2005 by cbxpm.

{
  Description = "Common Source Entities"
  t_player_size:incl = { bbox = '-16 -16 -24 16 16 32' }
  Toolbox Folders.qtx =
  {
    Toolbox = "New map items..."
    Root = "Common Source Entities.qtxfolder"
    Common Source Entities.qtxfolder =
    {

// env entities

      env_* entities.qtxfolder =
      {
        env_beam:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that creates a visible beam between two points. T"
           "he points can be attached to entities to make the beam move around"
           "."
          renderamt = "100"
          rendercolor = "255 255 255"
          Radius = "256"
          life = "1"
          BoltWidth = "2"
          NoiseAmplitude = "0"
          texture = "sprites/laserbeam.spr"
          TextureScroll = "35"
          framerate = "0"
          framestart = "0"
          StrikeTime = "1"
          damage = "0"
          TouchType = "0"
        }
        env_beverage:e =
        {
          origin = "0 0 0"
          ;desc = "HL1 Legacy: Beverage Dispenser."
          health = "10"
          beveragetype = "0"
        }
        env_blood:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to spawn blood effects."
          spraydir = "0 0 0"
          color = "0"
          amount = "100"
        }
        env_bubbles:b =
        {
          t_nodrawpoly=!
          ;desc = "An entity used to create a volume in which to spawn bubbles"
           "."
          density = "2"
          frequency = "2"
          current = "0"
        }
        env_credits:e =
        {
          origin = "0 0 0"
          ;desc = "An entity to control the rolling credits."
        }
        env_cubemap:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that creates a sample point for the Cubic Environ"
           "ment Map."
          cubemapsize = "0"
        }
        env_dustpuff:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that can emit dust puffs."
          scale = "8"
          speed = "16"
          color = "128 128 128"
        }
        env_effectscript:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that allows you to script special visual effects "
           "via a script file."
          model = "models/Effects/teleporttrail.mdl"
          scriptfile = "scripts/effects/testeffect.txt"
        }
        env_embers:b =
        {
          t_nodrawpoly=!
          ;desc = "An entity used to create a volume in which to spawn fire em"
           "bers."
          particletype = "0"
          density = "50"
          lifetime = "4"
          speed = "32"
          rendercolor = "255 255 255"
        }
        env_entity_igniter:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that catches a target entity on fire. If the enti"
           "ty is an animating model, it will have sprite flames attached to i"
           "ts skeleton. Otherwise the entity will emit particle flame puffs."
          lifetime = "10"
        }
        env_entity_maker:e =
        {
          origin = "0 0 0"
          ;desc = "Spawns the specified entity template at its origin. If set "
           "to auto-spawn, it will spawn the template whenever there's room an"
           "d the player is looking elsewhere."
        }
        env_explosion:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that creates an explosion at its origin."
          iMagnitude = "100"
          iRadiusOverride = "0"
          fireballsprite = "sprites/zerogxplode.spr"
          rendermode = "5"
        }
        env_fade:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that controls screen fades."
          duration = "2"
          holdtime = "0"
          renderamt = "255"
          rendercolor = "0 0 0"
        }
        env_fire:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that handles a single flame at its origin. The fl"
           "ame causes heat 'damage' to other env_fire entities around it, and"
           " will eventually ignite non-flaming env_fire entities nearby, caus"
           "ing the fire to spread."
          health = "30"
          firesize = "64"
          fireattack = "4"
          firetype = "0"
          ignitionpoint = "32"
          damagescale = "1.0"
        }
        env_firesensor:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that detects changes in heat nearby."
          spawnflags = "1"
          fireradius = "128"
          heatlevel = "32"
          heattime = "0"
        }
        env_firesource:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that provides heat to all nearby env_fire entitie"
           "s. Cannot be extinguished."
          fireradius = "128"
          firedamage = "10"
        }
        env_fog_controller:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that controls the fog and view distance in the ma"
           "p."
          fogenable = "0"
          fogblend = "0"
          use_angles = "0"
          fogcolor = "255 255 255"
          fogcolor2 = "255 255 255"
          fogdir = "1 0 0"
          fogstart = "500.0"
          fogend = "2000.0"
          farz = "-1"
        }
        env_funnel:e =
        {
          origin = "0 0 0"
          ;desc = "HL1 Legacy: Large Portal Funnel"
        }
        env_hudhint:e =
        {
          origin = "0 0 0"
          ;desc = "An entity to control the display of HUD hints. HUD hints ar"
           "e used to show the player what key is bound to a particular comman"
           "d."
        }
        env_laser:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that creates a laser beam between itself and a gi"
           "ven target."
          renderamt = "100"
          rendercolor = "255 255 255"
          width = "2"
          NoiseAmplitude = "0"
          texture = "sprites/laserbeam.spr"
          TextureScroll = "35"
          framestart = "0"
          damage = "100"
          dissolvetype = "None"
        }
        env_lightglow:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that puts an additive glow in the world, mostly u"
           "sed over light sources."
          rendercolor = "255 255 255"
          VerticalGlowSize = "30"
          HorizontalGlowSize = "30"
          MinDist = "500"
          MaxDist = "2000"
          OuterMaxDist = "0"
          GlowProxySize = "2.0"
        }
        env_message:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that draws a text message on player's HUDs."
          messagevolume = "10"
          messageattenuation = "0"
        }
        env_microphone:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that acts as a microphone. It works in one of two"
           " modes. If it has a 'Speaker' set, it picks up all sounds within t"
           "he specified sound range, and rebroadcasts them through the Speake"
           "r entity. In this Speaker mode, it ignores the Hears X spawnflags "
           "and does not fire the SoundLevel output. If it has no Speaker set,"
           " it measures the sound level at a point, and outputs the sound lev"
           "el as a value between 0 and 1. In Measuring mode, it only hears so"
           "unds that match the Hear X spawnflags."
          speaker_dsp_preset = "0"
          spawnflags = "15"
          Sensitivity = "1"
          SmoothFactor = "0"
          MaxRange = "240"
        }
        env_particlelight:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that can be used to light the smoke particles emi"
           "tted by env_smokestack entities. Does not light any other particle"
           " types."
          Color = "255 0 0"
          Intensity = "5000"
          directional = "0"
        }
        env_particlescript:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that has special animation events that can be fir"
           "ed by a model with an animation inside its .qc designed foruse by "
           "this entity."
          model = "models/Ambient_citadel_paths.mdl"
        }
        env_physexplosion:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that creates an explosion at its origin. If the n"
           "o-damage spawnflag is set, the explosion won't be visible, but wil"
           "l apply force to any physics objects within its radius."
          magnitude = "100"
          radius = "0"
          spawnflags = "1"
        }
        env_physimpact:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that will cause a physics impact on another entit"
           "y."
          angles = "0 0 0"
          magnitude = "100"
          distance = "0"
        }
        env_player_surface_trigger:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that monitors the material of the surface the pla"
           "yer is standing on, and fires outputs whenever it changes to/from "
           "a specific material."
          gamematerial = "0"
        }
         env_rotorshooter:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that creates gibs when it's within the influence "
           "of a helicopter's rotor wash."
          shootsounds = "-1"
          simulation = "0"
          skin = "0"
          rotortime = "1"
          rotortimevariance = "0.3"
        }
        env_screenoverlay:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that can display and control a set of screen over"
           "lays, to be displayed over the player's view. Useful for view effe"
           "cts like drunkenness, or teleporter afterimages, etc."
          OverlayTime1 = "1.0"
          OverlayTime2 = "1.0"
          OverlayTime3 = "1.0"
          OverlayTime4 = "1.0"
          OverlayTime5 = "1.0"
          OverlayTime6 = "1.0"
          OverlayTime7 = "1.0"
          OverlayTime8 = "1.0"
          OverlayTime9 = "1.0"
          OverlayTime10 = "1.0"
        }
        env_shake:e =
        {
          origin = "0 0 0"
          ;desc = "An entity to control screen shake on players."
          amplitude = "4"
          radius = "500"
          duration = "1"
          frequency = "2.5"
        }
        env_shooter:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that shoots models, or sprites, out of its origin"
           "."
          shootsounds = "-1"
          simulation = "0"
          skin = "0"
        }
        env_smokestack:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that spits out a constant stream of smoke. See pa"
           "rticlezoo.vmf for sample usage. You can place up to two env_partic"
           "lelight entities near the smoke stack to add ambient light to its "
           "particles."
          InitialState = "0"
          BaseSpread = "20"
          SpreadSpeed = "15"
          Speed = "30"
          StartSize = "20"
          EndSize = "30"
          Rate = "20"
          JetLength = "180"
          WindAngle = "0"
          WindSpeed = "0"
          SmokeMaterial = "particle/SmokeStack.vmt"
          twist = "0"
          rendercolor = "255 255 255"
          renderamt = "255"
        }
        env_smoketrail:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that creates a smoke trail."
          opacity = "0.75"
          spawnrate = "20"
          lifetime = "5.0"
          startcolor = "192 192 192"
          endcolor = "160 160 160"
          emittime = "0"
          minspeed = "10"
          maxspeed = "20"
          mindirectedspeed = "0"
          maxdirectedspeed = "0"
          startsize = "15"
          endsize = "50"
          spawnradius = "15"
          firesprite = "sprites/firetrail.spr"
          smokesprite = "sprites/whitepuff.spr"
        }
        env_soundscape:e =
        {
          origin = "0 0 0"
          ;desc = "An entity to control sound in an area. The active soundscap"
           "e at any time is the last one that had line-of-sight to the player"
           ", and was within the radius."
          radius = "128"
          soundscape = "Nothing"
        }
        env_soundscape_proxy:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that acts like a soundscape but gets all of its s"
           "ound parameters from another env_soundscape entity."
          radius = "128"
        }
        env_soundscape_triggerable:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that works like env_soundscape except that it wor"
           "ks in conjunction with trigger_soundscape to determine when a play"
           "er hears it."
          radius = "128"
          soundscape = "Nothing"
        }
        env_spark:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to create sparks at its origin."
          MaxDelay = "0"
          Magnitude = "1"
          TrailLength = "1"
        }
        env_splash:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that creates a splash effect at its origin. If th"
           "e 'find water surface' spawnflag is set, it will instead trace dow"
           "n below itself to find the water surface on which to create splash"
           "es."
          scale = "8.0"
          spawnflags = "2"
        }
        env_sprite:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that controls the drawing of a sprite in the worl"
           "d."
          framerate = "10.0"
          model = "sprites/glow01.spr"
          GlowProxySize = "2.0"
        }
        env_steam:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to create a jet of steam."
          InitialState = "0"
          type = "0"
          SpreadSpeed = "15"
          Speed = "120"
          StartSize = "10"
          EndSize = "25"
          Rate = "26"
          rendercolor = "255 255 255"
          JetLength = "80"
          renderamt = "255"
        }
        env_sun:e =
        {
          origin = "0 0 0"
          ;desc = "An entity to control & draw a sun effect in the sky."
          use_angles = "0"
          pitch = "0"
          rendercolor = "100 80 80"
          size = "16"
        }
        env_texturetoggle:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that allows you to change the textures on other b"
           "rush-built entities."
        }
        env_tonemap_controller:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that controls the HDR tonemapping for the player."
           " Think of it as a method of controlling the exposure of the player"
           "'s eyes."
        }
        env_wind:e =
        {
          origin = "0 0 0"
          ;desc = "An entity to control wind in the map. Partially functional."
          minwind = "20"
          maxwind = "50"
          mingust = "100"
          maxgust = "250"
          mingustdelay = "10"
          maxgustdelay = "20"
          gustdirchange = "20"
        }
        env_zoom:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that can be used to control the player's FOV. Use"
           "ful for scenes where the player's view is being controlled, or pla"
           "yer-usable binoculars/telescopes, etc."
          Rate = "1.0"
          FOV = "75"
        }
      }

// filter entities

      filter_* entities.qtxfolder =
      {
        filter_activator_class:e =
        {
          origin = "0 0 0"
          ;desc = "A filter that filters by the class name of the activator."
        }
        filter_activator_name:e =
        {
          origin = "0 0 0"
          ;desc = "A filter that filters by the name of the activator."
        }
        filter_damage_type:e =
        {
          origin = "0 0 0"
          ;desc = "A damage filter that filters by the type of damage inflicte"
           "d. This can only be used as a damage filter, not as an activator f"
           "ilter."
          damagetype = "64"
        }
         filter_multi:e =
        {
          origin = "0 0 0"
          ;desc = "A filter that tests the activator against multiple filters."
           " This allows you to build more complex filters, such as'Allow anyo"
           "ne on Team 1 who is also class engineer', or 'Allow everyone excep"
           "t classes npc_zombie and npc_headcrab'."
          filtertype = "0"
          Negated = "0"
        }
      }

// func entities

      func_* entities.qtxfolder =
      {
        func_areaportal:b =
        {
          t_portalpoly=!
          ;desc = "A portal brush used to manage visibility in maps. Portals d"
           "efine areas, which are spaces that are connected in the map. Both "
           "sides of a portal cannot touch the same area, for example, a dough"
           "nut shaped map would require at least two portals to divide the ma"
           "p into two areas. A linear map could be divided into two areas wit"
           "h a single area portal."
          StartOpen = "0"
        }
        func_areaportalwindow:b =
        {
          t_portalpoly=!
          ;desc = "An entity that can be used to optimize the visibility in a "
           "map. If you seal off an area with them, when the viewer moves the "
           "specified distance away from them, they will go opaque and the par"
           "ts inside the area will not be drawn. The 'target' brush model sho"
           "uld enclose the func_areaportal window so no parts of it are culle"
           "d by the window. If you use the optional foreground brush model, t"
           "hen it should enclose the 'target' brush model."
          FadeStartDist = "128"
          FadeDist = "512"
          TranslucencyLimit = "0.2"
        }
        func_breakable:b =
        {
          t_detailpoly=!
          ;desc = "A brush entity that can be broken from damage, or an input."
          minhealthdmg = "0"
          physdamagescale = "1.0"
        }
        func_breakable_surf:b =
        {
          t_nodrawpoly=!
          ;desc = "A breakable surface, for partially breakable glass / tile /"
           " etc.  All faces but the desired visible one must be marked as NOD"
           "RAW and thatface must be 4 sided.  The material applied to the vis"
           "ible face must be set up to be breakable."
          health = "5"
          fragility = "100"
          surfacetype = "0"
          upperleft = "0 0 0"
          upperright = "0 0 0"
          lowerright = "0 0 0"
          lowerleft = "0 0 0"
        }
        func_brush:b =
        {
          t_detailpoly=!
          ;desc = "An brush built entity with various features."
          Solidity = "0"
          solidbsp = "0"
        }
        func_button:b =
        {
          t_detailpoly=!
          ;desc = "A brush entity that's designed to be used for a player-usea"
           "ble button. When used by the player, it moves to a pressed positio"
           "n."
          movedir = "0 0 0"
          speed = "5"
          health = "0"
          lip = "0"
          sounds = "0"
          wait = "3"
          spawnflags = "1024"
          locked_sound = "0"
          unlocked_sound = "0"
          locked_sentence = "0"
          unlocked_sentence = "0"
        }
        func_clip_vphysics:b =
        {
          t_nodrawpoly=!
          ;desc = "A brush entity that's considered solid to vphysics."
        }
        func_conveyor:b =
        {
          t_detailpoly=!
          ;desc = "Conveyor Belt"
          movedir = "0 0 0"
          speed = "100"
        }
        func_detail:b =
        {
          t_detailpoly=!
          ;desc = "An entity that turns its brushes into detail brushes. Detai"
           "l brushes do NOT contribute to visibility in the PVS. World geomet"
           "ry is not clipped to detail brushes, so if you have a small detail"
           " clump attached to a wall, the wall won't be cut up by the detail "
           "brush.func_detail is great for high-frequency brush geometry that'"
           "s visual detail only. It is also ideal for reducing map VIS time."
        }
        func_door:b =
        {
          t_detailpoly=!
          ;desc = "A brush entity for use as a player-useable door."
          movedir = "0 0 0"
        }
        func_door_rotating:b =
        {
          t_detailpoly=!
          ;desc = "A brush entity for use as a rotating player-useable door."
          distance = "90"
          solidbsp = "0"
        }
        func_dustcloud:b =
        {
          t_triggerpoly=!
          ;desc = "A brush entity that spawns a translucent dust cloud within "
           "its volume."
          Alpha = "30"
          SizeMin = "100"
          SizeMax = "200"
        }
        func_dustmotes:b =
        {
          t_triggerpoly=!
          ;desc = "A brush entity that spawns sparkling dust motes within its "
           "volume."
          SizeMin = "10"
          SizeMax = "20"
          Alpha = "255"
        }
        func_guntarget:b =
        {
          t_detailpoly=!
          ;desc = "This is a moving target that moves along a path of path_tra"
           "cks. It can be shot and killed."
          speed = "100"
          health = "0"
        }
        func_illusionary:b =
        {
          t_detailpoly=!
          ;desc = "Legacy support. Use func_brush instead."
        }
        func_ladderendpoint:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to specify the endpoints of a ladder. This e"
           "ntity is functional, but has been replaced by the easier-to-use fu"
           "nc_useableladder entity. Left in only for backwards-compatibility!"
           "\n\nTo be valid, a full sized player hull traced between the start"
           " and end points must not be obstructed at level activation time. T"
           "he angle determines in which direction the player leaves the ladde"
           "r if the player presses the +jump button.\n\nNote: This entity is "
           "non-functional in Counter-Strike: Source. In CS:S, use func_ladder"
           " instead."
        }
        func_lod:b =
        {
          t_detailpoly=!
          ;desc = "Brush-built model that fades out over a specified distance."
           " Useful for creating world detail that doesn't need to be drawn fa"
           "r away, for performance reasons."
          DisappearDist = "2000"
          Solid = "0"
        }
        func_movelinear:b =
        {
          t_detailpoly=!
          ;desc = "A brush entity that moves linearly along a given distance, "
           "in a given direction."
          movedir = "0 0 0"
          startposition = "0"
          speed = "100"
          movedistance = "100"
          blockdamage = "0"
        }
        func_occluder:b =
        {
          t_occluderpoly=!
          ;desc = "A occluder brush used to manage dynamic visibility in maps."
           " Occluders are used to dynamically determine what things are behin"
           "d them, to prevent trying to draw them at all."
          StartActive = "1"
        }
        func_physbox:b =
        {
          t_detailpoly=!
          ;desc = "A brush entity that's physically simulated."
          spawnflags = "524288"
          Damagetype = "0"
          massScale = "0"
          damagetoenablemotion = "0"
          forcetoenablemotion = "0"
          health = "0"
          preferredcarryangles = "0 0 0"
          notsolid = "0"
        }
        func_platrot:b =
        {
          t_detailpoly=!
          ;desc = "A brush entity that moves vertically, and can rotate while "
           "doing so."
          spawnflags = "1"
          speed = "50"
          height = "0"
          rotation = "0"
        }
        func_precipitation:b =
        {
          t_triggerpoly=!
          ;desc = "A brush entity that creates rain and snow inside its volume"
           "."
          renderamt = "5"
          rendercolor = "100 100 100"
          preciptype = "0"
        }
        func_rot_button:b =
        {
          t_detailpoly=!
          ;desc = "A brush entity that's designed to be used for a rotating pl"
           "ayer-useable button. When used by the player, it rotates to a pres"
           "sed position."
          speed = "50"
          health = "0"
          sounds = "21"
          wait = "3"
          distance = "90"
        }
        func_rotating:b =
        {
          t_detailpoly=!
          ;desc = "A rotating brush entity."
          maxspeed = "100"
          fanfriction = "20"
          volume = "10"
          spawnflags = "512"
          dmg = "0"
          solidbsp = "0"
        }
        func_smokevolume:b =
        {
          t_triggerpoly=!
          ;desc = "A brush entity that spawns smoke particles within its volum"
           "e."
          Color1 = "255 255 255"
          Color2 = "255 255 255"
          material = "particle/smoke_grenade1"
          ParticleDrawWidth = "120"
          ParticleSpacingDistance = "80"
          DensityRampSpeed = "1"
          RotationSpeed = "10"
          MovementSpeed = "10"
          Density = "1"
        }
        func_tanktrain:b =
        {
          t_detailpoly=!
          ;desc = "A moving train that follows a path of path_track entities, "
           "shoots at the player, and can be killed.\nNOTE: Build your train s"
           "o that the front of the train is facing down the X axis. When it s"
           "pawns it will automatically rotate to face the next path_track on "
           "the path."
          health = "100"
        }
        func_trackautochange:b =
        {
          t_detailpoly=!
          ;desc = "An entity that works as a rotating/moving platform that wil"
           "l carry a train to a new track. It must be larger in X-Y planar ar"
           "ea than the train, since it must contain the train within these di"
           "mensions in order to operate when the train is near it."
        }
        func_trackchange:b =
        {
          t_detailpoly=!
          ;desc = "An entity that works as a rotating/moving platform that wil"
           "l carry a train to a new track. It must be larger in X-Y planar ar"
           "ea than the train, since it must contain the train within these di"
           "mensions in order to operate when the train is near it."
        }
        func_tracktrain:b =
        {
          t_detailpoly=!
          ;desc = "A moving platform that the player can ride. It follows a pa"
           "th of path_track entities.\nNOTE: Build your train so that the fro"
           "nt of the train is facing down the X axis. When it spawns it will "
           "automatically rotate to face the next path_track on the path."
        }
        func_traincontrols:b =
        {
          t_detailpoly=!
          ;desc = "When used by the player, this entity overrides the player's"
           " controls to let them drive a train."
        }
        func_useableladder:e =
        {
          origin = "0 0 0"
          ;desc = "A Half-Life 2 ladder. Handles player auto mount/unmount, as"
           " well as +use to get onto the ladder. \n\nSee also 'info_ladder_di"
           "smount', used to specify ladder auto-dismount points.\n\nNote: Thi"
           "s entity is non-functional in Counter-Strike: Source. Use func_lad"
           "der instead."
          StartDisabled = "0"
          point0 = "0 0 0"
          point1 = "0 0 0"
        }
        func_wall:b =
        {
          t_detailpoly=!
          ;desc = "Legacy support. Use func_brush instead."
        }
        func_wall_toggle:b =
        {
          t_detailpoly=!
          ;desc = "A brush entity that can be toggled on/off. When off, the br"
           "ush will be non-solid and invisible. Does not cast lightmap shadow"
           "s."
        }
        func_water_analog:b =
        {
          t_detailpoly=!
          ;desc = "A water brush entity that moves linearly along a given dist"
           "ance, in a given direction"
          movedir = "0 0 0"
          startposition = "0"
          speed = "100"
          movedistance = "100"
          WaveHeight = "3.0"
        }
      }

// game entities

      game_* entities.qtxfolder =
      {
        game_end:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that ends a multiplayer game."
        }
        game_player_equip:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that gives equipment to the player who activates "
           "it. To use, add new keys to this entity, where each key is the cla"
           "ssname of a weapon/item, and the corresponding value is the number"
           " of those weapons/items to give to the player who uses this entity"
           ". If the 'Use Only' spawnflag isn't set, then players can just tou"
           "ch this entity to get the equipment."
        }
        game_player_team:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that changes the team of the player who activates"
           " it."
        }
        game_ragdoll_manager:e =
        {
          origin = "0 0 0"
          ;desc = "An entity to control the number of ragdolls in the world, f"
           "or performance reasons."
          MaxRagdollCount = "-1"
        }
        game_score:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that awards/deducts points from the player who ac"
           "tivates it."
          points = "1"
        }
        game_text:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that displays text on player's screens."
          x = "-1"
          y = "-1"
          effect = "0"
          color = "100 100 100"
          color2 = "240 110 0"
          fadein = "1.5"
          fadeout = "0.5"
          holdtime = "1.2"
          fxtime = "0.25"
          channel = "1"
        }
        game_ui:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to override player input when the player is "
           "looking at it."
          spawnflags = "480"
          FieldOfView = "-1.0"
        }
        game_weapon_manager:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to limit the number of a particular weapon t"
           "ype in the world. Useful in places where NPCs are spawning rapidly"
           ", dying, and dropping weapons."
          maxpieces = "0"
        }
        game_zone_player:b =
        {
          t_triggerpoly=!
          ;desc = "An entity used to count the number of players within a zone"
           "."
        }
      }

// info entities

      info_* entities.qtxfolder =
      {
        info_camera_link:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that can use point_cameras to render images for m"
           "aterials used by entities. To author the material, use the special"
           " identifier _rt_Camera for the $baseTexture (or whatever texture y"
           "ou want, like envmap, etc.) in the .vmt then connect the 'target' "
           "field to the entity which uses that material, and the 'PointCamera"
           "' field to the point_camera you want to have appear on that entity"
           "'s material"
        }
        info_constraint_anchor:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to attach constraints to a local position on"
           " an entity. Usually constraints will attach to the center of mass "
           "of an object. Attach the desired constraint to this entity, and th"
           "en parent this entity to the entity you want the constraint to app"
           "ly to."
          massScale = "1"
        }
        info_hint:e =
        {
          origin = "0 0 0"
          ;desc = "A hint that is not used for navigation. They don't go into "
           "the nodegraph, nor do they fall to the ground. Use these to provid"
           "e some spatial context for NPCs, such as 'look here if you can't f"
           "ind the player' or 'throw rocks at this spot'."
        }
        info_intermission:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that defines an intermission spot where dead play"
           "ers will float until they respawn."
        }
        info_ladder_dismount:e =
        {
          origin = "0 0 0"
          ;desc = "An entity to handle endpoints for multiple ladders that are"
           " too close to each other."
        }
        info_landmark:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that acts as a landmark for transitions to anothe"
           "r level. There should be a corresponding info_landmark entity in t"
           "he next map. Entities will be transitioned to the next level relat"
           "ive to the info_landmark entities."
        }
        info_lighting:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that can be used to change the lighting origin of"
           " a prop_static. Set the prop_static's Lighting Origin to point at "
           "this entity to make the prop_static light as if it was at the info"
           "_lighting's origin. Good for prop_static entities that are embedde"
           "d in world geometry (like rocks/windows/etc)."
        }
        info_mass_center:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that overrides the mass center of the target phys"
           "ics prop, or func_physbox, by moving it to the info_mass_center's "
           "location."
        }
        info_no_dynamic_shadow:e =
        {
          origin = "0 0 0"
          ;desc = "Use this entity to mark surfaces that shouldn't receive dyn"
           "amic shadows. Useful to apply to walls and floors where shadows ar"
           "e drawn improperly, giving away the location of enemies."
        }
        info_node:e =
        {
          origin = "0 0 0"
          ;desc = "A navigation node for ground moving NPCs. Navigation nodes "
           "are baked into the nodegraph so that NPCs can move to them. Ground"
           " nodes fall to the ground when they spawn."
        }
        info_node_air:e =
        {
          origin = "0 0 0"
          ;desc = "A navigation node for flying NPCs. Air navigation nodes are"
           " baked into the nodegraph so that NPCs can move to them. Air nodes"
           " do not fall to the ground when they spawn."
          nodeheight = "0"
        }
        info_node_air_hint:e =
        {
          origin = "0 0 0"
          ;desc = "A navigation node for flying NPCs that includes some contex"
           "t information for NPCs that are interested in it. The hint might i"
           "ndicate a window that could be looked into, or an item of interest"
           " that could be commented on. Many hint nodes are NPC-specific, so "
           "it's helpful to use naming conventions like 'Crow: Fly to point' i"
           "n the hint choices list. The angles of a hint node indicate what d"
           "irection the NPC should face to perform the hint behavior."
          nodeheight = "0"
        }
        info_node_climb:e =
        {
          origin = "0 0 0"
          ;desc = "A climb-node for AI navigation. Only usable by NPCs that ca"
           "n climb."
        }
        info_node_hint:e =
        {
          origin = "0 0 0"
          ;desc = "A navigation node for ground moving NPCs that includes some"
           " context information for NPCs that are interested in it. The hint "
           "might indicate a window that could be looked out of, or an item of"
           " interest that could be commented on. Many hint nodes are NPC-spec"
           "ific, so it's helpful to use naming conventions like 'Crow: Fly to"
           " point' in the hint choices list. The angles of a hint node indica"
           "te what direction the NPC should face to perform the hint behavior"
           ".\n\nIt's important to understand the distinction between scripts,"
           " such as scripted_sequence and scripted_schedule, and info_hint en"
           "tities. Scripts summon NPCs to specific cue points to play their p"
           "arts, while hints provide context information to the AI that they "
           "use to perform their behaviors. Hints require code support in the "
           "NPC, while scripts are generic and may require only animations to "
           "play. Use a hint if the behavior is driven by the AI, use a script"
           " if the behavior is driven by the map."
        }
        info_node_link:e =
        {
          origin = "0 0 0"
          ;desc = "A dynamic connection between two navigation nodes. You spec"
           "ify the node IDs of the start and end nodes, and then you can use "
           "entity I/O to turn on and off the connection. This could be used t"
           "o create or destroy a connection in the nodegraph because of some "
           "event in your map (a bridge being created/destroyed, etc)."
          initialstate = "1"
        }
        info_node_link_controller:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that controls all connections between nodes that "
           "intersect the controller's volume. This allows for mass enabling/d"
           "isabling of all node connections through a volume."
          mins = "-8 -32 -36"
          maxs = "8 32 36"
          initialstate = "1"
        }
        info_npc_spawn_destination:e =
        {
          origin = "0 0 0"
          ;desc = "NPC Spawn Destination. (Consult npc_template_maker help for"
           " more info)"
          ReuseDelay = "1"
        }
        info_null:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that's immediately removed on spawning. Useful as"
           " a spotlight target."
        }
        info_overlay:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that places an overlay on the world."
          RenderOrder = "0"
          StartU = "0.0"
          EndU = "1.0"
          StartV = "0.0"
          EndV = "1.0"
        }
        info_player_start:e =
        {
          origin = "0 0 0"
          angles = "0 0 0"
          ;desc = "This entity indicates the position and facing direction at "
           "which the player will spawn. Any number of info_player_start entit"
           "ies may be placed in a map for when working in cordoned-off portio"
           "ns of the map. When multiple info_player_start entities are presen"
           "t in a map, set the 'Master' spawnflag on one of them to indicate "
           "which one should be used when running the entire map."
        }
        info_projecteddecal:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that projects a decal onto the world (or props). "
           "If the decal has no target name, it will immediately apply itself "
           "when the level is loaded. If it has a name specified, it won't app"
           "ly until it receives the 'Activate' input."
          Distance = "64"
        }
        info_target:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that does nothing. Very useful as a positioning e"
           "ntity for other entities to refer to (i.e. the endpoint of an env_"
           "beam)"
        }
        info_teleport_destination:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that does nothing itself, but can be used to spec"
           "ify the destination for a trigger_teleport entity. An info_target "
           "can be used instead."
        }
      }

// keyframe entities

      keyframe_* entities.qtxfolder =
      {
        keyframe_rope:e =
        {
          origin = "0 0 0"
          ;desc = "A node entity that marks a point in a rope. The first node "
           "in the rope should be a move_rope, followed by 1 or more keyframe_"
           "ropes."
        }
        keyframe_track:e =
        {
          origin = "0 0 0"
          ;desc = "Animation KeyFrame"
        }
       }

// light entities

      light_* entities.qtxfolder =
      {
        light:e =
        {
          style = "Normal"
          _light = "255 255 255 300"
          origin = "0 0 0"
          ;desc = "An invisible omnidirectional lightsource."
        }
        light_dynamic:e =
        {
          origin = "0 0 0"
          angles = "0 0 0"
          ;desc = "An invisible lightsource that changes in some way over time"
           "."
          _light = "255 255 255 200"
          brightness = "0"
          _inner_cone = "30"
          _cone = "45"
          pitch = "-90"
          distance = "120"
          spotlight_radius = "80"
          style = "0"
        }
        light_environment:e =
        {
         origin = "0 0 0"
         angles = "0 0 0"
          ;desc = "Sets the color and angle of the light from the sun and sky."
          pitch = "0"
          _light = "255 201 128 210"
          _ambient = "103 143 184 50"
        }
        light_spot:e =
        {
          origin = "0 0 0"
          angles = "0 0 0"
          ;desc = "An invisible and directional spotlight."
          _light = "255 255 255 500"
          _inner_cone = "35"
          _cone = "45"
          _exponent = "1"
          _distance = "0"
          pitch = "-90"
        }
      }

// logic entities

      logic_* entities.qtxfolder =
      {
        logic_auto:e =
        {
          origin = "0 0 0"
          ;desc = "Fires outputs when a map spawns. If 'Remove on fire' flag i"
           "s set the logic_auto is deleted after firing. It can be set to che"
           "ck a global state before firing. This allows you to only fire even"
           "ts based on what took place in a previous map."
          spawnflags = "1"
        }
        logic_autosave:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that is used to force an autosave."
          NewLevelUnit = "0"
        }
        logic_branch:e =
        {
          origin = "0 0 0"
          ;desc = "Tests a boolean value and fires an output based on whether "
           "the value is true or false. Use this entity to branch between two "
           "potential sets of events."
        }
        logic_case:e =
        {
          origin = "0 0 0"
          ;desc = "Compares an input to up to 16 preset values. If the input v"
           "alue is the same as any of the preset values, an output correspond"
           "ing to that value is fired.\n\nFor example: if Case01 is set to 2 "
           "and Case02 is set to 5, and the input value is 5, the OnCase02 out"
           "put will be fired.\n\nThis entity can also be used to select from "
           "a number of random targets via the PickRandom input. One of the On"
           "Case outputs that is connected to another entity will be picked at"
           " random and fired."
        }
        logic_collision_pair:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that can be used to enables/disable vphysics coll"
           "isions between two target entities."
          startdisabled = "1"
        }
       logic_compare:e =
        {
          origin = "0 0 0"
          ;desc = "Compares an input value to another value. If the input valu"
           "e is less than the compare value, the OnLessThan output is fired w"
           "ith the input value. If the input value is equal to the compare va"
           "lue, the OnEqualTo output is fired with the input value. If the in"
           "put value is greater than the compare value, the OnGreaterThan out"
           "put is fired with the input value."
        }
        logic_lineto:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that calculates and outputs a vector from one ent"
           "ity to another."
        }
        logic_measure_movement:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that can measure the movement of an entity relati"
           "ve to another entity and apply that movement to a third entity."
          TargetScale = "1"
          MeasureType = "0"
        }
        logic_multicompare:e =
        {
          origin = "0 0 0"
          ;desc = "Compares a set of inputs to each other. If they are all the"
           " same, fires an OnEqual output. If any are different, fires the On"
           "NotEqual output."
          ShouldComparetoValue = "0"
        }
        logic_navigation:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that is used to set navigation properties on othe"
           "r entities. Useful to make NPCs ignore physics props in their way "
           "that they can easily push."
          target = "Name of the entity to set navigation properties on."
          spawnflags = "1"
          navprop = "Ignore"
        }
        logic_relay:e =
        {
          origin = "0 0 0"
          ;desc = "A message forwarder. Fires an OnTrigger output when trigger"
           "ed, and can be disabled to prevent forwarding outputs.\n\nUseful a"
           "s an intermediary between one entity and another for turning on or"
           " off an I/O connection, or as a container for holding a set of out"
           "puts that can be triggered from multiple places."
        }
        logic_timer:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that fires a timer event at regular, or random, i"
           "ntervals. It can also be set to oscillate betweena high and low en"
           "d, in which case it will fire alternating high/low outputs each ti"
           "me it fires."
          UseRandomTime = "0"
        }
      }

// math entities

      math_* entities.qtxfolder =
      {
        math_colorblend:e =
        {
          origin = "0 0 0"
          ;desc = "Used to create a blend between two colors for controlling t"
           "he color of another entity."
          spawnflags = "1"
          inmin = "0"
          inmax = "1"
          colormin = "0 0 0"
          colormax = "255 255 255"
        }
        math_counter:e =
        {
          origin = "0 0 0"
          ;desc = "Holds a numeric value and performs arithmetic operations up"
           "on it. If either the minimum or maximum legal value is nonzero, Ou"
           "tValue will be clamped to the legal range, and the OnHitMin/OnHitM"
           "ax outputs will be fired at the appropriate times. If both min and"
           " max are set to zero, no clamping is performed and only the OutVal"
           "ue output will be fired."
          startvalue = "0"
          min = "0"
          max = "0"
        }
        math_remap:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that remaps a range of input values to a given ra"
           "nge of output values."
          spawnflags = "1"
          in1 = "0"
          in2 = "1"
        }
      }

// move entities

      move_* entities.qtxfolder =
      {
        move_keyframed:e =
        {
          origin = "0 0 0"
          ;desc = "Keyframed Move Behavior"
        }
        move_rope:e =
        {
          origin = "0 0 0"
          ;desc = "The first node in set of nodes that are used to place ropes"
           " in the world. It should connect to 1 or more keyframe_rope entiti"
           "es."
          PositionInterpolator = "2"
        }
        move_track:e =
        {
          origin = "0 0 0"
          ;desc = "Track Move Behavior"
          WheelBaseLength = "50"
          Damage = "0"
          NoRotate = "0"
        }
      }

// npc entities

      npc_* entities.qtxfolder =
      {
        npc_furniture:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used for non-NPCs that need to synchronise their "
           "animation with an NPC in a scripted_sequence. Usually a pieceof fu"
           "rniture or door that an NPC needs to manipulate within a scripted_"
           "sequence."
        }
        npc_template_maker:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that creates NPCs. The NPCs it creates are clones"
           " of a template NPC. NPCs are spawned around this maker's origin, o"
           "r at specified destination points."
          Radius = "256"
          CriterionVisibility = "2"
          CriterionDistance = "2"
        }
      }

// other entities

      other entities.qtxfolder =
      {
        ai_speechfilter:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that can be used to control the idle speech patte"
           "rns of a set of NPCs."
          IdleModifier = "1.0"
          NeverSayHello = "0"
        }
        ambient_generic:e =
        {
          origin = "0 0 0"
          ;desc = "Universal ambient sound. Use it to play and control a singl"
           "e sound."
          health = "10"
          preset = "0"
          volstart = "0"
          fadein = "0"
          fadeout = "0"
          pitch = "100"
          pitchstart = "100"
          spinup = "0"
          spindown = "0"
          lfotype = "0"
          lforate = "0"
          lfomodpitch = "0"
          lfomodvol = "0"
          cspinup = "0"
          radius = "1250"
          spawnflags = "48"
        }
        cycler:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to display a model for testing purposes. Sho"
           "oting it with cycle through the model's animations."
          skin = "0"
          sequence = "0"
        }
        gibshooter:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that shoots out gibs. Style of body part depends "
           "on language type."
        }
        infodecal:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that places a decal on the world. If the decal ha"
           "s no target name, it will immediately apply itself when the level "
           "is loaded. If it has a name specified, it won't apply until it rec"
           "eives the 'Activate' input."
          LowPriority = "0"
        }
        material_modify_control:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that can be used to directly control material var"
           "s. To use it, you need to read the .vmt of the material you intend"
           " to change. Parent this entity to a brush model entity who's mater"
           "ial you want to control."
        }
        momentary_rot_button:b =
        {
          t_detailpoly=!
          ;desc = "A brush entity that's designed to be used for rotating whee"
           "ls, where the player can rotate them to arbitrary positions before"
           " stopping."
          speed = "50"
          sounds = "0"
          distance = "90"
          returnspeed = "0"
          spawnflags = "1057"
          startposition = "0"
          startdirection = "Forward"
          solidbsp = "0"
        }
        path_track:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to build paths for other entities to follow."
           " Each path_track is a node on the path, each holding the name of t"
           "he next path_track in the path."
          speed = "0"
          radius = "0"
          orientationtype = "1"
        }
        physics_cannister:e =
        {
          origin = "0 0 0"
          ;desc = "A physically simulated gas cannister that can have its cap "
           "shot off, at which point gas will start escaping and cause the can"
           "nister to fly around. If it takes enough damage, it will explode."
          model = "models/fire_equipment/w_weldtank.mdl"
          spawnflags = "2"
          expdamage = "200.0"
          expradius = "250.0"
          health = "25"
          thrust = "3000.0"
          fuel = "12.0"
          rendercolor = "255 255 255"
          renderamt = "128"
          gassound = "ambient/objects/cannister_loop.wav"
        }
        shadow_control:e =
        {
          origin = "0 0 0"
          ;desc = "An entity to control the shadows in the map."
          angles = "80 30 0"
          color = "128 128 128"
          distance = "75"
        }
        sky_camera:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to control the 3D Skybox. Its origin is used"
           " to determine the 3D Skybox's position relative to the map. Place "
           "this entity, in the 3D Skybox, at the point where the origin of th"
           "e map should be."
          scale = "16"
          fogenable = "0"
          fogblend = "0"
          use_angles = "0"
          fogcolor = "255 255 255"
          fogcolor2 = "255 255 255"
          fogdir = "1 0 0"
          fogstart = "500.0"
          fogend = "2000.0"
        }
        tanktrain_ai:e =
        {
          origin = "0 0 0"
          ;desc = "Train chase AI"
          startsound = "vehicles/diesel_start1.wav"
          enginesound = "vehicles/diesel_turbo_loop1.wav"
          movementsound = "vehicles/tank_treads_loop1.wav"
        }
        tanktrain_aitarget:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that changes the target of a tanktrain_ai entity."
        }
        test_traceline:e =
        {
          origin = "0 0 0"
          ;desc = "A debugging tool for testing tracelines."
        }
        vgui_screen:e =
        {
          origin = "0 0 0"
          ;desc = "A VGUI screen. Useful for in-world monitors."
        }
        water_lod_control:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to control the LOD behavior of any water in "
           "the map. If your map has water, this entity is required."
          cheapwaterstartdistance = "1000"
          cheapwaterenddistance = "2000"
        }
        worldspawn:b =
        {
          ;desc = "This is the world entity. Each map can only contain one, an"
           "d it's automatically created for you."
        }
      }

// phys entities

      phys_* entities.qtxfolder =
      {
        phys_ballsocket:e =
        {
          origin = "0 0 0"
          ;desc = "A constraint that keeps the position of two objects fixed, "
           "relative to the constraint's origin. It does not affect rotation."
        }
        phys_constraint:e =
        {
          origin = "0 0 0"
          ;desc = "A constraint that keeps the relative position and orientati"
           "on of two objects fixed."
          spawnflags = "1"
        }
        phys_constraintsystem:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to manage a group of interacting constraints"
           " and keep them stable. All constraints on a set of entities should"
           " be placed in the same system, or they will fight each other durin"
           "g simulation."
          additionaliterations = "0"
        }
        phys_convert:e =
        {
          origin = "0 0 0"
          ;desc = "Turns an arbitrary entity into a physically simulated entit"
           "y. i.e. brush entities will behave like func_physbox, model entiti"
           "es behave like prop_physics."
        }
        phys_hinge:e =
        {
          origin = "0 0 0"
          ;desc = "A physically simulated hinge. Use the helper to define the "
           "axis of rotation."
          hingefriction = "0"
          SystemLoadScale = "1"
        }
        phys_keepupright:e =
        {
          origin = "0 0 0"
          ;desc = "A controller that tries to keep an entity facing a particul"
           "ar direction."
          angularlimit = "15"
        }
        phys_lengthconstraint:e =
        {
          origin = "0 0 0"
          ;desc = "A constraint that preserves the distance between two entiti"
           "es. If the 'Keep Rigid' flag is set, think of it as a rod. If not,"
           " think off it as a virtual rope."
          addlength = "0"
          minlength = "0"
          attachpoint = "The position the rope attaches to object 2"
          spawnflags = "1"
        }
        phys_magnet:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that acts like a magnet, attaching metallic physi"
           "cs objects to itself when they touch it."
          forcelimit = "0"
          torquelimit = "0"
          massScale = "0"
          maxobjects = "0"
        }
        phys_motor:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that tries to spin a target entity at a particula"
           "r speed."
          speed = "0"
          spinup = "1"
          inertiafactor = "1.0"
          spawnflags = "5"
        }
        phys_pulleyconstraint:e =
        {
          origin = "0 0 0"
          ;desc = "A constraint that is essentially two length constraints and"
           " two points. Imagine it as a virtual rope connected to two objects"
           ", each suspended from a pulley above them.The constraint keeps the"
           " sum of the distances between the pulley points and their suspende"
           "d objects constant."
          addlength = "0"
          gearratio = "1"
          spawnflags = "1"
        }
        phys_ragdollconstraint:e =
        {
          origin = "0 0 0"
          ;desc = "A constraint that fixes the position of two entities, relat"
           "ive to this constraint's origin. Also allows for limits on the rot"
           "ation around each axis, in the space of this constraint."
          spawnflags = "1"
          xmin = "-90"
          xmax = "90"
          ymin = "0"
          ymax = "0"
          zmin = "0"
          zmax = "0"
          xfriction = "0"
          yfriction = "0"
          zfriction = "0"
        }
        phys_ragdollmagnet:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that acts like a magnet for ragdolls. Useful for "
           "crafting exaggerated ragdoll behavior (i.e. guys falling over rail"
           "s on death). If the Bar Magnet spawnflag is set, the magnet works "
           "like it was a cylindrical magnet i.e. it attracts ragdolls to the "
           "nearest point on a line."
          radius = "512"
          force = "5000"
        }       
        phys_slideconstraint:e =
        {
          origin = "0 0 0"
          ;desc = "A constraint that constrains an entity along a line segment"
           "."
          spawnflags = "1"
          slidefriction = "0"
          SystemLoadScale = "1"
        }
        phys_spring:e =
        {
          origin = "0 0 0"
          ;desc = "A physically simulated spring. 'Length' is what's known as "
           "the 'natural spring length'. This is how long the spring would be "
           "if it was at rest (nothing hanging on it or attached). When you at"
           "tach something to the spring, it will stretch longer than its 'nat"
           "ural length'. The amount of stretch is determined by the 'Sprint C"
           "onstant'. The larger the spring constant the less stretch the spri"
           "ng."
          length = "0"
          constant = "50"
          damping = "2.0"
          relativedamping = "0.1"
          breaklength = "0"
        }       
        phys_thruster:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to apply constant acceleration to a physics "
           "object. The force and torque is calculated using the position and "
           "direction of the thruster as an impulse. So moving those off the o"
           "bject's center will cause torque as well. Torque can be removed by"
           " unchecking the 'apply torque' flag. The position of the thruster "
           "can be forced to be at the object's center by checking to 'ignore "
           "pos' flag."
          force = "0"
        }
        phys_torque:e =
        {
          origin = "0 0 0"
          ;desc = "An angular thruster. Use it to apply angular force to an en"
           "tity."
          force = "0"
        }
      }

// point entities

      point_* entities.qtxfolder =
      {
        point_anglesensor:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that detects if another entity points in a given "
           "direction for a period of time."
        }
        point_angularvelocitysensor:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that detects if another entity's angular velocity"
           " meets or exceeds a threshold value."
          threshold = "0"
        }
        point_clientcommand:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that issues commands to the client console, as if"
           " it was typed in by the player (if activator is a player, or the l"
           "ocal player in single player)."
        }
        point_devshot_camera:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used by the -makedevshots system, which automatic"
           "ally takes screenshots at the position of every devshot camera in "
           "the level."
          FOV = "75"
        }
        point_enable_motion_fixup:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to move a motion-disabled prop when it enabl"
           "es motion. Parent this entity to the prop, and when the prop has i"
           "ts motion enabled, it will immediately teleport to the origin of t"
           "his entity."
        }
        point_hurt:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that does damage to all entities in a radius arou"
           "nd itself, with a specified delay.If 'Target Entity' is specified,"
           " the damage is only done to that entity."
          DamageRadius = "256"
          Damage = "5"
          DamageDelay = "1"
          DamageType = "0"
        }
        point_message:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that displays a text message in the world, at its"
           " origin."
          radius = "128"
          developeronly = "0"
        }
        point_playermoveconstraint:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that constrains players to a radius around itself"
           ", slowing them down the closer they get to the edge of the radius."
          radius = "256"
          width = "75.0"
          speedfactor = "0.15"
        }
        point_servercommand:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that issues commands to the server console."
        }
        point_spotlight:e =
        {
          origin = "0 0 0"
          angles = "0 0 0"
          ;desc = "An entity to draw a spotlight. Will draw a beam when the pl"
           "ayer views it side on, and a halo when it's facing towards the pla"
           "yer. Unless the 'No Dynamic Light' spawnflag is checked, it will a"
           "lso create a dynamic light wherever the end of the spotlight rests"
           "."
          spawnflags = "3"
          spotlightlength = "500"
          spotlightwidth = "50"
          rendercolor = "255 255 255"
        }
        point_teleport:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that teleports a target entity to this position a"
           "nd angles. If 'Teleport Home' spawn flag is set, teleports the tar"
           "get entity to its spawn position instead.If object is physically s"
           "imulated, simulation is turned off when teleported."
        }
        point_template:e =
        {
          origin = "0 0 0"
          ;desc = "Turns an entity, or set of entities, into a single template"
           " that can be instanced anywhere, and multiple times. If there are "
           "interdependencies (entity I/O, hierarchy, or other name references"
           ") between the entities in the template, the entities in the templa"
           "te will have their names changed and the interdependencies will be"
           " reconnected to the changes names. The name change format is as fo"
           "llows: '<original name>&0000', where the 0000 will be replaced wit"
           "h the current global template instance, so wildcard searches for '"
           "<original name>*' will still find them.\nIf you don't want the nam"
           "e fixup to happen, because you're only spawning the template once,"
           " or you want inputs to trigger all instances of the template, chec"
           "k the 'Preserve entity names' spawnflag. \nTo spawn the template i"
           "n other places, use an env_entity_maker."
          spawnflags = "2"
        }
        point_tesla:e =
        {
          origin = "0 0 0"
          ;desc = "An entity that creates tesla lightning arcs around its orig"
           "in."
          m_SoundName = "DoSpark"
          texture = "sprites/physbeam.vmt"
          m_Color = "255 255 255"
          m_flRadius = "200"
          beamcount_min = "6"
          beamcount_max = "8"
          thick_min = "4"
          thick_max = "5"
          lifetime_min = "0.3"
          lifetime_max = "0.3"
          interval_min = "0.5"
          interval_max = "2"
        }
        point_viewcontrol:e =
        {
          origin = "0 0 0"
          ;desc = "A camera entity that controls the player's view. While it's"
           " active, the player will see out of the camera."
          wait = "10"
          spawnflags = "3"
          speed = "0"
          acceleration = "500"
          deceleration = "500"
        }
      }

// prop entities

      prop_* entities.qtxfolder =
      {
        prop_detail:e =
        {
          origin = "0 0 0"
          ;desc = "Detail Prop"
        }
        prop_door_rotating:e =
        {
          origin = "0 0 0"
          ;desc = "An entity used to place a door in the world."
          hardware = "1"
          ajarangles = "0 0 0"
          spawnpos = "0"
          distance = "90"
          speed = "100"
          returndelay = "-1"
          dmg = "0"
          health = "0"
          forceclosed = "0"
          spawnflags = "8192"
        }
        prop_dynamic:e =
        {
          origin = "0 0 0"
          angles = "0 0 0"
          fademindist = "-1"
          fadescale = "1"
          ;desc = "A prop that can be placed in hierarchy and can play animati"
           "ons. It can also be configured to break when it takes enough damag"
           "e. Note that the health of the object will be overridden by the he"
           "alth inside the model, to ensure consistent health game-wide. If t"
           "he model used by the prop is configured to be used as a prop_physi"
           "cs (i.e. it should be physically simulated) then it CANNOT be used"
           " as a prop_dynamic. Upon level load it will display a warning in t"
           "he console and remove itself. Use a prop_physics instead."
        }
        prop_dynamic_ornament:e =
        {
          origin = "0 0 0"
          ;desc = "A way to attach one studio model to another as an ornament."
           " It will render in the way that player/NPC weapons render."
          solid = "0"
        }
        prop_dynamic_override:e =
        {
          origin = "0 0 0"
          angles = "0 0 0"
          fademindist = "-1"
          fadescale = "1"
          ;desc = "A prop that can be placed in hierarchy and can play animati"
           "ons. It can also be configured to break when it takes enough damag"
           "e.\nprop_dynamic_override is a prototyping entity only. It will al"
           "low the use of models designed to be used as prop_physics."
          health = "0"
        }
        prop_physics:e =
        {
          origin = "0 0 0"
          angles = "0 0 0"
          fademindist = "-1"
          fadescale = "1"
          ;desc = "A prop that physically simulates as a single rigid body. It"
           " can be constrained to other physics objects using hinges or other"
           " constraints. It can also be configured to break when it takes eno"
           "ugh damage. Note that the health of the object will be overridden "
           "by the health inside the model, to ensure consistent health game-w"
           "ide. If the model used by the prop is configured to be used as a p"
           "rop_dynamic (i.e. it should not be physically simulated) then it C"
           "ANNOT be used as a prop_physics. Upon level load it will display a"
           " warning in the console and remove itself. Use a prop_dynamic inst"
           "ead."
        }
        prop_physics_multiplayer:e =
        {
          origin = "0 0 0"
          angles = "0 0 0"
          fademindist = "-1"
          fadescale = "1"
          ;desc = "This class is the same as prop_physics, except the runtime "
           "collisions use a more bouncy method that avoids the prediction err"
           "ors normal physics objects get."
        }
        prop_physics_override:e =
        {
          origin = "0 0 0"
          angles = "0 0 0"
          fademindist = "-1"
          fadescale = "1"
          ;desc = "A prop that physically simulates as a single rigid body. It"
           " can be constrained to other physics objects using hinges or other"
           " constraints. It can also be configured to break when it takes eno"
           "ugh damage. Health can be overridden on this version."
          health = "0"
        }
        prop_ragdoll:e =
        {
          origin = "0 0 0"
          ;desc = "A prop that physically simulates and can be articulated wit"
           "h internal joints. The joint constraints are part of the physics m"
           "odel."
          spawnflags = "4"
          fademindist = "-1"
          fademaxdist = "0"
          fadescale = "1"
        }
        prop_static:e =
        {
          origin = "0 0 0"
          angles = "0 0 0"
          fademindist = "-1"
          fadescale = "1"
          ;desc = "A prop that doesn't move and doesn't animate."
        }
      }

// trigger entities

      trigger_* entities.qtxfolder =
      {
        trigger_autosave:b =
        {
          t_triggerpoly=!
          ;desc = "A trigger volume that autosaves when the player touches it."
          NewLevelUnit = "0"
        }
        trigger_changelevel:b =
        {
          t_triggerpoly=!
          ;desc = "An entity that triggers a level change.\nPlace an info_land"
           "mark in both maps that marks the 'same' location in each map.\nTIP"
           "S & TRICKS: To fire events in the next level, use the OnLevelChang"
           "e output to turn on an env_global in the current level.  Create an"
           " logic_auto in the next level that checks for the state set by the"
           " env_global.\n\nTo control which entities go through the level tra"
           "nsition, create one or more trigger_transitions and give them the "
           "same name as the landmark. Any entities within the trigger_transit"
           "ion(s) will go to the next map."
        }
        trigger_gravity:b =
        {
          t_triggerpoly=!
          ;desc = "A trigger volume that changes the gravity on any entity tha"
           "t touches it."
          gravity = "1"
        }
        trigger_hurt:b =
        {
          t_triggerpoly=!
          ;desc = "A trigger volume that damages entities that touch it."
          damage = "10"
          damagecap = "20"
          damagetype = "0"
          damagemodel = "0"
        }
        trigger_impact:b =
        {
          t_triggerpoly=!
          ;desc = "A trigger volume that can be told to push all physics objec"
           "ts that are inside of it in the direction specified by this trigge"
           "r's angles.\nAlso outputs the force at the time of impact for anyo"
           "ne else that wants to use it."
          Magnitude = "200"
          noise = "0.1"
          viewkick = "0.05"
        }
        trigger_look:b =
        {
          t_triggerpoly=!
          ;desc = "An entity used to trigger something when the player looks a"
           "t something. It fires 'OnTrigger' when the player looks at a targe"
           "t entity for the given amount of time, while within the trigger vo"
           "lume. If the player leaves the trigger or looks away from the targ"
           "et entity the clock resets. If the 'Use Velocity instead of facing"
           "' spawnflag is checked, the trigger uses the player's velocity ins"
           "tead of the player's view, so it determines whenever the player is"
           " moving toward the target entity. Useful for triggering when playe"
           "rs are driving a vehicle at something.NOTE: Only designed for sing"
           "le-player game. "
          spawnflags = "128"
          LookTime = "0.5"
          FieldOfView = "0.9"
          Timeout = "0"
        }
        trigger_multiple:b =
        {
          t_triggerpoly=!
          ;desc = "A trigger volume that can be triggered multiple times."
          wait = "1"
        }
        trigger_once:b =
        {
          t_triggerpoly=!
          ;desc = "A trigger volume that removes itself after it is triggered "
           "once."
        }
        trigger_playermovement:b =
        {
          t_triggerpoly=!
          ;desc = "An entity that can be used to disable player's automatic du"
           "cking/unducking when jumping."
          spawnflags = "128"
        }
        trigger_proximity:b =
        {
          t_triggerpoly=!
          ;desc = "Measures the distance of the player within the trigger volu"
           "me from a given point (and within a given radius). The NearestPlay"
           "erDistance output will be 0 when the player is at the center point"
           ", and 1 when the player is at the radius."
          radius = "256"
        }
        trigger_push:b =
        {
          t_triggerpoly=!
          ;desc = "A trigger volume that pushes entities that touch it."
          pushdir = "0 0 0"
          speed = "40"
        }
        trigger_remove:b =
        {
          t_triggerpoly=!
          ;desc = "A trigger volume that removes any entities that touch it. B"
           "e careful, removing some entities can cause instability. This is n"
           "ot the same as killing entities. i.e. NPCs removed in this manner "
           "will not fire their OnKilled outputs."
        }
        trigger_soundscape:b =
        {
          t_triggerpoly=!
          ;desc = "Soundscape trigger. It is not necessary to create outputs f"
           "or this trigger. It automatically will trigger the soundscape refe"
           "rred to by its 'Soundscape' property."
        }
        trigger_teleport:b =
        {
          t_triggerpoly=!
          ;desc = "A trigger volume that teleports entities that touch it. Ent"
           "ities are teleported to the Remote Destination, and have their ang"
           "les set to that of the Remote Destination's. If a Local Destinatio"
           "n Landmark is specified, teleported entities are offset from the t"
           "arget by their initial offset from the landmark, and their angles "
           "are left alone."
        }
        trigger_transition:b =
        {
          t_triggerpoly=!
          ;desc = "A volume that's used to control which entities go through t"
           "he level transition. Create one or more trigger_transitions and gi"
           "ve them the same name as the changelevel landmark. Any entities wi"
           "thin the trigger_transition(s) will go to the next map.See trigger"
           "_changelevel for more info."
        }
        trigger_wind:b =
        {
          t_triggerpoly=!
          ;desc = "A trigger volume that pushes physics objects that touch it."
          Speed = "200"
          SpeedNoise = "0"
          DirectionNoise = "10"
          HoldTime = "0"
          HoldNoise = "0"
        }
      }
    }
  }
  Entity Forms.fctx =
  {
    t_Angles:incl =
    {
      angles: =
      {
        txt = "&"
        hint = "Pitch Yaw Roll (Y Z X)"
      }
    }
    t_Origin:incl =
    {
      origin: =
      {
        txt = "&"
        hint = "Origin (X Y Z)"
      }
    }
    t_Studiomodel:incl =
    {
     t_modelselect = !
      skin: =
      {
        txt = "&"
        hint = "Skin"
      }
      disableshadows: =
      {
        txt = "&"
        hint = "Disable Shadows"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#Skin: =
      {
        txt = "&"
        hint = "Changes the model skin to the specified number."
      }
      input#DisableShadow: =
      {
        txt = "&"
        hint = "Turn shadow off."
      }
      input#EnableShadow: =
      {
        txt = "&"
        hint = "Turn shadow on."
      }
      output#OnIgnite: =
      {
        txt = "&"
        hint = "Fired when this object catches fire."
      }
    }
    t_BasePlat:incl =
    {
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggles the platform's state."
      }
      input#GoUp: =
      {
        txt = "&"
        hint = "Tells the platform to go up."
      }
      input#GoDown: =
      {
        txt = "&"
        hint = "Tells the platform to go down."
      }
    }
    t_Targetname:incl =
    {
      targetname: =
      {
        txt = "&"
        hint = "Name"
      }
      input#Kill: =
      {
        txt = "&"
        hint = "Removes this entity from the world."
      }
      input#KillHierarchy: =
      {
        txt = "&"
        hint = "Removes this entity and all its children from the world."
      }
      input#AddOutput: =
      {
        txt = "&"
        hint = "Adds an entity I/O connection to this entity. Format: <output "
         "name> <targetname>:<inputname>:<parameter>:<delay>:<max times to fir"
         "e (-1 == infinite)>. Very dangerous, use with care."
      }
      input#FireUser1: =
      {
        txt = "&"
        hint = "Causes this entity's OnUser1 output to be fired."
      }
      input#FireUser2: =
      {
        txt = "&"
        hint = "Causes this entity's OnUser2 output to be fired."
      }
      input#FireUser3: =
      {
        txt = "&"
        hint = "Causes this entity's OnUser3 output to be fired."
      }
      input#FireUser4: =
      {
        txt = "&"
        hint = "Causes this entity's OnUser4 output to be fired."
      }
      output#OnUser1: =
      {
        txt = "&"
        hint = "Fired in response to FireUser1 input."
      }
      output#OnUser2: =
      {
        txt = "&"
        hint = "Fired in response to FireUser2 input."
      }
      output#OnUser3: =
      {
        txt = "&"
        hint = "Fired in response to FireUser3 input."
      }
      output#OnUser4: =
      {
        txt = "&"
        hint = "Fired in response to FireUser4 input."
      }
    }
    t_Parentname:incl =
    {
      parentname: =
      {
        txt = "&"
        hint = "Parent"
      }
      input#SetParent: =
      {
        txt = "&"
        hint = "Changes the entity's parent in the movement hierarchy."
      }
      input#SetParentAttachment: =
      {
        txt = "&"
        hint = "Change this entity to attach to a specific attachment point on"
         " its parent. Entities must be parented before being sent this input."
         " The parameter passed in should be the name of the attachment."
      }
      input#ClearParent: =
      {
        txt = "&"
        hint = "Removes this entity from the the movement hierarchy, leaving i"
         "t free to move independently."
      }
    }
    t_BaseBrush:incl =
    {
      input#SetTextureIndex: =
      {
        txt = "&"
        hint = "Used by HL1Port. Sets the brush texture index. Use a material_"
         "modify_control entity instead."
      }
      input#IncrementTextureIndex: =
      {
        txt = "&"
        hint = "Used by HL1Port. Increments the brush texture index. Use a mat"
         "erial_modify_control entity instead."
      }
    }
    t_EnableDisable:incl =
    {
      StartDisabled: =
      {
        txt = "&"
        hint = "Start Disabled"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable this entity."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable this entity."
      }
    }
    t_RenderFxChoices:incl =
    {
      renderfx: =
      {
        txt = "&"
        hint = "Render FX"
        typ = "C"
        items = "Normal"$0D"Slow Pulse"$0D"Fast Pulse"$0D"Slow Wide Pulse"$0D"F"
         "ast Wide Pulse"$0D"Slow Strobe"$0D"Fast Strobe"$0D"Faster Strobe"$0D
         "Slow Flicker"$0D"Fast Flicker"$0D"Slow Fade Away"$0D"Fast Fade Away"$0D
         "Slow Become Solid"$0D"Fast Become Solid"$0D"Constant Glow"$0D"Distor"
         "t"$0D"Hologram (Distort + fade)"$0D"Cull By Distance (TEST)"$0D"Spot"
         "light FX"$0D"Fade Near"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"9"$0D"10"$0D"11"$0D"12"$0D"13"$0D
         "5"$0D"6"$0D"7"$0D"8"$0D"14"$0D"15"$0D"16"$0D"23"$0D"24"$0D"26"
      }
    }
    t_Shadow:incl =
    {
      disableshadows: =
      {
        txt = "&"
        hint = "Disable shadows"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#DisableShadow: =
      {
        txt = "&"
        hint = "Turn shadow off."
      }
      input#EnableShadow: =
      {
        txt = "&"
        hint = "Turn shadow on."
      }
    }
    t_RenderFields:incl =
    {
      t_RenderFxChoices = !
      rendermode: =
      {
        txt = "&"
        hint = "Render Mode"
        typ = "C"
        items = "Normal"$0D"Color"$0D"Texture"$0D"Glow"$0D"Solid"$0D"Additive"$0D
         "Additive Fractional Frame"$0D"World Space Glow"$0D"Dont Render"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"7"$0D"9"$0D"10"
      }
      renderamt: =
      {
        txt = "&"
        hint = "FX Amount (0 - 255)"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "FX Color (R G B)"
      }
      rendercolor: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "FX Color (R G B)"
      }
      disablereceiveshadows: =
      {
        txt = "&"
        hint = "Disable Receiving Shadows"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
    }
    t_DXLevelChoice:incl =
    {
      mindxlevel: =
      {
        txt = "&"
        hint = "Minimum DX Level"
        typ = "C"
        items = "default (lowest)"$0D"dx7"
        values = "0"$0D"70"
      }
      maxdxlevel: =
      {
        txt = "&"
        hint = "Maximum DX Level"
        typ = "C"
        items = "default (highest)"$0D"dx6"
        values = "0"$0D"60"
      }
    }
    t_Inputfilter:incl =
    {
      InputFilter: =
      {
        txt = "&"
        hint = "Input Filter"
        typ = "C"
        items = "Allow all inputs"$0D"Ignore Touch/Untouch"$0D"Ignore Use"$0D"I"
         "gnore All"
        values = "0"$0D"8"$0D"16"$0D"32"
      }
    }
    t_Global:incl =
    {
      globalname: =
      {
        txt = "&"
        hint = "Global Entity Name"
      }
    }
    t_EnvGlobal:incl =
    {
      t_Targetname = !
      initialstate: =
      {
        txt = "&"
        hint = "Initial State"
        typ = "C"
        items = "Off"$0D"On"$0D"Dead"
        values = "0"$0D"1"$0D"2"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Set Initial State"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Set state of global to ON."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Set state of global to OFF."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggles state of global between ON and OFF."
      }
      input#Remove: =
      {
        txt = "&"
        hint = "Set state of global to DEAD."
      }
    }
    t_DamageFilter:incl =
    {
      damagefilter: =
      {
        txt = "&"
        hint = "Damage Filter"
      }
      input#SetDamageFilter: =
      {
        txt = "&"
        hint = "Sets the entity to use as damage filter. Pass in an empty stri"
         "ng to clear the damage filter."
      }
    }
    t_ResponseContext:incl =
    {
      input#AddContext: =
      {
        txt = "&"
        hint = "Adds a context to this entity's list of response contexts. The"
         " format should be 'key:value'."
      }
      input#RemoveContext: =
      {
        txt = "&"
        hint = "Remove a context from this entity's list of response contexts."
         " The name should match the 'key' of a previously added context."
      }
      input#ClearContext: =
      {
        txt = "&"
        hint = "Removes all contexts in this entity's list of response context"
         "s."
      }
      ResponseContext: =
      {
        txt = "&"
        hint = "Response Contexts"
      }
    }
    t_Breakable:incl =
    {
      t_Targetname = !
      t_DamageFilter = !
      t_Shadow = !
      ExplodeDamage: =
      {
        txt = "&"
        hint = "Explosion Damage"
      }
      ExplodeRadius: =
      {
        txt = "&"
        hint = "Explosion Radius"
      }
      PerformanceMode: =
      {
        txt = "&"
        hint = "Performance Mode"
        typ = "C"
        items = "Normal"$0D"Limit Gibs"$0D"Full Gibs on All Platforms"
        values = "0"$0D"1"$0D"2"
      }
      input#Break: =
      {
        txt = "&"
        hint = "Breaks the breakable."
      }
      input#SetHealth: =
      {
        txt = "&"
        hint = "Sets a new value for the breakable's health. If the breakable'"
         "s health reaches zero it will break."
      }
      input#AddHealth: =
      {
        txt = "&"
        hint = "Adds health to the breakable. If the breakable's health reache"
         "s zero it will break."
      }
      input#RemoveHealth: =
      {
        txt = "&"
        hint = "Removes health from the breakable. If the breakable's health r"
         "eaches zero it will break."
      }
      input#EnablePhyscannonPickup: =
      {
        txt = "&"
        hint = "Makes the breakable able to picked up by the physcannon."
      }
      input#DisablePhyscannonPickup: =
      {
        txt = "&"
        hint = "Makes the breakable not able to picked up by the physcannon."
      }
      output#OnBreak: =
      {
        txt = "&"
        hint = "Fired when this breakable breaks."
      }
      output#OnHealthChanged: =
      {
        txt = "&"
        hint = "Fired when the health of this breakable changes, passing the n"
         "ew value of health as a percentage of max health, from [0..1]."
      }
      output#OnPhysCannonDetach: =
      {
        txt = "&"
        hint = "Fired when the physcannon has ripped this breakable off of the"
         " wall. Only fired if ACT_PHYSCANNON_DETACH is defined in the model t"
         "his breakable is using."
      }
    }
    t_BreakableBrush:incl =
    {
      t_Breakable = !
      t_Parentname = !
      t_Global = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Only Break on Trigger"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Break on Touch"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Break on Pressure"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Break immediately on Physics"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1024"
        cap = "Don't take physics damage"
      }
      propdata: =
      {
        txt = "&"
        hint = "Prop Data"
        typ = "C"
        items = "None"$0D"Wooden.Tiny"$0D"Wooden.Small"$0D"Wooden.Medium"$0D"W"
         "ooden.Large"$0D"Wooden.Huge"$0D"Metal.Small"$0D"Metal.Medium"$0D"Met"
         "al.Large"$0D"Cardboard.Small"$0D"Cardboard.Medium"$0D"Cardboard.Larg"
         "e"$0D"Stone.Small"$0D"Stone.Medium"$0D"Stone.Large"$0D"Stone.Huge"$0D
         "Glass.Small"$0D"Plastic.Small"$0D"Plastic.Medium"$0D"Plastic.Large"$0D
         "Pottery.Small"$0D"Pottery.Medium"$0D"Pottery.Large"$0D"Pottery.Huge"$0D
         "Glass.Window"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"$0D"9"$0D"1"
         "0"$0D"11"$0D"12"$0D"13"$0D"14"$0D"15"$0D"16"$0D"17"$0D"18"$0D"19"$0D
         "20"$0D"21"$0D"22"$0D"23"$0D"24"
      }
      health: =
      {
        txt = "&"
        hint = "Strength"
      }
      material: =
      {
        txt = "&"
        hint = "Material Type"
        typ = "C"
        items = "Glass"$0D"Wood"$0D"Metal"$0D"Flesh"$0D"CinderBlock"$0D"Ceilin"
         "g Tile"$0D"Computer"$0D"Unbreakable Glass"$0D"Rocks"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"
      }
      explosion: =
      {
        txt = "&"
        hint = "Gibs Direction"
        typ = "C"
        items = "Random"$0D"Relative to Attack"$0D"Use Precise Gib Dir"
        values = "0"$0D"1"$0D"2"
      }
      gibdir: =
      {
        txt = "&"
        hint = "Precise Gib Direction"
      }
      nodamageforces: =
      {
        txt = "&"
        hint = "Damaging it Doesn't Push It"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#EnableDamageForces: =
      {
        txt = "&"
        hint = "Damaging the entity applies physics forces to it."
      }
      input#DisableDamageForces: =
      {
        txt = "&"
        hint = "Damaging the entity does *not* apply physics forces to it."
      }
      gibmodel: =
      {
        txt = "&"
        hint = "Gib Model"
      }
      spawnobject: =
      {
        txt = "&"
        hint = "Spawn On Break"
        typ = "C"
        items = "item_battery"$0D"item_healthkit"$0D"item_ammo_pistol"$0D"item"
         "_ammo_pistol_large"$0D"item_ammo_smg1"$0D"item_ammo_smg1_large"$0D"i"
         "tem_ammo_ar2"$0D"item_ammo_ar2_large"$0D"item_box_buckshot"$0D"item_"
         "flare_round"$0D"item_box_flare_rounds"$0D"item_ml_grenade"$0D"item_s"
         "mg1_grenade"$0D"item_box_sniper_rounds"$0D"unused1"$0D"weapon_stunst"
         "ick"$0D"weapon_ar1"$0D"weapon_ar2"$0D"unused2"$0D"weapon_ml"$0D"weap"
         "on_smg1"$0D"weapon_smg2"$0D"weapon_slam"$0D"weapon_shotgun"$0D"weapo"
         "n_molotov"$0D"item_dynamic_resupply"
        values = "1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"$0D"9"$0D"10"$0D
         "11"$0D"12"$0D"13"$0D"14"$0D"15"$0D"16"$0D"17"$0D"18"$0D"19"$0D"20"$0D
         "21"$0D"22"$0D"23"$0D"24"$0D"25"$0D"26"
      }
      explodemagnitude: =
      {
        txt = "&"
        hint = "Explode Magnitude"
      }
      pressuredelay: =
      {
        txt = "&"
        hint = "Pressure Delay"
      }
    }
    t_BreakableProp:incl =
    {
      t_Breakable = !
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Break on Touch"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Break on Pressure"
      }
      pressuredelay: =
      {
        txt = "&"
        hint = "Pressure Delay"
      }
    }
    t_BaseNPC:incl =
    {
      t_Targetname = !
      t_Angles = !
      t_RenderFields = !
      t_DamageFilter = !
      t_ResponseContext = !
      t_Shadow = !
      target: =
      {
        txt = "&"
        hint = "Target Path Corner"
      }
      squadname: =
      {
        txt = "&"
        hint = "Squad Name"
      }
      hintgroup: =
      {
        txt = "&"
        hint = "Hint Group"
      }
      hintlimiting: =
      {
        txt = "&"
        hint = "Hint Limit Nav"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Wait Till Seen"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Gag (No IDLE sounds until angry)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Fall to ground (unchecked means *teleport* to ground)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Drop Healthkit"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Efficient - Don't acquire enemies or avoid obstacles"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Wait For Script"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Long Visibility/Shoot"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Fade Corpse"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1024"
        cap = "Think outside PVS"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2048"
        cap = "Template NPC (used by npc_maker, will not spawn)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4096"
        cap = "Do Alternate collision for this NPC (player avoidance)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8192"
        cap = "Don't drop weapons"
      }
      sleepstate: =
      {
        txt = "&"
        hint = "Sleep State"
        typ = "C"
        items = "None"$0D"Waiting for threat"$0D"Waiting for PVS"$0D"Waiting f"
         "or input"
        values = "0"$0D"1"$0D"2"$0D"3"
      }
      wakeradius: =
      {
        txt = "&"
        hint = "Wake Radius"
      }
      wakesquad: =
      {
        txt = "&"
        hint = "Wake Squad"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      physdamagescale: =
      {
        txt = "&"
        hint = "Physics Impact Damage Scale"
      }
      output#OnDamaged: =
      {
        txt = "&"
        hint = "Fired when this NPC takes damage."
      }
      output#OnDeath: =
      {
        txt = "&"
        hint = "Fired when this NPC is killed."
      }
      output#OnHalfHealth: =
      {
        txt = "&"
        hint = "Fired when this NPC reaches half of its maximum health."
      }
      output#OnHearWorld: =
      {
        txt = "&"
        hint = "Fired when this NPC hears a sound (other than combat or the pl"
         "ayer)."
      }
      output#OnHearPlayer: =
      {
        txt = "&"
        hint = "Fired when this NPC hears the player."
      }
      output#OnHearCombat: =
      {
        txt = "&"
        hint = "Fired when this NPC hears combat sounds."
      }
      output#OnFoundEnemy: =
      {
        txt = "&"
        hint = "Fired when this NPC establishes line of sight to its enemy (ou"
         "tputs entity)."
      }
      output#OnLostEnemyLOS: =
      {
        txt = "&"
        hint = "Fired when this NPC loses line of sight to its enemy."
      }
      output#OnLostEnemy: =
      {
        txt = "&"
        hint = "Fired when this NPC loses its enemy. Usually due to the enemy "
         "being killed/removed, or because this NPC has selected a newer, more"
         " dangerous enemy."
      }
      output#OnFoundPlayer: =
      {
        txt = "&"
        hint = "Fired when this NPC establishes line of sight to its enemy, an"
         "d that enemy is a player (outputs player entity)."
      }
      output#OnLostPlayerLOS: =
      {
        txt = "&"
        hint = "Fired when this NPC loses line of sight to its enemy, and that"
         " enemy is a player."
      }
      output#OnLostPlayer: =
      {
        txt = "&"
        hint = "Fired when this NPC loses its enemy, and that enemy was a play"
         "er. Usually due to the enemy being killed/removed, or because this N"
         "PC has selected a newer, more dangerous enemy."
      }
      output#OnDamagedByPlayer: =
      {
        txt = "&"
        hint = "Fired when this NPC is hurt by a player."
      }
      output#OnDamagedByPlayerSquad: =
      {
        txt = "&"
        hint = "Fired when this NPC is hurt by a player OR by one of the playe"
         "r's squadmates."
      }
      output#OnDenyCommanderUse: =
      {
        txt = "&"
        hint = "Fired when this NPC has refused to join the player's squad."
      }
      output#OnWake: =
      {
        txt = "&"
        hint = "Fired when this NPC comes out of a sleep state."
      }
      input#SetRelationship: =
      {
        txt = "&"
        hint = "Changes this entity's relationship with another entity or clas"
         "s. Format: <entityname/classname> <D_HT/D_FR/D_LI/D_NU> <priority>"
      }
      input#SetHealth: =
      {
        txt = "&"
        hint = "Set this NPC's health."
      }
      input#SetBodyGroup: =
      {
        txt = "&"
        hint = "HACK: Sets this NPC's body group (from 0 - n). You'd better kn"
         "ow what you are doing!"
      }
      input#physdamagescale: =
      {
        txt = "&"
        hint = "Sets the value that scales damage energy when this character i"
         "s hit by a physics object. NOTE: 0 means this feature is disabled fo"
         "r backwards compatibility."
      }
      input#Ignite: =
      {
        txt = "&"
        hint = "Ignite, burst into flames"
      }
      input#Break: =
      {
        txt = "&"
        hint = "Break, smash into pieces"
      }
      input#StartScripting: =
      {
        txt = "&"
        hint = "Enter scripting state. In this state, NPCs ignore a variety of"
         " stimulus that would make them break out of their scripts: They igno"
         "re danger sounds, ignore +USE, don't idle speak or respond to other "
         "NPC's idle speech, and so on."
      }
      input#StopScripting: =
      {
        txt = "&"
        hint = "Exit scripting state."
      }
      input#Assault: =
      {
        txt = "&"
        hint = "Start an assault. Parameter passed in should be the name of th"
         "e rally point."
      }
      input#SetSquad: =
      {
        txt = "&"
        hint = "Set the name of this NPC's squad. It will be removed from any "
         "existing squad automatically. Leaving the parameter blank will remov"
         "e the NPC from any existing squad."
      }
      input#Wake: =
      {
        txt = "&"
        hint = "Wakes up the NPC if it is sleeping."
      }
      input#ForgetEntity: =
      {
        txt = "&"
        hint = "Clears out the NPC's knowledge of a named entity."
      }
      input#GagEnable: =
      {
        txt = "&"
        hint = "Turn on the NPC Gag flag. NPC won't speak outside of choreogra"
         "phed scenes."
      }
      input#GagDisable: =
      {
        txt = "&"
        hint = "Turn off the NPC Gag flag."
      }
      input#IgnoreDangerSounds: =
      {
        txt = "&"
        hint = "Ignore danger sounds for the specified number of seconds."
      }
    }
    info_npc_spawn_destination:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      ReuseDelay: =
      {
        txt = "&"
        hint = "Reuse Delay"
      }
      RenameNPC: =
      {
        txt = "&"
        hint = "New NPC Name"
      }
      output#OnSpawnNPC: =
      {
        txt = "&"
        hint = "Fired when an NPC spawns at this destination."
      }
    }
    t_BaseNPCMaker:incl =
    {
      t_Targetname = !
      t_Angles = !
      t_EnableDisable = !
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Fade Corpse"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Infinite Children"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Do Not Drop"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Don't Spawn While Visible"
      }
      MaxNPCCount: =
      {
        txt = "&"
        hint = "Num. of NPCs"
      }
      SpawnFrequency: =
      {
        txt = "&"
        hint = "Frequency"
      }
      MaxLiveChildren: =
      {
        txt = "&"
        hint = "Max Live NPCs"
      }
      output#OnSpawnNPC: =
      {
        txt = "&"
        hint = "Fired when an NPC is spawned. The activator is the NPC, and th"
         "e string is the name of the NPC."
      }
      output#OnAllSpawned: =
      {
        txt = "&"
        hint = "Fired when the spawned is exhausted (all children have been sp"
         "awned)."
      }
      output#OnAllSpawnedDead: =
      {
        txt = "&"
        hint = "Fired when the spawner is exhausted (all children have been sp"
         "awned), and all spawned children have died."
      }
      input#Spawn: =
      {
        txt = "&"
        hint = "Spawns an NPC."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggles the spawner enabled/disabled state."
      }
      input#AddMaxChildren: =
      {
        txt = "&"
        hint = "Adds to the number of NPCs that can spawn before the spawner i"
         "s exhausted. If an exhausted spawner is given some children to spawn"
         ", it still wont begin spawning until it is re-enabled with the Enabl"
         "e input."
      }
      input#SetMaxChildren: =
      {
        txt = "&"
        hint = "Sets the number of NPCs that can spawn before the spawner is e"
         "xhausted. If an exhausted spawner is given some children to spawn, i"
         "t still won't begin spawning until it is re-enabled with the Enable "
         "input."
      }
      input#SetMaxLiveChildren: =
      {
        txt = "&"
        hint = "Sets the maximum number of NPCs that can be alive at any one t"
         "ime from this spawner."
      }
      input#SetSpawnFrequency: =
      {
        txt = "&"
        hint = "Sets how often (in seconds) a new NPC will be spawned."
      }
    }
    npc_template_maker:form =
    {
      t_BaseNPCMaker = !
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Always use radius spawn"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Don't preload template models"
      }
      TemplateName: =
      {
        txt = "&"
        hint = "Name of template NPC"
      }
      Radius: =
      {
        txt = "&"
        hint = "Radius"
      }
      DestinationGroup: =
      {
        txt = "&"
        hint = "Name of Destination Group"
      }
      CriterionVisibility: =
      {
        txt = "&"
        hint = "Dest. Criterion: Visible to player?"
        typ = "C"
        items = "Yes"$0D"No"$0D"Don't Care"
        values = "0"$0D"1"$0D"2"
      }
      CriterionDistance: =
      {
        txt = "&"
        hint = "Dest. Criterion: Distance to player?"
        typ = "C"
        items = "Nearest"$0D"Farthest"$0D"Don't Care"
        values = "0"$0D"1"$0D"2"
      }
      input#SpawnNPCInRadius: =
      {
        txt = "&"
        hint = "Spawn an NPC somewhere within the maker's radius."
      }
      input#SpawnNPCInLine: =
      {
        txt = "&"
        hint = "Spawn an NPC somewhere within a line behind the maker."
      }
      input#ChangeDestinationGroup: =
      {
        txt = "&"
        hint = "Switch to a different set of Destination entities."
      }
    }
    t_BaseHelicopter:incl =
    {
      t_BaseNPC = !
      InitialSpeed: =
      {
        txt = "&"
        hint = "Initial Speed"
      }
      target: =
      {
        txt = "&"
        hint = "Target path_track"
      }
      input#MoveTopSpeed: =
      {
        txt = "&"
        hint = "The helicopter will immediately move at top speed toward its c"
         "urrent goal, or in its current orientation if it's on top of its goa"
         "l."
      }
      input#ChangePathCorner: =
      {
        txt = "&"
        hint = "Tell the helicopter to move to a path corner on a new path."
      }
      input#SelfDestruct: =
      {
        txt = "&"
        hint = "Self Destruct."
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Activate. Use to wake up a helicopter that spawned with the 'A"
         "wait Input' spawnflag on."
      }
      input#SetTrack: =
      {
        txt = "&"
        hint = "Set a track for the helicopter to adhere to. The helicopter wi"
         "ll do nothing if he's on the same path, and will move to the closest"
         " point on the specified track if he's on a different path."
      }
      input#FlyToSpecificTrackViaPath: =
      {
        txt = "&"
        hint = "The helicopter will first fly to the closest point on the path"
         " if he's on a different path. Then he'll fly along the path to the s"
         "pecified track point."
      }
      input#StartPatrol: =
      {
        txt = "&"
        hint = "Start patrolling back and forth along the current track."
      }
      input#StopPatrol: =
      {
        txt = "&"
        hint = "Stop patrolling back and forth along the track. This will caus"
         "e the helicopter to come to rest at the track which he's currently f"
         "lying toward."
      }
      input#ChooseFarthestPathPoint: =
      {
        txt = "&"
        hint = "When tracking an enemy, choose the point on the path furthest "
         "from the enemy, but still in firing range."
      }
      input#ChooseNearestPathPoint: =
      {
        txt = "&"
        hint = "When tracking an enemy, choose the point on the path nearest f"
         "rom the enemy."
      }
      input#StartBreakableMovement: =
      {
        txt = "&"
        hint = "The helicopter is now allowed to disobey direct commands to go"
         " to particular points if he senses an enemy. He will move to the clo"
         "sest point (or farthest point, if ChooseFarthestPathPoint is used), "
         "on the path if he senses an enemy."
      }
      input#StopBreakableMovement: =
      {
        txt = "&"
        hint = "The helicopter can not disobey direct commands. He will contin"
         "ue to fly along his patrol path or to his specified target even if h"
         "e senses an enemy."
      }
      InitialSpeed: =
      {
        txt = "&"
        hint = "Initial Speed"
      }
      target: =
      {
        txt = "&"
        hint = "Target path_track"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "No Rotorwash"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Await Input"
      }
    }
    t_PlayerClass:incl =
    {
      t_player_size = !
    }
    t_Light:incl =
    {
      _light: =
      {
        txt = "&"
        hint = "Brightness"
      }
      _light: =
      {
        Txt = "&"
        Typ = "LU4"
        Hint = "light color (not the intensity, only the color)"
      }

      style: =
      {
        txt = "&"
        hint = "Appearance"
        typ = "C"
        items = "Normal"$0D"Fluorescent flicker"$0D"Slow, strong pulse"$0D"Slo"
         "w pulse, noblack"$0D"Gentle pulse"$0D"Flicker A"$0D"Flicker B"$0D"Ca"
         "ndle A"$0D"Candle B"$0D"Candle C"$0D"Fast strobe"$0D"Slow strobe"
        values = "0"$0D"10"$0D"2"$0D"11"$0D"5"$0D"1"$0D"6"$0D"3"$0D"7"$0D"8"$0D
         "4"$0D"9"
      }
      pattern: =
      {
        txt = "&"
        hint = "Custom Appearance"
      }
      _constant_attn: =
      {
        txt = "&"
        hint = "Constant"
      }
      _linear_attn: =
      {
        txt = "&"
        hint = "Linear"
      }
      _quadratic_attn: =
      {
        txt = "&"
        hint = "Quadratic"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn the light on."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "The the light off."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the light's current state."
      }
      input#SetPattern: =
      {
        txt = "&"
        hint = "Set a custom pattern of light brightness for this light. Patte"
         "rn format is a string of characters, where 'a' is total darkness, 'z"
         "' fully bright. i.e. 'aaggnnttzz' would be a steppy fade in from dar"
         "k to light."
      }
      input#FadeToPattern: =
      {
        txt = "&"
        hint = "Fades from first value in old pattern, to first value in the n"
         "ew given pattern. Pattern format is a string of characters, where 'a"
         "' is total darkness, 'z' fully bright. i.e. 'aaggnnttzz' would be a "
         "steppy fade in from dark to light."
      }
    }
    t_Node:incl =
    {
      nodeid: =
      {
        txt = "&"
        hint = "Node ID"
      }
    }
    t_HintNode:incl =
    {
      t_Node = !
      hinttype: =
      {
        txt = "&"
        hint = "Hint"
        typ = "C"
        items = "None"$0D"World: Window"$0D"World: Act Busy Hint"$0D"World: Vi"
         "sually Interesting"$0D"World: Visually Interesting (Don't aim at)"$0D
         "World: Inhibit Combine Mines within 15 feet"$0D"Crouch Cover Medium"$0D
         "Crouch Cover Low"$0D"Waste Scanner Spawn"$0D"Entrance / Exit Pinch"$0D
         "Enemy Disadvantage Point"$0D"Health Kit"$0D"Antlion: Burrow Point"$0D
         "Antlion: Thumper Flee Point"$0D"Headcrab: Burrow Point"$0D"Roller: P"
         "atrol Point"$0D"Roller: Cleanup Spot"$0D"Crow: Fly to point"$0D"Crow"
         ": Perch point"$0D"Follower: Wait point"$0D"Override jump permission"$0D
         "Player squad transition point"$0D"NPC exit point"$0D"Strider node"$0D
         "HL1 World: Machinery"$0D"HL1 World: Blinking Light"$0D"HL1 World: Hu"
         "man Blood"$0D"HL1 World: Alien Blood"
        values = "0"$0D"2"$0D"12"$0D"13"$0D"14"$0D"15"$0D"100"$0D"101"$0D"102"$0D
         "103"$0D"105"$0D"106"$0D"400"$0D"401"$0D"450"$0D"500"$0D"501"$0D"700"$0D
         "701"$0D"900"$0D"901"$0D"902"$0D"903"$0D"904"$0D"1000"$0D"1001"$0D"10"
         "02"$0D"1003"
      }
      hintactivity: =
      {
        txt = "&"
        hint = "Hint Activity"
      }
      nodeFOV: =
      {
        txt = "&"
        hint = "Node FOV"
        typ = "C"
        items = "180 Degrees"$0D"360 Degrees"
        values = "180"$0D"360"
      }
      StartHintDisabled: =
      {
        txt = "&"
        hint = "Start Hint Disabled"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      Group: =
      {
        txt = "&"
        hint = "Hint Group"
      }
      TargetNode: =
      {
        txt = "&"
        hint = "Target node"
      }
      IgnoreFacing: =
      {
        txt = "&"
        hint = "Ignore Facing"
        typ = "C"
        items = "No"$0D"Yes"$0D"Default"
        values = "0"$0D"1"$0D"2"
      }
      MinimumState: =
      {
        txt = "&"
        hint = "Minimum State"
        typ = "C"
        items = "Idle"$0D"Alert"$0D"Combat"
        values = "1"$0D"2"$0D"3"
      }
      MaximumState: =
      {
        txt = "&"
        hint = "Maximum State"
        typ = "C"
        items = "Idle"$0D"Alert"$0D"Combat"
        values = "1"$0D"2"$0D"3"
      }
      input#EnableHint: =
      {
        txt = "&"
        hint = "Enable hint."
      }
      input#DisableHint: =
      {
        txt = "&"
        hint = "Disable hint."
      }
    }
    t_TriggerOnce:incl =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_EnableDisable = !
      t_Global = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Clients"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "NPCs"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Pushables"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Physics Objects"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Only player ally NPCs"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Only clients in vehicles"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Everything"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Only clients *not* in vehicles"
      }
      filtername: =
      {
        txt = "&"
        hint = "Filter Name"
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggles this trigger between enabled and disabled states."
      }
      output#OnStartTouch: =
      {
        txt = "&"
        hint = "Fired when an entity starts touching this trigger. The touchin"
         "g entity must pass this trigger's filters to cause this output to fi"
         "re."
      }
    }
    t_Trigger:incl =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_EnableDisable = !
      t_TriggerOnce = !
      output#OnEndTouch: =
      {
        txt = "&"
        hint = "Fired when an entity stops touching this trigger. Only entitie"
         "s that passed this trigger's filters will cause this output to fire."
      }
      output#OnEndTouchAll: =
      {
        txt = "&"
        hint = "Fires when an entity stops touching this trigger, and no other"
         " entities are touching it. Only entities that passed this trigger's "
         "filters are considered."
      }
    }
    t_worldbase:incl =
    {
      message: =
      {
        txt = "&"
        hint = "Map Description / Title"
      }
      skyname: =
      {
        txt = "&"
        hint = "SkyBox Texture Name"
      }
      chaptertitle: =
      {
        txt = "&"
        hint = "Chapter Title Message"
      }
      startdark: =
      {
        txt = "&"
        hint = "Level Fade In"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      gametitle: =
      {
        txt = "&"
        hint = "Display Game Title"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      newunit: =
      {
        txt = "&"
        hint = "New Level Unit"
        typ = "C"
        items = "No, keep current"$0D"Yes, clear previous levels"
        values = "0"$0D"1"
      }
      maxoccludeearea: =
      {
        txt = "&"
        hint = "Max occludee area"
      }
      minoccluderarea: =
      {
        txt = "&"
        hint = "Min occluder area"
      }
      maxpropscreenwidth: =
      {
        txt = "&"
        hint = "Start Fade Pixels"
      }
      minpropscreenwidth: =
      {
        txt = "&"
        hint = "End Fade Pixels"
      }
    }
    worldspawn:form =
    {
      t_Targetname = !
      t_worldbase = !
      t_ResponseContext = !
    }
    ambient_generic:form =
    {
      t_Targetname = !
      t_gamesoundselect = !

//      message: =
//      {
//        txt = "&"
//        hint = "Sound Name"
//      }

      health: =
      {
        txt = "&"
        hint = "Volume"
      }
      preset: =
      {
        txt = "&"
        hint = "Dynamic Presets"
        typ = "C"
        items = "None"$0D"Huge Machine"$0D"Big Machine"$0D"Machine"$0D"Slow Fa"
         "de in"$0D"Fade in"$0D"Quick Fade in"$0D"Slow Pulse"$0D"Pulse"$0D"Qui"
         "ck pulse"$0D"Slow Oscillator"$0D"Oscillator"$0D"Quick Oscillator"$0D
         "Grunge pitch"$0D"Very low pitch"$0D"Low pitch"$0D"High pitch"$0D"Ver"
         "y high pitch"$0D"Screaming pitch"$0D"Oscillate spinup/down"$0D"Pulse"
         " spinup/down"$0D"Random pitch"$0D"Random pitch fast"$0D"Incremental "
         "Spinup"$0D"Alien"$0D"Bizzare"$0D"Planet X"$0D"Haunted"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"$0D"9"$0D"1"
         "0"$0D"11"$0D"12"$0D"13"$0D"14"$0D"15"$0D"16"$0D"17"$0D"18"$0D"19"$0D
         "20"$0D"21"$0D"22"$0D"23"$0D"24"$0D"25"$0D"26"$0D"27"
      }
      volstart: =
      {
        txt = "&"
        hint = "Start Volume"
      }
      fadein: =
      {
        txt = "&"
        hint = "Fade in time (0-100)"
      }
      fadeout: =
      {
        txt = "&"
        hint = "Fade out time (0-100)"
      }
      pitch: =
      {
        txt = "&"
        hint = "Pitch"
      }
      pitchstart: =
      {
        txt = "&"
        hint = "Start Pitch"
      }
      spinup: =
      {
        txt = "&"
        hint = "Spin up time (0-100)"
      }
      spindown: =
      {
        txt = "&"
        hint = "Spin down time (0-100)"
      }
      lfotype: =
      {
        txt = "&"
        hint = "LFO type 0)off 1)sqr 2)tri 3)rnd"
      }
      lforate: =
      {
        txt = "&"
        hint = "LFO rate (0-1000)"
      }
      lfomodpitch: =
      {
        txt = "&"
        hint = "LFO mod pitch (0-100)"
      }
      lfomodvol: =
      {
        txt = "&"
        hint = "LFO mod vol (0-100)"
      }
      cspinup: =
      {
        txt = "&"
        hint = "Incremental Spinup Count"
      }
      radius: =
      {
        txt = "&"
        hint = "Max Audible Distance"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Play everywhere"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Start Silent"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Is NOT Looped"
      }
      SourceEntityName: =
      {
        txt = "&"
        hint = "SourceEntityName"
      }
      input#Pitch: =
      {
        txt = "&"
        hint = "Sets the sound pitch, expressed as a range from 1 to 255, wher"
         "e 100 is the sound's default pitch."
      }
      input#PlaySound: =
      {
        txt = "&"
        hint = "Starts the sound."
      }
      input#StopSound: =
      {
        txt = "&"
        hint = "Stops the sound if it is playing."
      }
      input#ToggleSound: =
      {
        txt = "&"
        hint = "Toggles the sound between playing and stopping."
      }
      input#Volume: =
      {
        txt = "&"
        hint = "Sets the sound volume, expressed as a range from 0 to 10, wher"
         "e 10 is the loudest."
      }
    }
    func_lod:form =
    {
      t_Targetname = !
      DisappearDist: =
      {
        txt = "&"
        hint = "Disappear Distance"
      }
      Solid: =
      {
        txt = "&"
        hint = "Solid"
        typ = "C"
        items = "Solid"$0D"Nonsolid"
        values = "0"$0D"1"
      }
    }
    env_zoom:form =
    {
      t_Targetname = !
      Rate: =
      {
        txt = "&"
        hint = "Seconds to reach target"
      }
      FOV: =
      {
        txt = "&"
        hint = "Target FOV"
      }
      input#Zoom: =
      {
        txt = "&"
        hint = "Start controlling the player's FOV."
      }
      input#UnZoom: =
      {
        txt = "&"
        hint = "Stop controlling the player's FOV."
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Allow Suit Zoom"
      }
    }
    env_screenoverlay:form =
    {
      t_Targetname = !
      OverlayName1: =
      {
        txt = "&"
        hint = "Overlay Name 1"
      }
      OverlayTime1: =
      {
        txt = "&"
        hint = "Overlay Duration 1"
      }
      OverlayName2: =
      {
        txt = "&"
        hint = "Overlay Name 2"
      }
      OverlayTime2: =
      {
        txt = "&"
        hint = "Overlay Duration 2"
      }
      OverlayName3: =
      {
        txt = "&"
        hint = "Overlay Name 3"
      }
      OverlayTime3: =
      {
        txt = "&"
        hint = "Overlay Duration 3"
      }
      OverlayName4: =
      {
        txt = "&"
        hint = "Overlay Name 4"
      }
      OverlayTime4: =
      {
        txt = "&"
        hint = "Overlay Duration 4"
      }
      OverlayName5: =
      {
        txt = "&"
        hint = "Overlay Name 5"
      }
      OverlayTime5: =
      {
        txt = "&"
        hint = "Overlay Duration 5"
      }
      OverlayName6: =
      {
        txt = "&"
        hint = "Overlay Name 6"
      }
      OverlayTime6: =
      {
        txt = "&"
        hint = "Overlay Duration 6"
      }
      OverlayName7: =
      {
        txt = "&"
        hint = "Overlay Name 7"
      }
      OverlayTime7: =
      {
        txt = "&"
        hint = "Overlay Duration 7"
      }
      OverlayName8: =
      {
        txt = "&"
        hint = "Overlay Name 8"
      }
      OverlayTime8: =
      {
        txt = "&"
        hint = "Overlay Duration 8"
      }
      OverlayName9: =
      {
        txt = "&"
        hint = "Overlay Name 9"
      }
      OverlayTime9: =
      {
        txt = "&"
        hint = "Overlay Duration 9"
      }
      OverlayName10: =
      {
        txt = "&"
        hint = "Overlay Name 10"
      }
      OverlayTime10: =
      {
        txt = "&"
        hint = "Overlay Duration 10"
      }
      input#StartOverlays: =
      {
        txt = "&"
        hint = "Start displaying the first overlay."
      }
      input#StopOverlays: =
      {
        txt = "&"
        hint = "Stop displaying any overlays."
      }
      input#SwitchOverlay: =
      {
        txt = "&"
        hint = "Switch to displaying a specific overlay. Pass in the desired o"
         "verlay number in the parameter."
      }
    }
    env_texturetoggle:form =
    {
      t_Targetname = !
      target: =
      {
        txt = "&"
        hint = "Target Brush(es)."
      }
      input#IncrementTextureIndex: =
      {
        txt = "&"
        hint = "Increments target brush's current texture frame by one."
      }
      input#SetTextureIndex: =
      {
        txt = "&"
        hint = "Sets target brush's texture frame to the specified index."
      }
    }
    env_splash:form =
    {
      t_Targetname = !
      t_Angles = !
      scale: =
      {
        txt = "&"
        hint = "Scale of the splash"
      }
      input#Splash: =
      {
        txt = "&"
        hint = "Create a splash effect."
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Automatically find water surface (place entity above water)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Diminish with depth (diminished completely in 10 feet of water)"
      }
    }
    env_particlelight:form =
    {
      t_Parentname = !
      Color: =
      {
        txt = "&"
        hint = "Color"
      }
      Color: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Color"
      }
      Intensity: =
      {
        txt = "&"
        hint = "Intensity"
      }
      directional: =
      {
        txt = "&"
        hint = "Directional"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      PSName: =
      {
        txt = "&"
        hint = "Particle System Entity"
      }
    }
    env_sun:form =
    {
      t_Angles = !
      target: =
      {
        txt = "&"
        hint = "Viewer entity"
      }
      use_angles: =
      {
        txt = "&"
        hint = "UseAngles"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      pitch: =
      {
        txt = "&"
        hint = "Pitch"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Sun Color (R G B)"
      }
      rendercolor: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Sun Color (R G B)"
      }
      size: =
      {
        txt = "&"
        hint = "Size"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Enable sun rendering."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Disable sun rendering."
      }
      input#SetColor: =
      {
        txt = "&"
        hint = "Change the sun's color. Format: <Red 0-255> <Green 0-255> <Blu"
         "e 0-255>"
      }
    }
    game_ragdoll_manager:form =
    {
      t_Targetname = !
      MaxRagdollCount: =
      {
        txt = "&"
        hint = "Max Ragdoll Count"
      }
      input#SetMaxRagdollCount: =
      {
        txt = "&"
        hint = "Set the Max Ragdoll Count."
      }
    }
    env_lightglow:form =
    {
      t_Targetname = !
      t_Angles = !
      rendercolor: =
      {
        txt = "&"
        hint = "Color (R G B)"
      }
      rendercolor: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Color (R G B)"
      }
      VerticalGlowSize: =
      {
        txt = "&"
        hint = "Vertical Size"
      }
      HorizontalGlowSize: =
      {
        txt = "&"
        hint = "Horizontal Size"
      }
      MinDist: =
      {
        txt = "&"
        hint = "Minimum Distance"
      }
      MaxDist: =
      {
        txt = "&"
        hint = "Maximum Distance"
      }
      OuterMaxDist: =
      {
        txt = "&"
        hint = "Outer Maximum Distance"
      }
      GlowProxySize: =
      {
        txt = "&"
        hint = "Glow Proxy Geometry Size"
      }
      input#Color: =
      {
        txt = "&"
        hint = "Change the render color of the glow. Format: <Red 0-255> <Gree"
         "n 0-255> <Blue 0-255>"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Visible only from front"
      }
    }
    env_smokestack:form =
    {
      t_Parentname = !
      t_Angles = !
      targetname: =
      {
        txt = "&"
        hint = "Name"
      }
      InitialState: =
      {
        txt = "&"
        hint = "Initial State"
        typ = "C"
        items = "Off"$0D"On"
        values = "0"$0D"1"
      }
      BaseSpread: =
      {
        txt = "&"
        hint = "Spread at the base"
      }
      SpreadSpeed: =
      {
        txt = "&"
        hint = "Spread Speed"
      }
      Speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      StartSize: =
      {
        txt = "&"
        hint = "Particle start size"
      }
      EndSize: =
      {
        txt = "&"
        hint = "Particle end size"
      }
      Rate: =
      {
        txt = "&"
        hint = "Emission rate"
      }
      JetLength: =
      {
        txt = "&"
        hint = "Length of smoke trail"
      }
      WindAngle: =
      {
        txt = "&"
        hint = "Wind X/Y Angle"
      }
      WindSpeed: =
      {
        txt = "&"
        hint = "Wind Speed"
      }
      SmokeMaterial: =
      {
        txt = "&"
        hint = "Particle material"
      }
      twist: =
      {
        txt = "&"
        hint = "Twist"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Base Color (R G B)"
      }
      rendercolor: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Base Color (R G B)"
      }
      renderamt: =
      {
        txt = "&"
        hint = "Translucency"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn on the smokestack."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn off the smokestack."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggles the smokestack between on and off state."
      }
      input#JetLength: =
      {
        txt = "&"
        hint = "Set the length of the smoke trail."
      }
      input#Rate: =
      {
        txt = "&"
        hint = "Set the rate at which to emit smoke particles (particles per s"
         "econd)."
      }
      input#Speed: =
      {
        txt = "&"
        hint = "Set the speed at which the smoke particles move after they're "
         "spawned."
      }
      input#SpreadSpeed: =
      {
        txt = "&"
        hint = "Set the amount of random spread in the velocity of the smoke p"
         "articles after they're spawned."
      }
    }
    env_fade:form =
    {
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Fade From"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Modulate"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Stay Out"
      }
      duration: =
      {
        txt = "&"
        hint = "Duration (seconds)"
      }
      holdtime: =
      {
        txt = "&"
        hint = "Hold Fade (seconds)"
      }
      renderamt: =
      {
        txt = "&"
        hint = "Fade Alpha"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Fade Color (R G B)"
      }
      rendercolor: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Fade Color (R G B)"
      }
      input#Fade: =
      {
        txt = "&"
        hint = "Start the screen fade."
      }
      output#OnBeginFade: =
      {
        txt = "&"
        hint = "Fired when the fade has begun."
      }
    }
    env_player_surface_trigger:form =
    {
      t_Targetname = !
      gamematerial: =
      {
        txt = "&"
        hint = "Game Material to Watch"
        typ = "C"
        items = "None (player's in the air)"$0D"Concrete"$0D"Metal"$0D"Dirt"$0D
         "Vent"$0D"Grate"$0D"Tile"$0D"Slosh"$0D"Wood"$0D"Computer"$0D"Glass"$0D
         "Flesh"$0D"Clip"$0D"Foliage"$0D"Sand"
        values = "0"$0D"67"$0D"77"$0D"68"$0D"86"$0D"71"$0D"84"$0D"83"$0D"87"$0D
         "80"$0D"89"$0D"70"$0D"73"$0D"79"$0D"78"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Start watching the player's surface."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Stop watching the player's surface."
      }
      output#OnSurfaceChangedToTarget: =
      {
        txt = "&"
        hint = "Fired when the player moves onto the specified game material."
      }
      output#OnSurfaceChangedFromTarget: =
      {
        txt = "&"
        hint = "Fired when the player moves off the specified game material."
      }
    }
    env_tonemap_controller:form =
    {
      t_Targetname = !
      input#SetTonemapScale: =
      {
        txt = "&"
        hint = "Set the player's tonemap scale. It should be a value between 0"
         " and 2, where 0 is the eyes fully closed, 1 is use the unchanged aut"
         "oexposure (default), and 2 is the eye fully wide open."
      }
      input#BlendTonemapScale: =
      {
        txt = "&"
        hint = "Blend from the player's current tonemap scale to a new one. Th"
         "e parameter syntax is as follows: <target tonemap scale> <blend dura"
         "tion>. For example: '0.5 10' would blend from the current tonemap sc"
         "ale to 0.5 over a period of 10 seconds. Tonemap scale is a value bet"
         "ween 0 and 2, where 0 is the eyes fully closed, 1 is use the unchang"
         "ed autoexposure (default), and 2 is the eye fully wide open."
      }
    }
    func_useableladder:form =
    {
      t_Targetname = !
      t_Parentname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Fake Ladder"
      }
      point0: =
      {
        txt = "&"
        hint = "Start"
      }
      point1: =
      {
        txt = "&"
        hint = "End"
      }
      StartDisabled: =
      {
        txt = "&"
        hint = "Start Disabled"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable this ladder."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable this ladder."
      }
      output#OnPlayerGotOnLadder: =
      {
        txt = "&"
        hint = "Fired whenever a player gets on this ladder."
      }
      output#OnPlayerGotOffLadder: =
      {
        txt = "&"
        hint = "Fired whenever a player gets off this ladder."
      }
    }
    func_ladderendpoint:form =
    {
      bbox = '-16 -16 0 16 16 72'
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      target: =
      {
        txt = "&"
        hint = "Other"
      }
    }
    info_ladder_dismount:form =
    {
      bbox = '-16 -16 0 16 16 4'
      t_Parentname = !
      target: =
      {
        txt = "&"
        hint = "LadderName"
      }
    }
    func_areaportalwindow:form =
    {
      t_Targetname = !
      target: =
      {
        txt = "&"
        hint = "Rendered Window"
      }
      FadeStartDist: =
      {
        txt = "&"
        hint = "Fade Start Distance"
      }
      FadeDist: =
      {
        txt = "&"
        hint = "Fade End Distance"
      }
      TranslucencyLimit: =
      {
        txt = "&"
        hint = "Translucency limit"
      }
      BackgroundBModel: =
      {
        txt = "&"
        hint = "Foreground bmodel"
      }
    }

    func_wall:form =
    {
      t_Targetname = !
      t_RenderFields = !
      t_Global = !
      t_Shadow = !
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
    }

    t_func_wall:incl =
    {
      t_Targetname = !
      t_RenderFields = !
      t_Global = !
      t_Shadow = !
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
    }

    func_clip_vphysics:form =
    {
      t_Targetname = !
      filtername: =
      {
        txt = "&"
        hint = "Filter Name"
      }
    }

    func_brush:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_RenderFields = !
      t_Global = !
      t_Inputfilter = !
      t_EnableDisable = !
      t_Shadow = !
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Ignore player +USE"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      Solidity: =
      {
        txt = "&"
        hint = "Solidity"
        typ = "C"
        items = "Toggle"$0D"Never Solid"$0D"Always Solid"
        values = "0"$0D"1"$0D"2"
      }
      excludednpc: =
      {
        txt = "&"
        hint = "NPC class excluded from collisions"
      }
      solidbsp: =
      {
        txt = "&"
        hint = "Solid BSP"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
    }

    t_func_brush:incl =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_RenderFields = !
      t_Global = !
      t_Inputfilter = !
      t_EnableDisable = !
      t_Shadow = !
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Ignore player +USE"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      Solidity: =
      {
        txt = "&"
        hint = "Solidity"
        typ = "C"
        items = "Toggle"$0D"Never Solid"$0D"Always Solid"
        values = "0"$0D"1"$0D"2"
      }
      excludednpc: =
      {
        txt = "&"
        hint = "NPC class excluded from collisions"
      }
      solidbsp: =
      {
        txt = "&"
        hint = "Solid BSP"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
    }

    t_vgui_screen_base:incl =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      panelname: =
      {
        txt = "&"
        hint = "Panel Name"
      }
      overlaymaterial: =
      {
        txt = "&"
        hint = "Overlay Material"
      }
      width: =
      {
        txt = "&"
        hint = "Panel Width in World"
      }
      height: =
      {
        txt = "&"
        hint = "Panel Height in World"
      }
      input#SetActive: =
      {
        txt = "&"
        hint = "Make the vgui screen visible."
      }
      input#SetInactive: =
      {
        txt = "&"
        hint = "Make the vgui screen invisible."
      }
    }
    vgui_screen:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_vgui_screen_base = !
    }
    cycler:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      t_RenderFxChoices = !
      t_RenderFields = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Not Solid"
      }
      model: =
      {
        txt = "&"
        hint = "Model"
        typ = "B"
        Cap = "models..."
        form = "t_models_hl2_form:form"
      }
      skin: =
      {
        txt = "&"
        hint = "Skin"
      }
      sequence: =
      {
        txt = "&"
        hint = "Sequence"
      }
      input#SetSequence: =
      {
        txt = "&"
        hint = "Sets the cycler's sequence."
      }
      input#Alpha: =
      {
        txt = "&"
        hint = "Sets the cycler's alpha value."
      }
    }
    t_gibshooterbase:incl =
    {
      t_Targetname = !
      t_Parentname = !
      angles: =
      {
        txt = "&"
        hint = "Gib Direction (Pitch Yaw Roll)"
      }
      m_iGibs: =
      {
        txt = "&"
        hint = "Number of Gibs"
      }
      delay: =
      {
        txt = "&"
        hint = "Delay between shots"
      }
      gibangles: =
      {
        txt = "&"
        hint = "Gib Angles (Pitch Yaw Roll)"
      }
      m_flVelocity: =
      {
        txt = "&"
        hint = "Gib Velocity"
      }
      m_flVariance: =
      {
        txt = "&"
        hint = "Course Variance"
      }
      m_flGibLife: =
      {
        txt = "&"
        hint = "Gib Life"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Repeatable"
      }
      input#Shoot: =
      {
        txt = "&"
        hint = "Force the gibshooter to create and shoot a gib."
      }
    }
    env_beam:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      t_Parentname = !
      t_RenderFxChoices = !
      renderamt: =
      {
        txt = "&"
        hint = "Brightness (1 - 255)"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Beam Color (R G B)"
      }
      rendercolor: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Beam Color (R G B)"
      }
      Radius: =
      {
        txt = "&"
        hint = "Radius"
      }
      life: =
      {
        txt = "&"
        hint = "Life (seconds 0 = infinite)"
      }
      BoltWidth: =
      {
        txt = "&"
        hint = "Width of beam"
      }
      NoiseAmplitude: =
      {
        txt = "&"
        hint = "Amount of noise (0-255)"
      }
      texture: =
      {
        txt = "&"
        hint = "Sprite Name"
      }
      TextureScroll: =
      {
        txt = "&"
        hint = "Texture Scroll Rate (0-100)"
      }
      framerate: =
      {
        txt = "&"
        hint = "Frames per 10 seconds"
      }
      framestart: =
      {
        txt = "&"
        hint = "Starting Frame"
      }
      StrikeTime: =
      {
        txt = "&"
        hint = "Strike again time (secs)"
      }
      damage: =
      {
        txt = "&"
        hint = "Damage / second"
      }
      LightningStart: =
      {
        txt = "&"
        hint = "Start Entity"
      }
      LightningEnd: =
      {
        txt = "&"
        hint = "Ending Entity"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start On"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Toggle"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Random Strike"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Ring"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "StartSparks"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "EndSparks"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Decal End"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Shade Start"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Shade End"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Taper Out"
      }
      TouchType: =
      {
        txt = "&"
        hint = "Touch Type (tripwire)"
        typ = "C"
        items = "Not a tripwire"$0D"Player Only"$0D"NPC Only"$0D"Player or NPC"
         $0D"Player or NPC or Physprop"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"
      }
      filtername: =
      {
        txt = "&"
        hint = "Filter Name"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turns the beam on."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turns the beam off."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggles the beam between on and off."
      }
      input#StrikeOnce: =
      {
        txt = "&"
        hint = "Causes the beam to strike once. It will stay on for its set Li"
         "fe and then turn off (it will never turn off if Life is set to zero)"
         "."
      }
      input#Alpha: =
      {
        txt = "&"
        hint = "Sets the beam's alpha (0 - 255)."
      }
      input#Color: =
      {
        txt = "&"
        hint = "Sets the beam's render color (R G B)."
      }
      input#Amplitude: =
      {
        txt = "&"
        hint = "Set the amplitude of beam noise (0 - 255)."
      }
      input#ScrollSpeed: =
      {
        txt = "&"
        hint = "Set the scroll speed in units per second (0 - 100)."
      }
      input#Width: =
      {
        txt = "&"
        hint = "Set the width of the beam, in pixels."
      }
      output#OnTouchedByEntity: =
      {
        txt = "&"
        hint = "Fired when an entity touches the beam. Only fired if the entit"
         "y passes the 'Touch Type' choice."
      }
    }
    env_beverage:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      t_Parentname = !
      health: =
      {
        txt = "&"
        hint = "Capacity"
      }
      beveragetype: =
      {
        txt = "&"
        hint = "Beverage Type"
        typ = "C"
        items = "Coca-Cola"$0D"Sprite"$0D"Diet Coke"$0D"Orange"$0D"Surge"$0D"M"
         "oxie"$0D"Random"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Enable this dispenser."
      }
    }
    env_embers:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      particletype: =
      {
        txt = "&"
        hint = "Ember type"
        typ = "C"
        items = "Normal"$0D"Smooth Fade"$0D"Pulled"
        values = "0"$0D"1"$0D"2"
      }
      density: =
      {
        txt = "&"
        hint = "Density (particles per second)"
      }
      lifetime: =
      {
        txt = "&"
        hint = "Particle Lifetime (seconds)"
      }
      speed: =
      {
        txt = "&"
        hint = "Particle Speed (units per second)"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Ember Color (R G B)"
      }
      rendercolor: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Ember Color (R G B)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start On"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Toggle"
      }
    }
    env_funnel:form =
    {
      bbox = '-16 -16 -16 16 16 16'
      t_Targetname = !
      t_Parentname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Reverse"
      }
    }
    env_blood:form =
    {
      bbox = '-16 -16 -16 16 16 16'
      t_Targetname = !
      t_Parentname = !
      spraydir: =
      {
        txt = "&"
        hint = "Spray Direction (Pitch Yaw Roll)"
      }
      color: =
      {
        txt = "&"
        hint = "Blood Color"
        typ = "C"
        items = "Red (Human)"$0D"Yellow (Alien)"
        values = "0"$0D"1"
      }
      amount: =
      {
        txt = "&"
        hint = "Amount of blood (damage to simulate)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Random Direction"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Blood Stream"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "On Player"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Spray decals"
      }
      input#EmitBlood: =
      {
        txt = "&"
        hint = "Triggers the blood effect."
      }
    }
    env_bubbles:form =
    {
      t_Targetname = !
      t_Parentname = !
      density: =
      {
        txt = "&"
        hint = "Bubble density"
      }
      frequency: =
      {
        txt = "&"
        hint = "Bubble frequency"
      }
      current: =
      {
        txt = "&"
        hint = "Speed of Current"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start Off"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Activates the bubbles."
      }
      input#Deactivate: =
      {
        txt = "&"
        hint = "Deactivates the bubbles."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggles the bubbles on and off."
      }
      input#SetDensity: =
      {
        txt = "&"
        hint = "Sets the bubble density."
      }
      input#SetFrequency: =
      {
        txt = "&"
        hint = "Sets bubble emission rate in bubbles per second."
      }
      input#SetCurrent: =
      {
        txt = "&"
        hint = "Sets current speed in inches per second."
      }
    }
    env_explosion:form =
    {
      t_Targetname = !
      t_Parentname = !
      iMagnitude: =
      {
        txt = "&"
        hint = "Magnitude"
      }
      iRadiusOverride: =
      {
        txt = "&"
        hint = "Radius Override"
      }
      fireballsprite: =
      {
        txt = "&"
        hint = "Fireball Sprite"
      }
      rendermode: =
      {
        txt = "&"
        hint = "Render Mode"
        typ = "C"
        items = "Normal"$0D"Solid"$0D"Additive"
        values = "0"$0D"4"$0D"5"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Damage"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Repeatable"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "No Fireball"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "No Smoke"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "No Decal"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "No Sparks"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "No Sound"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Random Orientation"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "No Fireball Smoke"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "No particles"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1024"
        cap = "No DLights"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2048"
        cap = "Don't clamp Min"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4096"
        cap = "Don't clamp Max"
      }
      input#Explode: =
      {
        txt = "&"
        hint = "Triggers the explosion."
      }
    }
    env_smoketrail:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      t_Parentname = !
      opacity: =
      {
        txt = "&"
        hint = "Sprite Opacity"
      }
      spawnrate: =
      {
        txt = "&"
        hint = "Spawn Rate"
      }
      lifetime: =
      {
        txt = "&"
        hint = "Particle Life Time"
      }
      startcolor: =
      {
        txt = "&"
        hint = "Start Color"
      }
      startcolor: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Start Color"
      }
      endcolor: =
      {
        txt = "&"
        hint = "End Color"
      }
      endcolor: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "End Color"
      }
      emittime: =
      {
        txt = "&"
        hint = "Emitter Life Time"
      }
      minspeed: =
      {
        txt = "&"
        hint = "Minimum Random Speed"
      }
      maxspeed: =
      {
        txt = "&"
        hint = "Maximum Random Speed"
      }
      mindirectedspeed: =
      {
        txt = "&"
        hint = "Minimum Directed Speed"
      }
      maxdirectedspeed: =
      {
        txt = "&"
        hint = "Maximum Directed Speed"
      }
      startsize: =
      {
        txt = "&"
        hint = "Starting particle size"
      }
      endsize: =
      {
        txt = "&"
        hint = "Ending particle size"
      }
      spawnradius: =
      {
        txt = "&"
        hint = "Spawn radius"
      }
      firesprite: =
      {
        txt = "&"
        hint = "Fire Sprite"
      }
      smokesprite: =
      {
        txt = "&"
        hint = "Smoke Puff"
      }
    }
    env_physexplosion:form =
    {
      t_Targetname = !
      t_Parentname = !
      magnitude: =
      {
        txt = "&"
        hint = "Magnitude"
      }
      radius: =
      {
        txt = "&"
        hint = "Clamp Radius (0 = auto)"
      }
      targetentityname: =
      {
        txt = "&"
        hint = "Limit to Entity"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Damage - Only Force"
      }
      input#Explode: =
      {
        txt = "&"
        hint = "Trigger the explosion."
      }
    }
    env_physimpact:form =
    {
      t_Targetname = !
      t_Parentname = !
      angles: =
      {
        txt = "&"
        hint = "Pitch Yaw Roll (Y Z X)"
      }
      magnitude: =
      {
        txt = "&"
        hint = "Magnitude"
      }
      distance: =
      {
        txt = "&"
        hint = "Distance"
      }
      directionentityname: =
      {
        txt = "&"
        hint = "Point to Entity"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No fall-off"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Infinite Length"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Ignore Mass"
      }
      input#Impact: =
      {
        txt = "&"
        hint = "Trigger the impact"
      }
    }
    env_fire:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_EnableDisable = !
      health: =
      {
        txt = "&"
        hint = "Duration"
      }
      firesize: =
      {
        txt = "&"
        hint = "Size"
      }
      fireattack: =
      {
        txt = "&"
        hint = "Attack"
      }
      firetype: =
      {
        txt = "&"
        hint = "Type"
        typ = "C"
        items = "Natural"$0D"Plasma"
        values = "0"$0D"1"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Infinite Duration"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Smokeless"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Start On"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Start Full"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Don't drop"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "No glow"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Delete when out"
      }
      ignitionpoint: =
      {
        txt = "&"
        hint = "Ignition Point"
      }
      damagescale: =
      {
        txt = "&"
        hint = "Damage Scale"
      }
      input#StartFire: =
      {
        txt = "&"
        hint = "Start the fire."
      }
      input#Extinguish: =
      {
        txt = "&"
        hint = "Puts out the fire permanently in the number of seconds specifi"
         "ed."
      }
      input#ExtinguishTemporary: =
      {
        txt = "&"
        hint = "Puts out the fire temporarily in the number of seconds specifi"
         "ed."
      }
      output#OnIgnited: =
      {
        txt = "&"
        hint = "Fires when the fire is first ignited."
      }
      output#OnExtinguished: =
      {
        txt = "&"
        hint = "Fires when the fire is fully extinguished."
      }
    }
    env_firesource:form =
    {
      t_Targetname = !
      t_Parentname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start On"
      }
      fireradius: =
      {
        txt = "&"
        hint = "Radius"
      }
      firedamage: =
      {
        txt = "&"
        hint = "Intensity / Damage"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable fire source."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable fire source."
      }
    }
    env_firesensor:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      t_Parentname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start On"
      }
      fireradius: =
      {
        txt = "&"
        hint = "Radius"
      }
      heatlevel: =
      {
        txt = "&"
        hint = "Heat level"
      }
      heattime: =
      {
        txt = "&"
        hint = "Time at level"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable fire sensor."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable fire sensor."
      }
      output#OnHeatLevelStart: =
      {
        txt = "&"
        hint = "Fires when the heat level has been sustained for the specified"
         " length of time."
      }
      output#OnHeatLevelEnd: =
      {
        txt = "&"
        hint = "Fires when the heat level drops below the target level."
      }
    }
    env_entity_igniter:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      target: =
      {
        txt = "&"
        hint = "Entity to ignite"
      }
      lifetime: =
      {
        txt = "&"
        hint = "Lifetime in seconds"
      }
      input#Ignite: =
      {
        txt = "&"
        hint = "Ignite the target entity."
      }
    }
    env_fog_controller:form =
    {
      t_Targetname = !
      t_DXLevelChoice = !
      t_Angles = !
      input#SetStartDist: =
      {
        txt = "&"
        hint = "Set the fog start distance."
      }
      input#SetEndDist: =
      {
        txt = "&"
        hint = "Set the fog end distance."
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn the fog on."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn the fog off."
      }
      input#SetColor: =
      {
        txt = "&"
        hint = "Set the primary fog color."
      }
      input#SetColorSecondary: =
      {
        txt = "&"
        hint = "Set the secondary fog color."
      }
      input#SetFarZ: =
      {
        txt = "&"
        hint = "Set the far clip plane distance."
      }
      input#SetAngles: =
      {
        txt = "&"
        hint = "Set the angles to use for the secondary fog direction."
      }
      fogenable: =
      {
        txt = "&"
        hint = "Fog Enable"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      fogblend: =
      {
        txt = "&"
        hint = "Fog Blend"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      use_angles: =
      {
        txt = "&"
        hint = "Use Angles for Fog Dir"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      fogcolor: =
      {
        txt = "&"
        hint = "Primary Fog Color"
      }
      fogcolor: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Primary Fog Color"
      }
      fogcolor2: =
      {
        txt = "&"
        hint = "Secondary Fog Color"
      }
      fogcolor2: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Secondary Fog Color"
      }
      fogdir: =
      {
        txt = "&"
        hint = "Primary Fog Direction"
      }
      fogstart: =
      {
        txt = "&"
        hint = "Fog Start"
      }
      fogend: =
      {
        txt = "&"
        hint = "Fog End"
      }
      farz: =
      {
        txt = "&"
        hint = "Far Z Clip Plane"
      }
    }
    env_steam:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Emissive"
      }
      InitialState: =
      {
        txt = "&"
        hint = "Initial State"
        typ = "C"
        items = "Off"$0D"On"
        values = "0"$0D"1"
      }
      type: =
      {
        txt = "&"
        hint = "Particle Type"
        typ = "C"
        items = "Normal"$0D"Heat Wave"
        values = "0"$0D"1"
      }
      SpreadSpeed: =
      {
        txt = "&"
        hint = "Spread Speed"
      }
      Speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      StartSize: =
      {
        txt = "&"
        hint = "Particle start size"
      }
      EndSize: =
      {
        txt = "&"
        hint = "Particle end size"
      }
      Rate: =
      {
        txt = "&"
        hint = "Emission rate"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Color (R G B)"
      }
      rendercolor: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Color (R G B)"
      }
      JetLength: =
      {
        txt = "&"
        hint = "Length of steam jet"
      }
      renderamt: =
      {
        txt = "&"
        hint = "Translucency"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turns the steam jet on."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turns the steam jet off."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggles the steam jet between on and off."
      }
      input#JetLength: =
      {
        txt = "&"
        hint = "Sets the length of steam jet."
      }
      input#Rate: =
      {
        txt = "&"
        hint = "Sets the particle emission rate in particles per second."
      }
      input#Speed: =
      {
        txt = "&"
        hint = "Sets the default speed of the particles in units per second."
      }
      input#SpreadSpeed: =
      {
        txt = "&"
        hint = "Sets the spread speed in units per second."
      }
    }
    env_laser:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      t_Parentname = !
      t_RenderFxChoices = !
      LaserTarget: =
      {
        txt = "&"
        hint = "Target of Laser"
      }
      renderamt: =
      {
        txt = "&"
        hint = "Brightness (1 - 255)"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Beam Color (R G B)"
      }
      rendercolor: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Beam Color (R G B)"
      }
      width: =
      {
        txt = "&"
        hint = "Width of Beam"
      }
      NoiseAmplitude: =
      {
        txt = "&"
        hint = "Amount of noise (0-255)"
      }
      texture: =
      {
        txt = "&"
        hint = "Sprite Name"
      }
      EndSprite: =
      {
        txt = "&"
        hint = "End Sprite"
      }
      TextureScroll: =
      {
        txt = "&"
        hint = "Texture Scroll Rate (0-100)"
      }
      framestart: =
      {
        txt = "&"
        hint = "Starting Frame"
      }
      damage: =
      {
        txt = "&"
        hint = "Damage / second"
      }
      dissolvetype: =
      {
        txt = "&"
        hint = "Dissolve Type"
        typ = "C"
        items = "None"$0D"Energy"$0D"Heavy electrical"$0D"Light electrical"
        values = "-1"$0D"0"$0D"1"$0D"2"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start On"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "StartSparks"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "EndSparks"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Decal End"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turns the laser on."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turns the laser off."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggles the laser between on and off."
      }
    }
    env_message:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      message: =
      {
        txt = "&"
        hint = "Message Text"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Play Once"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "All Clients"
      }
      messagesound: =
      {
        txt = "&"
        hint = "Sound Effect"
      }
      messagevolume: =
      {
        txt = "&"
        hint = "Volume 0-10"
      }
      messageattenuation: =
      {
        txt = "&"
        hint = "Sound Radius"
        typ = "C"
        items = "Small Radius"$0D"Medium Radius"$0D"Large  Radius"$0D"Play Eve"
         "rywhere"
        values = "0"$0D"1"$0D"2"$0D"3"
      }
      input#ShowMessage: =
      {
        txt = "&"
        hint = "Shows the message and plays the sound."
      }
      output#OnShowMessage: =
      {
        txt = "&"
        hint = "Fired when the message is activated."
      }
    }
    env_hudhint:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      message: =
      {
        txt = "&"
        hint = "Hint Text (localized)"
      }
      input#ShowHudHint: =
      {
        txt = "&"
        hint = "Shows the hint message."
      }
    }
    env_shake:form =
    {
      t_Targetname = !
      t_Parentname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "GlobalShake"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "In Air"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Physics"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Ropes"
      }
      amplitude: =
      {
        txt = "&"
        hint = "Amplitude (0-16)"
      }
      radius: =
      {
        txt = "&"
        hint = "Effect Radius"
      }
      duration: =
      {
        txt = "&"
        hint = "Duration (seconds)"
      }
      frequency: =
      {
        txt = "&"
        hint = "Frequency"
      }
      input#Amplitude: =
      {
        txt = "&"
        hint = "Set the amplitude (0-16)"
      }
      input#Frequency: =
      {
        txt = "&"
        hint = "Set the frequence. Should be a value between 0 and 255, where "
         "0.1 = jerk, and 255.0 = rumble."
      }
      input#StartShake: =
      {
        txt = "&"
        hint = "Start the shake."
      }
      input#StopShake: =
      {
        txt = "&"
        hint = "Stop the shake."
      }
    }
    gibshooter:form =
    {
      t_gibshooterbase = !
    }
    env_shooter:form =
    {
      t_gibshooterbase = !
      t_RenderFields = !
      shootmodel: =
      {
        txt = "&"
        hint = "Model"
        typ = "B"
        Cap = "models..."
        form = "t_models_hl2_form:form"
      }
      shootsounds: =
      {
        txt = "&"
        hint = "Material Sound"
        typ = "C"
        items = "None"$0D"Glass"$0D"Wood"$0D"Metal"$0D"Flesh"$0D"Concrete"
        values = "-1"$0D"0"$0D"1"$0D"2"$0D"3"$0D"4"
      }
      simulation: =
      {
        txt = "&"
        hint = "Simulate"
        typ = "C"
        items = "Point"$0D"Physics"$0D"Ragdoll"
        values = "0"$0D"1"$0D"2"
      }
      skin: =
      {
        txt = "&"
        hint = "Gib Skin"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "On fire"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "strict remove after lifetime"
      }
    }
    env_rotorshooter:form =
    {
      t_gibshooterbase = !
      t_RenderFields = !
      shootmodel: =
      {
        txt = "&"
        hint = "Model"
        typ = "B"
        Cap = "models..."
        form = "t_models_hl2_form:form"
      }
      shootsounds: =
      {
        txt = "&"
        hint = "Material Sound"
        typ = "C"
        items = "None"$0D"Glass"$0D"Wood"$0D"Metal"$0D"Flesh"$0D"Concrete"
        values = "-1"$0D"0"$0D"1"$0D"2"$0D"3"$0D"4"
      }
      simulation: =
      {
        txt = "&"
        hint = "Simulate"
        typ = "C"
        items = "Point"$0D"Physics"$0D"Ragdoll"
        values = "0"$0D"1"$0D"2"
      }
      skin: =
      {
        txt = "&"
        hint = "Gib Skin"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "On fire"
      }
      rotortime: =
      {
        txt = "&"
        hint = "Time Under Rotor"
      }
      rotortimevariance: =
      {
        txt = "&"
        hint = "Time variance"
      }
    }
    env_soundscape_proxy:form =
    {
      t_Targetname = !
      t_Parentname = !
      MainSoundscapeName: =
      {
        txt = "&"
        hint = "Soundscape Entity"
      }
      radius: =
      {
        txt = "&"
        hint = "Radius"
      }
    }

    env_soundscape:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_EnableDisable = !
      radius: =
      {
        txt = "&"
        hint = "Radius"
      }

// include external soundscape file

      t_soundscapeselect = !

// old dialog
//
//      soundscape: =
//      {
//        txt = "&"
//        hint = "Soundscape"
//        typ = "C"
//        items = "Nothing"$0D"Automatic"$0D"Automatic (dialog)"$0D"Indoor"$0D"O"
//         "utdoor"
//        values = "Nothing"$0D"Automatic"$0D"Automatic_Dialog"$0D"GenericIndoor"
//         $0D"GenericOutdoor"
//      }

      position0: =
      {
        txt = "&"
        hint = "Sound Position 0"
      }
      position1: =
      {
        txt = "&"
        hint = "Sound Position 1"
      }
      position2: =
      {
        txt = "&"
        hint = "Sound Position 2"
      }
      position3: =
      {
        txt = "&"
        hint = "Sound Position 3"
      }
      position4: =
      {
        txt = "&"
        hint = "Sound Position 4"
      }
      position5: =
      {
        txt = "&"
        hint = "Sound Position 5"
      }
      position6: =
      {
        txt = "&"
        hint = "Sound Position 6"
      }
      position7: =
      {
        txt = "&"
        hint = "Sound Position 7"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable the soundscape."
      }
      input#Disabled: =
      {
        txt = "&"
        hint = "Disable the soundscape."
      }
      input#ToggleEnabled: =
      {
        txt = "&"
        hint = "Toggle the soundscape enabled state."
      }
      output#OnPlay: =
      {
        txt = "&"
        hint = "Fired when this soundscape becomes the active one."
      }
    }

    t_env_soundscape:incl =
    {
      t_Targetname = !
      t_Parentname = !
      t_EnableDisable = !
      radius: =
      {
        txt = "&"
        hint = "Radius"
      }

// include external soundscape file

      t_soundscapeselect = !

// old dialog
//
//      soundscape: =
//      {
//        txt = "&"
//        hint = "Soundscape"
//        typ = "C"
//        items = "Nothing"$0D"Automatic"$0D"Automatic (dialog)"$0D"Indoor"$0D"O"
//         "utdoor"
//        values = "Nothing"$0D"Automatic"$0D"Automatic_Dialog"$0D"GenericIndoor"
//         $0D"GenericOutdoor"
//      }

      position0: =
      {
        txt = "&"
        hint = "Sound Position 0"
      }
      position1: =
      {
        txt = "&"
        hint = "Sound Position 1"
      }
      position2: =
      {
        txt = "&"
        hint = "Sound Position 2"
      }
      position3: =
      {
        txt = "&"
        hint = "Sound Position 3"
      }
      position4: =
      {
        txt = "&"
        hint = "Sound Position 4"
      }
      position5: =
      {
        txt = "&"
        hint = "Sound Position 5"
      }
      position6: =
      {
        txt = "&"
        hint = "Sound Position 6"
      }
      position7: =
      {
        txt = "&"
        hint = "Sound Position 7"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable the soundscape."
      }
      input#Disabled: =
      {
        txt = "&"
        hint = "Disable the soundscape."
      }
      input#ToggleEnabled: =
      {
        txt = "&"
        hint = "Toggle the soundscape enabled state."
      }
      output#OnPlay: =
      {
        txt = "&"
        hint = "Fired when this soundscape becomes the active one."
      }
    }

    env_soundscape_triggerable:form =
    {
      t_env_soundscape = !
    }
    env_spark:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      MaxDelay: =
      {
        txt = "&"
        hint = "Max Delay"
      }
      Magnitude: =
      {
        txt = "&"
        hint = "Magnitude"
        typ = "C"
        items = "Small"$0D"Medium"$0D"Large"$0D"Huge"
        values = "1"$0D"2"$0D"5"$0D"8"
      }
      TrailLength: =
      {
        txt = "&"
        hint = "Spark Trail Length"
        typ = "C"
        items = "Short"$0D"Medium"$0D"Long"
        values = "1"$0D"2"$0D"3"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Start ON"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Glow"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Silent"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Directional"
      }
      input#StartSpark: =
      {
        txt = "&"
        hint = "Start the spark effect."
      }
      input#StopSpark: =
      {
        txt = "&"
        hint = "Stop the spark effect."
      }
      input#ToggleSpark: =
      {
        txt = "&"
        hint = "Toggle the on/off state of the spark effect."
      }
      input#SparkOnce: =
      {
        txt = "&"
        hint = "Spark once."
      }
    }
    env_sprite:form =
    {
      bbox = '-2 -2 -2 2 2 2'
      t_Targetname = !
      t_Parentname = !
      t_RenderFields = !
      t_DXLevelChoice = !
      framerate: =
      {
        txt = "&"
        hint = "Framerate"
      }
      model: =
      {
        txt = "&"
        hint = "Sprite Name"
      }
      scale: =
      {
        txt = "&"
        hint = "Scale"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start on"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Play Once"
      }
      GlowProxySize: =
      {
        txt = "&"
        hint = "Size of Glow Proxy Geometry."
      }
      input#Alpha: =
      {
        txt = "&"
        hint = "Set the sprite's alpha (0 - 255)."
      }
      input#Color: =
      {
        txt = "&"
        hint = "Set the sprite's color (R G B)."
      }
      input#SetScale: =
      {
        txt = "&"
        hint = "Set the sprite's scale (0 - 8.0)."
      }
      input#HideSprite: =
      {
        txt = "&"
        hint = "Hide the sprite. Won't be drawn until the 'ShowSprite' input i"
         "s received."
      }
      input#ShowSprite: =
      {
        txt = "&"
        hint = "Show the sprite."
      }
      input#ToggleSprite: =
      {
        txt = "&"
        hint = "Toggle the sprite between hidden and shown."
      }
    }
    env_wind:form =
    {
      t_Targetname = !
      t_Angles = !
      gustsound: =
      {
        txt = "&"
        hint = "Gust Sound Filename"
      }
      minwind: =
      {
        txt = "&"
        hint = "Min normal speed"
      }
      maxwind: =
      {
        txt = "&"
        hint = "Max normal speed"
      }
      mingust: =
      {
        txt = "&"
        hint = "Min gust speed"
      }
      maxgust: =
      {
        txt = "&"
        hint = "Max gust speed"
      }
      mingustdelay: =
      {
        txt = "&"
        hint = "Min gust delay"
      }
      maxgustdelay: =
      {
        txt = "&"
        hint = "Max gust delay"
      }
      gustdirchange: =
      {
        txt = "&"
        hint = "Max gust dir change (degrees)"
      }
    }
    sky_camera:form =
    {
      bbox = '-16 -16 -16 16 16 16'
      t_Angles = !
      scale: =
      {
        txt = "&"
        hint = "3D Skybox scale"
      }
      fogenable: =
      {
        txt = "&"
        hint = "Fog Enable"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      fogblend: =
      {
        txt = "&"
        hint = "Fog Blend"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      use_angles: =
      {
        txt = "&"
        hint = "Use Angles for Fog Dir"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      fogcolor: =
      {
        txt = "&"
        hint = "Primary Fog Color"
      }
      _fogcolor: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Primary Fog Color"
      }
      fogcolor2: =
      {
        txt = "&"
        hint = "Secondary Fog Color"
      }
      _fogcolor2: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Secondary Fog Color"
      }
      fogdir: =
      {
        txt = "&"
        hint = "Primary Fog Dir"
      }
      fogstart: =
      {
        txt = "&"
        hint = "Fog Start"
      }
      fogend: =
      {
        txt = "&"
        hint = "Fog End"
      }
    }
    t_BaseSpeaker:incl =
    {
      t_Targetname = !
      t_ResponseContext = !
      delaymin: =
      {
        txt = "&"
        hint = "Min Delay Between Announcements"
      }
      delaymax: =
      {
        txt = "&"
        hint = "Max Delay Between Announcements"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start Silent"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Play Everywhere"
      }
      rulescript: =
      {
        txt = "&"
        hint = "Context rule script"
      }
      concept: =
      {
        txt = "&"
        hint = "Concept name"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn on the random announcements."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn off the random announcements."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the random announcements off and on."
      }
    }
    game_weapon_manager:form =
    {
      t_Targetname = !
      weaponname: =
      {
        txt = "&"
        hint = "Weapon Classname"
      }
      maxpieces: =
      {
        txt = "&"
        hint = "Max Allowed in Level"
      }
    }
    game_end:form =
    {
      t_Targetname = !
      master: =
      {
        txt = "&"
        hint = "Master (Obsolete)"
      }
      input#EndGame: =
      {
        txt = "&"
        hint = "End the multiplayer game."
      }
    }
    game_player_equip:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Use Only"
      }
      master: =
      {
        txt = "&"
        hint = "Team Master (Obsolete)"
      }
    }
    game_player_team:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Remove On fire"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Kill Player"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Gib Player"
      }
      target: =
      {
        txt = "&"
        hint = "game_team_master to use"
      }
      master: =
      {
        txt = "&"
        hint = "Master (Obsolete)"
      }
    }
    game_score:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Allow Negative"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Team Points"
      }
      points: =
      {
        txt = "&"
        hint = "Points to add (+/-)"
      }
      master: =
      {
        txt = "&"
        hint = "Master (Obsolete)"
      }
      input#ApplyScore: =
      {
        txt = "&"
        hint = "Add score to player."
      }
    }
    game_text:form =
    {
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "All Players"
      }
      message: =
      {
        txt = "&"
        hint = "Message Text"
      }
      x: =
      {
        txt = "&"
        hint = "X (0 - 1.0 = left to right) (-1 centers)"
      }
      y: =
      {
        txt = "&"
        hint = "Y (0 - 1.0 = top to bottom) (-1 centers)"
      }
      effect: =
      {
        txt = "&"
        hint = "Text Effect"
        typ = "C"
        items = "Fade In/Out"$0D"Credits"$0D"Scan Out"
        values = "0"$0D"1"$0D"2"
      }
      color: =
      {
        txt = "&"
        hint = "Color1"
      }
      color2: =
      {
        txt = "&"
        hint = "Color2"
      }
      fadein: =
      {
        txt = "&"
        hint = "Fade in Time (or character scan time)"
      }
      fadeout: =
      {
        txt = "&"
        hint = "Fade Out Time"
      }
      holdtime: =
      {
        txt = "&"
        hint = "Hold Time"
      }
      fxtime: =
      {
        txt = "&"
        hint = "Scan time (scan effect only)"
      }
      channel: =
      {
        txt = "&"
        hint = "Text Channel"
        typ = "C"
        items = "Channel 1"$0D"Channel 2"$0D"Channel 3"$0D"Channel 4"
        values = "1"$0D"2"$0D"3"$0D"4"
      }
      master: =
      {
        txt = "&"
        hint = "Master"
      }
      input#Display: =
      {
        txt = "&"
        hint = "Display the message text."
      }
    }
    point_enable_motion_fixup:form =
    {
      bbox = '-2 -2 -2 2 2 2'
      t_Parentname = !
      t_Angles = !
    }
    point_message:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      t_Parentname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start Disabled"
      }
      message: =
      {
        txt = "&"
        hint = "Entity Message"
      }
      radius: =
      {
        txt = "&"
        hint = "Show message radius"
      }
      developeronly: =
      {
        txt = "&"
        hint = "Developer Only?"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Start displaying the message text, if the player is within the"
         " message radius."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Stop displaying the message text."
      }
    }
    point_spotlight:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start On"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "No Dynamic Light"
      }
      spotlightlength: =
      {
        txt = "&"
        hint = "Spotlight Length"
      }
      spotlightwidth: =
      {
        txt = "&"
        hint = "Spotlight Width"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Color (R G B)"
      }
      rendercolor: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Color (R G B)"
      }
      input#LightOn: =
      {
        txt = "&"
        hint = "Turn the spotlight on."
      }
      input#LightOff: =
      {
        txt = "&"
        hint = "Turn the spotlight off"
      }
    }
    point_tesla:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      m_SourceEntityName: =
      {
        txt = "&"
        hint = "Source Entity"
      }
      m_SoundName: =
      {
        txt = "&"
        hint = "Sound Name"
      }
      texture: =
      {
        txt = "&"
        hint = "Sprite Name"
      }
      m_Color: =
      {
        txt = "&"
        hint = "Color"
      }
      m_Color: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Color"
      }
      m_flRadius: =
      {
        txt = "&"
        hint = "Radius"
      }
      beamcount_min: =
      {
        txt = "&"
        hint = "Min # of Beams"
      }
      beamcount_max: =
      {
        txt = "&"
        hint = "Max # of Beams"
      }
      thick_min: =
      {
        txt = "&"
        hint = "Min Beam Width"
      }
      thick_max: =
      {
        txt = "&"
        hint = "Max Beam Width"
      }
      lifetime_min: =
      {
        txt = "&"
        hint = "Min Time Visible"
      }
      lifetime_max: =
      {
        txt = "&"
        hint = "Max Time Visible"
      }
      interval_min: =
      {
        txt = "&"
        hint = "Min Time Between Arcs"
      }
      interval_max: =
      {
        txt = "&"
        hint = "Max Time Between Arcs"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn emitter on."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn emitter off."
      }
      input#DoSpark: =
      {
        txt = "&"
        hint = "Force a single arc."
      }
    }
    point_clientcommand:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      input#Command: =
      {
        txt = "&"
        hint = "Command to execute."
      }
    }
    point_servercommand:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      input#Command: =
      {
        txt = "&"
        hint = "Command to execute."
      }
    }
    game_ui:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Freeze Player"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Hide Weapon"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "+Use Deactivates"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Jump Deactivates"
      }
      FieldOfView: =
      {
        txt = "&"
        hint = "FieldOfView"
      }
      input#Deactivate: =
      {
        txt = "&"
        hint = "Return Player Control."
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Take Player Control."
      }
      output#PlayerOn: =
      {
        txt = "&"
        hint = "Fired whenever this entity starts controlling the player's inp"
         "ut."
      }
      output#PlayerOff: =
      {
        txt = "&"
        hint = "Fired whenever this entity stops controlling the player's inpu"
         "t."
      }
      output#PressedMoveLeft: =
      {
        txt = "&"
        hint = "Fired whenever the player presses the moveleft key."
      }
      output#PressedMoveRight: =
      {
        txt = "&"
        hint = "Fired whenever the player presses the moveright key."
      }
      output#PressedForward: =
      {
        txt = "&"
        hint = "Fired whenever the player presses the forward key."
      }
      output#PressedBack: =
      {
        txt = "&"
        hint = "Fired whenever the player presses the backward key."
      }
      output#PressedAttack: =
      {
        txt = "&"
        hint = "Fired whenever the player presses the attack key."
      }
      output#PressedAttack2: =
      {
        txt = "&"
        hint = "Fired whenever the player presses the secondary attack key."
      }
      output#XAxis: =
      {
        txt = "&"
        hint = "An output that fires whenever the X axis of the player's input"
         " changes. i.e. -1 when the player has moveleft key down, 1 when the "
         "player has moveright key down, and 0 if neither."
      }
      output#YAxis: =
      {
        txt = "&"
        hint = "An output that fires whenever the Y axis of the player's input"
         " changes. i.e. -1 when the player has backward key down, 1 when the "
         "player has forward key down, and 0 if neither."
      }
      output#AttackAxis: =
      {
        txt = "&"
        hint = "An output that fires whenever the state of the player's attack"
         " key changes. i.e. 1 when the player has the attack key down, 0 othe"
         "rwise."
      }
      output#Attack2Axis: =
      {
        txt = "&"
        hint = "An output that fires whenever the state of the player's second"
         "ary attack key changes. i.e. 1 when the player has the secondary att"
         "ack key down, 0 otherwise."
      }
    }
    game_zone_player:form =
    {
      t_Targetname = !
      t_Parentname = !
      input#CountPlayersInZone: =
      {
        txt = "&"
        hint = "Count the number of players in the zone, and fire the correspo"
         "nding outputs."
      }
      output#OnPlayerInZone: =
      {
        txt = "&"
        hint = "Fired whenever a count finds a player inside the zone, with th"
         "e player as the activator."
      }
      output#OnPlayerOutZone: =
      {
        txt = "&"
        hint = "Fired whenever a count finds a player outside the zone, with t"
         "he player as the activator."
      }
      output#PlayersInCount: =
      {
        txt = "&"
        hint = "Fired after a count, and contains the number of players found "
         "inside the zone."
      }
      output#PlayersOutCount: =
      {
        txt = "&"
        hint = "Fired after a count, and contains the number of players found "
         "outside the zone."
      }
    }
    infodecal:form =
    {
      t_Targetname = !
      texture: =
      {
        txt = "&"
        typ = "ET"
        Cap = "texture..."
      }
      LowPriority: =
      {
        txt = "&"
        hint = "Low Priority (can be replaced)"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Force the decal to apply itself to the world."
      }
    }
    info_projecteddecal:form =
    {
      t_Angles = !
      t_Targetname = !
      texture: =
      {
        txt = "&"
        typ = "ET"
        Cap = "texture..."
      }
      Distance: =
      {
        txt = "&"
        hint = "Distance"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Force the decal to apply itself to the world."
      }
    }
    info_no_dynamic_shadow:form =
    {
      sides: =
      {
        txt = "&"
        hint = "Brush faces"
      }
    }
    info_player_start:form =
    {
      t_PlayerClass = !
      t_Angles = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Master (Has priority if multiple info_player_starts exist)"
      }
    }
    info_overlay:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      material: =
      {
        txt = "&"
        hint = "Material"
        typ = "ET"
        Cap = "texture..."
      }
      sides: =
      {
        txt = "&"
        hint = "Brush faces"
      }
      RenderOrder: =
      {
        txt = "&"
        hint = "Render Order"
      }
      StartU: =
      {
        txt = "&"
        hint = "U Start"
      }
      EndU: =
      {
        txt = "&"
        hint = "U End"
      }
      StartV: =
      {
        txt = "&"
        hint = "V Start"
      }
      EndV: =
      {
        txt = "&"
        hint = "V End"
      }
      BasisOrigin: =
      {
        txt = "&"
        hint = "Overlay Basis Origin(Read-Only)"
      }
      BasisU: =
      {
        txt = "&"
        hint = "Overlay Basis U(Read-Only)"
      }
      BasisV: =
      {
        txt = "&"
        hint = "Overlay Basis V(Read-Only)"
      }
      BasisNormal: =
      {
        txt = "&"
        hint = "Overlay Basis Normal(Read-Only)"
      }
      uv0: =
      {
        txt = "&"
        hint = "Overlay Point 1(Read-Only)"
      }
      uv1: =
      {
        txt = "&"
        hint = "Overlay Point 2(Read-Only)"
      }
      uv2: =
      {
        txt = "&"
        hint = "Overlay Point 3(Read-Only)"
      }
      uv3: =
      {
        txt = "&"
        hint = "Overlay Point 4(Read-Only)"
      }
    }
    info_intermission:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      target: =
      {
        txt = "&"
        hint = "Entity to look at"
      }
    }
    info_landmark:form =
    {
      t_Targetname = !
    }
    info_null:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
    }
    info_target:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      input#DispatchEffect: =
      {
        txt = "&"
        hint = "Dispatch an effect from this point. Unfinished."
      }
    }
    phys_ragdollmagnet:form =
    {
      t_Targetname = !
      t_EnableDisable = !
      t_Parentname = !
      t_Angles = !
      axis: =
      {
        txt = "&"
        hint = "Bar Magnet Axis"
      }
      radius: =
      {
        txt = "&"
        hint = "Effective Radius"
      }
      force: =
      {
        txt = "&"
        hint = "Force"
      }
      target: =
      {
        txt = "&"
        hint = "Entity to affect"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Bar Magnet (use axis helper)"
      }
    }
    info_lighting:form =
    {
      t_Targetname = !
    }
    info_teleport_destination:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      t_PlayerClass = !
    }
    info_node:form =
    {
      t_Targetname = !
      t_Node = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Force human permission"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Force small_centered permission"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Force wide_human permission"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Force tiny permissiont"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Force wide_short permission"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Force medium permission"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Force tiny_centered permission"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Force large permission"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Force large_centered permission"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Keep editor position"
      }
    }
    info_node_hint:form =
    {
      t_Targetname = !
      t_Angles = !
      t_HintNode = !
      output#OnNPCStartedUsing: =
      {
        txt = "&"
        hint = "Fired when an NPC has reached this node and started using it. "
         "Passes along the NPC."
      }
      output#OnNPCStoppedUsing: =
      {
        txt = "&"
        hint = "Fired when an NPC has stopped using this node. Passes along th"
         "e NPC."
      }
    }
    info_node_air:form =
    {
      t_Targetname = !
      t_Node = !
      nodeheight: =
      {
        txt = "&"
        hint = "NodeHeight"
      }
    }
    info_node_air_hint:form =
    {
      t_Angles = !
      t_Targetname = !
      t_HintNode = !
      nodeheight: =
      {
        txt = "&"
        hint = "NodeHeight"
      }
    }
    info_hint:form =
    {
      t_Targetname = !
      t_Angles = !
      t_HintNode = !
    }
    info_node_link:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      StartNode: =
      {
        txt = "&"
        hint = "Start node ID"
      }
      EndNode: =
      {
        txt = "&"
        hint = "End node ID"
      }
      initialstate: =
      {
        txt = "&"
        hint = "Initial State"
        typ = "C"
        items = "Off"$0D"On"
        values = "0"$0D"1"
      }
      AllowUse: =
      {
        txt = "&"
        hint = "Allow Pass When Off"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Force human connect"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Force small_centered connect"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Force wide_human connect"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Force tiny connect"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Force wide_short connect"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Force medium connect"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Force tiny_centered connect"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Force large connect"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Force large_centered connect"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn the link on."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn the link off."
      }
    }
    info_node_link_controller:form =
    {
      t_Targetname = !
      mins: =
      {
        txt = "&"
        hint = "Mins"
      }
      maxs: =
      {
        txt = "&"
        hint = "Maxs"
      }
      initialstate: =
      {
        txt = "&"
        hint = "Initial State"
        typ = "C"
        items = "Off"$0D"On"
        values = "0"$0D"1"
      }
      AllowUse: =
      {
        txt = "&"
        hint = "Allow Pass When Off"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn the link on."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn the link off."
      }
    }
    info_node_climb:form =
    {
      t_Targetname = !
      t_Angles = !
      t_HintNode = !
    }
    light:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      t_Light = !
      target: =
      {
        txt = "&"
        hint = "Entity To Point At"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Initially dark"
      }
      _distance: =
      {
        txt = "&"
        hint = "Maximum Distance"
      }
      _lightHDR: =
      {
        txt = "&"
        hint = "use -1 -1 -1 1 as the argument"
      }
      _zero_percent_distance: =
      {
        txt = "&"
        hint = "use 0 as the argument"
      }
      _fifty_percent_distance: =
      {
        txt = "&"
        hint = "use 0 as the argument"
      }
    }
    light_environment:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Angles = !
      pitch: =
      {
        txt = "&"
        hint = "Pitch"
      }
      _light: =
      {
        txt = "&"
        hint = "Brightness"
      }
      _light: =
      {
        Txt = "&"
        Typ = "LU4"
        Hint = "light color (not the intensity, only the color)"
      }
      _ambient: =
      {
        txt = "&"
        hint = "Ambient"
      }
      _ambient: =
      {
        Txt = "&"
        Typ = "LU4"
        Hint = "light color (not the intensity, only the color)"
      }
      _ambientHDR: =
      {
        txt = "&"
        hint = "use -1 -1 -1 1 as the argument"
      }
      angles: =
      {
        txt = "&"
        hint = "Angle"
      }
      _lightHDR: =
      {
        txt = "&"
        hint = "use -1 -1 -1 1 as the argument"
      }
    }
    light_spot:form =
    {
      bbox = '-4 -4 -4 4 4 4
      '
      t_Targetname = !
      t_Angles = !
      t_Light = !
      target: =
      {
        txt = "&"
        hint = "Entity to point at"
      }
      _inner_cone: =
      {
        txt = "&"
        hint = "Inner (bright) angle"
      }
      _cone: =
      {
        txt = "&"
        hint = "Outer (fading) angle"
      }
      _exponent: =
      {
        txt = "&"
        hint = "Focus"
      }
      _distance: =
      {
        txt = "&"
        hint = "Maximum distance"
      }
      angles: =
      {
        txt = "&"
        hint = "Angle"
      }
      pitch: =
      {
        txt = "&"
        hint = "Pitch"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Initially dark"
      }
      _lightHDR: =
      {
        txt = "&"
        hint = "use -1 -1 -1 1 as the argument"
      }
      _zero_percent_distance: =
      {
        txt = "&"
        hint = "use 0 as the argument"
      }
      _fifty_percent_distance: =
      {
        txt = "&"
        hint = "use 0 as the argument"
      }
    }
    light_dynamic:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      target: =
      {
        txt = "&"
        hint = "Entity to point at"
      }
      _light: =
      {
        txt = "&"
        hint = "Light color"
      }
      _light: =
      {
        Txt = "&"
        Typ = "LU4"
        Hint = "light color (not the intensity, only the color)"
      }
      brightness: =
      {
        txt = "&"
        hint = "Light brightness"
      }
      _inner_cone: =
      {
        txt = "&"
        hint = "Inner (bright) angle"
      }
      _cone: =
      {
        txt = "&"
        hint = "Outer (fading) angle"
      }
      pitch: =
      {
        txt = "&"
        hint = "Pitch"
      }
      distance: =
      {
        txt = "&"
        hint = "Maximum distance"
      }
      spotlight_radius: =
      {
        txt = "&"
        hint = "Spotlight end radius"
      }
      style: =
      {
        txt = "&"
        hint = "Appearance"
        typ = "C"
        items = "Normal"$0D"Fluorescent flicker"$0D"Slow, strong pulse"$0D"Slo"
         "w pulse, noblack"$0D"Gentle pulse"$0D"Flicker A"$0D"Flicker B"$0D"Ca"
         "ndle A"$0D"Candle B"$0D"Candle C"$0D"Fast strobe"$0D"Slow strobe"
        values = "0"$0D"10"$0D"2"$0D"11"$0D"5"$0D"1"$0D"6"$0D"3"$0D"7"$0D"8"$0D
         "4"$0D"9"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No world light"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "No model light"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Add Displacement Alpha"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Subtract Displacement Alpha"
      }
      input#Color: =
      {
        txt = "&"
        hint = "Set the light's render color (R G B)."
      }
      input#brightness: =
      {
        txt = "&"
        hint = "Set the light brightness."
      }
      input#distance: =
      {
        txt = "&"
        hint = "Set the maximum light distance."
      }
      input#_inner_cone: =
      {
        txt = "&"
        hint = "Set the inner (bright) angle."
      }
      input#_cone: =
      {
        txt = "&"
        hint = "Set the outer (fading) angle."
      }
      input#spotlight_radius: =
      {
        txt = "&"
        hint = "Set the radius of the spotlight at the end point."
      }
      input#style: =
      {
        txt = "&"
        hint = "Change the lightstyle (see Appearance field for possible value"
         "s)."
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn the light off."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn the light on."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the light on/off."
      }
    }
    shadow_control:form =
    {
      t_Targetname = !
      angles: =
      {
        txt = "&"
        hint = "Pitch Yaw Roll (Y Z X)"
      }
      color: =
      {
        txt = "&"
        hint = "Shadow Color"
      }
      color: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Shadow Color"
      }
      distance: =
      {
        txt = "&"
        hint = "Maximum Distance"
      }
      input#color: =
      {
        txt = "&"
        hint = "Set the shadow color."
      }
      input#direction: =
      {
        txt = "&"
        hint = "Set the shadow direction."
      }
      input#SetDistance: =
      {
        txt = "&"
        hint = "Set the maximum shadow cast distance."
      }
      input#SetAngles: =
      {
        txt = "&"
        hint = "Set the shadow direction."
      }
    }
    t_KeyFrame:incl =
    {
      NextKey: =
      {
        txt = "&"
        hint = "Next KeyFrame"
      }
      MoveSpeed: =
      {
        txt = "&"
        hint = "Speed (units per second)"
      }
    }
    t_Mover:incl =
    {
      PositionInterpolator: =
      {
        txt = "&"
        hint = "Position Interpolator"
        typ = "C"
        items = "Linear"$0D"Catmull-Rom Spline"
        values = "0"$0D"1"
      }
    }
    func_movelinear:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      movedir: =
      {
        txt = "&"
        hint = "Move Direction (Pitch Yaw Roll)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Not Solid"
      }
      startposition: =
      {
        txt = "&"
        hint = "Start Position"
      }
      speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      movedistance: =
      {
        txt = "&"
        hint = "Move Distance"
      }
      blockdamage: =
      {
        txt = "&"
        hint = "Block Damage"
      }
      startsound: =
      {
        txt = "&"
        hint = "Sound played when the brush starts moving."
      }
      stopsound: =
      {
        txt = "&"
        hint = "Sound played when the brush stops moving."
      }
      input#Open: =
      {
        txt = "&"
        hint = "Move the brush to the end position (starting position + (move "
         "direction * move distance))."
      }
      input#Close: =
      {
        txt = "&"
        hint = "Move the brush to the starting position."
      }
      input#SetPosition: =
      {
        txt = "&"
        hint = "Move the brush to a specific position between 0.0 and 1.0, whe"
         "re 0 is the starting position and 1 is the starting position + (move"
         " direction * move distance)."
      }
      output#OnFullyOpen: =
      {
        txt = "&"
        hint = "Fired when the brush reaches the end position (starting positi"
         "on + (move direction * move distance))."
      }
      output#OnFullyClosed: =
      {
        txt = "&"
        hint = "Fired when the brush reaches the starting position."
      }
    }

    t_func_movelinear:incl =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      movedir: =
      {
        txt = "&"
        hint = "Move Direction (Pitch Yaw Roll)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Not Solid"
      }
      startposition: =
      {
        txt = "&"
        hint = "Start Position"
      }
      speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      movedistance: =
      {
        txt = "&"
        hint = "Move Distance"
      }
      blockdamage: =
      {
        txt = "&"
        hint = "Block Damage"
      }
      startsound: =
      {
        txt = "&"
        hint = "Sound played when the brush starts moving."
      }
      stopsound: =
      {
        txt = "&"
        hint = "Sound played when the brush stops moving."
      }
      input#Open: =
      {
        txt = "&"
        hint = "Move the brush to the end position (starting position + (move "
         "direction * move distance))."
      }
      input#Close: =
      {
        txt = "&"
        hint = "Move the brush to the starting position."
      }
      input#SetPosition: =
      {
        txt = "&"
        hint = "Move the brush to a specific position between 0.0 and 1.0, whe"
         "re 0 is the starting position and 1 is the starting position + (move"
         " direction * move distance)."
      }
      output#OnFullyOpen: =
      {
        txt = "&"
        hint = "Fired when the brush reaches the end position (starting positi"
         "on + (move direction * move distance))."
      }
      output#OnFullyClosed: =
      {
        txt = "&"
        hint = "Fired when the brush reaches the starting position."
      }
    }

    func_water_analog:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      movedir: =
      {
        txt = "&"
        hint = "Move Direction (Pitch Yaw Roll)"
      }
      startposition: =
      {
        txt = "&"
        hint = "Start Position"
      }
      speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      movedistance: =
      {
        txt = "&"
        hint = "Move Distance"
      }
      startsound: =
      {
        txt = "&"
        hint = "Sound played when the water brush starts moving."
      }
      stopsound: =
      {
        txt = "&"
        hint = "Sound played when the water brush stops moving."
      }
      WaveHeight: =
      {
        txt = "&"
        hint = "Wave Height"
      }
      input#Open: =
      {
        txt = "&"
        hint = "Move the water brush to the end position (starting position + "
         "(move direction * move distance))."
      }
      input#Close: =
      {
        txt = "&"
        hint = "Move the water brush to the starting position."
      }
      input#SetPosition: =
      {
        txt = "&"
        hint = "Move the water brush to a specific position between 0.0 and 1."
         "0, where 0 is the starting position and 1 is the starting position +"
         " (move direction * move distance)."
      }
      output#OnFullyOpen: =
      {
        txt = "&"
        hint = "Fired when the water brush reaches the end position (starting "
         "position + (move direction * move distance))."
      }
      output#OnFullyClosed: =
      {
        txt = "&"
        hint = "Fired when the water brush reaches the starting position."
      }
      renderfx: =
      {
        txt = "&"
        hint = "Use 0 as your argument unless you know what your doing"
      }
      rendermode: =
      {
        txt = "&"
        hint = "Use 0 as your argument unless you know what your doing"
      }
      renderamt: =
      {
        txt = "&"
        hint = "Translucency"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "RGB Color"
      }
      disableshadows: =
      {
        txt = "&"
        hint = "Use 0 as your argument unless you know what your doing"
      }
      disablereceiveshadows: =
      {
        txt = "&"
        hint = "Use 0 as your argument unless you know what your doing"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum light level"
      }
    }
    func_rotating:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_Angles = !
      t_RenderFields = !
      t_Shadow = !
      maxspeed: =
      {
        txt = "&"
        hint = "Max Rotation Speed"
      }
      fanfriction: =
      {
        txt = "&"
        hint = "Friction (0 - 100%)"
      }
      message: =
      {
        txt = "&"
        hint = "Rotating sound WAV"
      }
      volume: =
      {
        txt = "&"
        hint = "Volume (10 = loudest)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start ON"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Reverse Direction"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "X Axis"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Y Axis"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Acc/Dcc"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Fan Pain"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Not Solid"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Small Sound Radius"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Medium Sound Radius"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Large Sound Radius"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      dmg: =
      {
        txt = "&"
        hint = "Blocking Damage"
      }
      solidbsp: =
      {
        txt = "&"
        hint = "Solid Type"
        typ = "C"
        items = "VPhysics"$0D"BSP"
        values = "0"$0D"1"
      }
      input#SetSpeed: =
      {
        txt = "&"
        hint = "Set the speed as a ratio of the specified Max Rotation Speed, "
         "where 0 is stopped and 1 is the Max Rotation Speed.."
      }
      input#Start: =
      {
        txt = "&"
        hint = "Start the rotator rotating."
      }
      input#Stop: =
      {
        txt = "&"
        hint = "Stop the rotator from rotating."
      }
      input#StopAtStartPos: =
      {
        txt = "&"
        hint = "Stop the rotator from rotating when it gets around to the star"
         "t position again (on its rotation axis)."
      }
      input#StartForward: =
      {
        txt = "&"
        hint = "Start the rotator rotating forward."
      }
      input#StartBackward: =
      {
        txt = "&"
        hint = "Start the rotator rotating backward."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the rotator between rotating and not rotating."
      }
      input#Reverse: =
      {
        txt = "&"
        hint = "Reverse the direction of rotation of the rotator."
      }
    }
    func_platrot:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_Angles = !
      t_RenderFields = !
      t_BasePlat = !
      t_Shadow = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Toggle"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "X Axis"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Y Axis"
      }
      noise1: =
      {
        txt = "&"
        hint = "Movement Sound"
      }
      noise2: =
      {
        txt = "&"
        hint = "Stop Sound"
      }
      speed: =
      {
        txt = "&"
        hint = "Speed of Rotation"
      }
      height: =
      {
        txt = "&"
        hint = "Travel Altitude"
      }
      rotation: =
      {
        txt = "&"
        hint = "Spin amount"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
    }
    keyframe_track:form =
    {
      bbox = '-6 -6 -6 6 6 6'
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      t_KeyFrame = !
    }
    move_keyframed:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      t_Parentname = !
      t_KeyFrame = !
      t_Mover = !
    }
    move_track:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      t_Parentname = !
      t_Mover = !
      t_KeyFrame = !
      WheelBaseLength: =
      {
        txt = "&"
        hint = "Distance between the wheels"
      }
      Damage: =
      {
        txt = "&"
        hint = "Damage done to blocking entities"
      }
      NoRotate: =
      {
        txt = "&"
        hint = "Turn to face down path"
        typ = "C"
        items = "Yes"$0D"No"
        values = "0"$0D"1"
      }
    }
    t_RopeKeyFrame:incl =
    {
      t_DXLevelChoice = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Auto Resize"
      }
      Slack: =
      {
        txt = "&"
        hint = "Slack"
      }
      Type: =
      {
        txt = "&"
        hint = "Type"
        typ = "C"
        items = "Rope"$0D"Semi-rigid"$0D"Rigid"
        values = "0"$0D"1"$0D"2"
      }
      Subdiv: =
      {
        txt = "&"
        hint = "Subdivision"
      }
      Barbed: =
      {
        txt = "&"
        hint = "Barbed"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      Width: =
      {
        txt = "&"
        hint = "Width (1-64)"
      }
      TextureScale: =
      {
        txt = "&"
        hint = "Texture Scale"
      }
      Collide: =
      {
        txt = "&"
        hint = "Collide with world"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      Dangling: =
      {
        txt = "&"
        hint = "Start Dangling"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      Breakable: =
      {
        txt = "&"
        hint = "Breakable"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      RopeMaterial: =
      {
        txt = "&"
        hint = "Rope Material"
        typ = "ET"
        Cap = "texture..."
      }
      input#SetScrollSpeed: =
      {
        txt = "&"
        hint = "Set the speed at which the texture scrolls."
      }
      input#SetForce: =
      {
        txt = "&"
        hint = "Apply a force instantaneously to the rope. The parameter shoul"
         "d be a vector containing the force to be applied (X Y Z)."
      }
      input#Break: =
      {
        txt = "&"
        hint = "Break the rope, if it's marked to do so."
      }
    }
    keyframe_rope:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_KeyFrame = !
      t_RopeKeyFrame = !
    }
    move_rope:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_KeyFrame = !
      t_RopeKeyFrame = !
      PositionInterpolator: =
      {
        txt = "&"
        hint = "Position Interpolator"
        typ = "C"
      }
    }
    t_Button:incl =
    {
      input#Lock: =
      {
        txt = "&"
        hint = "Lock the button, preventing it from functioning."
      }
      input#Unlock: =
      {
        txt = "&"
        hint = "Unlock the button, allowing it to function."
      }
      input#Press: =
      {
        txt = "&"
        hint = "Activate the button, as if it was pressed."
      }
      output#OnDamaged: =
      {
        txt = "&"
        hint = "Fired when the button is damaged."
      }
      output#OnPressed: =
      {
        txt = "&"
        hint = "Fired when the button is pressed."
      }
      output#OnUseLocked: =
      {
        txt = "&"
        hint = "Fired when the button is used while locked."
      }
      output#OnIn: =
      {
        txt = "&"
        hint = "Fired when the button reaches the in/pressed position."
      }
      output#OnOut: =
      {
        txt = "&"
        hint = "Fired when the button reaches the out/released position."
      }
    }
    func_button:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_RenderFields = !
      t_Button = !
      movedir: =
      {
        txt = "&"
        hint = "Move Direction (Pitch Yaw Roll)"
      }
      speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      health: =
      {
        txt = "&"
        hint = "Health (Obsolete)"
      }
      lip: =
      {
        txt = "&"
        hint = "Lip"
      }
      master: =
      {
        txt = "&"
        hint = "Master (Obsolete)"
      }
      sounds: =
      {
        txt = "&"
        hint = "Sounds"
        typ = "C"
        items = "None (Silent)"$0D"Big zap & Warmup"$0D"Access Denied"$0D"Acce"
         "ss Granted"$0D"Quick Combolock"$0D"Power Deadbolt 1"$0D"Power Deadbo"
         "lt 2"$0D"Plunger"$0D"Small zap"$0D"Keycard Sound"$0D"Buzz"$0D"Buzz O"
         "ff"$0D"latch locked"$0D"Latch Unlocked"$0D"Lightswitch"$0D"small ble"
         "ek"$0D"small deny"$0D"small doop"$0D"small tech deny"$0D"click and c"
         "ombine screen fuzz"$0D"roomy beep"$0D"lever or wheel: turn + move sq"
         "eek"$0D"lever or wheel: latch + release gas"$0D"lever or wheel: ratc"
         "het + sqeek"$0D"lever or wheel: large ratchet"$0D"lever or wheel: cl"
         "anky + gas release"$0D"lever or wheel: latch + large metal thud"$0D"l"
         "ever or wheel: smaller ratchet"$0D"lever or wheel: smaller lever mov"
         "e"$0D"shock buzz"$0D"clickbeep"$0D"tech blip"$0D"clickbeepbeep open"$0D
         "small high blip"$0D"small tech fuzz blip"$0D"small click bleep (chan"
         "ge to lightswitch)"$0D"combine door lock - locked"$0D"combine blip g"
         "rowl"$0D"combine squick growl"$0D"combine whine purr"$0D"combine cli"
         "ck talk"$0D"combine click growl fizz"$0D"combine click fizz (deny)"$0D
         "combine click talker"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"$0D"9"$0D"1"
         "0"$0D"11"$0D"12"$0D"13"$0D"14"$0D"15"$0D"16"$0D"17"$0D"18"$0D"19"$0D
         "20"$0D"21"$0D"22"$0D"23"$0D"24"$0D"25"$0D"26"$0D"27"$0D"28"$0D"31"$0D
         "32"$0D"33"$0D"34"$0D"35"$0D"36"$0D"37"$0D"40"$0D"41"$0D"42"$0D"43"$0D
         "44"$0D"45"$0D"46"$0D"47"
      }
      wait: =
      {
        txt = "&"
        hint = "Delay Before Reset (-1 stay)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Don't move"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Toggle"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Touch Activates"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Damage Activates"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1024"
        cap = "Use Activates"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2048"
        cap = "Starts locked"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4096"
        cap = "Sparks"
      }
      locked_sound: =
      {
        txt = "&"
        hint = "Locked Sound"
        typ = "C"
        items = "None"$0D"Access Denied"$0D"Small zap"$0D"Buzz"$0D"Buzz Off"$0D
         "Latch Locked"
        values = "0"$0D"2"$0D"8"$0D"10"$0D"11"$0D"12"
      }
      unlocked_sound: =
      {
        txt = "&"
        hint = "Unlocked Sound"
        typ = "C"
        items = "None"$0D"Big zap & Warmup"$0D"Access Granted"$0D"Quick Combol"
         "ock"$0D"Power Deadbolt 1"$0D"Power Deadbolt 2"$0D"Plunger"$0D"Small "
         "zap"$0D"Keycard Sound"$0D"Buzz"$0D"Latch Unlocked"$0D"Lightswitch"
        values = "0"$0D"1"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"$0D"9"$0D"10"$0D
         "13"$0D"14"
      }
      locked_sentence: =
      {
        txt = "&"
        hint = "Locked Sentence"
        typ = "C"
        items = "None"$0D"Gen. Access Denied"$0D"Security Lockout"$0D"Blast Do"
         "or"$0D"Fire Door"$0D"Chemical Door"$0D"Radiation Door"$0D"Gen. Conta"
         "inment"$0D"Maintenance Door"$0D"Broken Shut Door"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"$0D"9"
      }
      unlocked_sentence: =
      {
        txt = "&"
        hint = "Unlocked Sentence"
        typ = "C"
        items = "None"$0D"Gen. Access Granted"$0D"Security Disengaged"$0D"Blas"
         "t Door"$0D"Fire Door"$0D"Chemical Door"$0D"Radiation Door"$0D"Gen. C"
         "ontainment"$0D"Maintenance area"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
    }
    func_rot_button:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_Angles = !
      t_Global = !
      t_Button = !
      master: =
      {
        txt = "&"
        hint = "Master (Obsolete)"
      }
      speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      health: =
      {
        txt = "&"
        hint = "Health (Obsolete)"
      }
      sounds: =
      {
        txt = "&"
        hint = "Sounds"
        typ = "C"
        items = "None (Silent)"$0D"Squeaky"$0D"Squeaky Pneumatic"$0D"Ratchet G"
         "roan"$0D"Clean Ratchet"$0D"Gas Clunk"
        values = "0"$0D"21"$0D"22"$0D"23"$0D"24"$0D"25"
      }
      wait: =
      {
        txt = "&"
        hint = "Delay Before Reset (-1 stay)"
      }
      distance: =
      {
        txt = "&"
        hint = "Distance (deg)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Not solid"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Reverse Dir"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Toggle"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "X Axis"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Y Axis"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Touch Activates"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Damage Activates"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1024"
        cap = "Use Activates"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2048"
        cap = "Starts locked"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
    }
    momentary_rot_button:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_Angles = !
      t_RenderFields = !
      speed: =
      {
        txt = "&"
        hint = "Speed (deg/sec)"
      }
      master: =
      {
        txt = "&"
        hint = "Master (Obsolete)"
      }
      sounds: =
      {
        txt = "&"
        hint = "Sounds"
        typ = "C"
        items = "None"$0D"Big zap & Warmup"$0D"Access Denied"$0D"Access Grante"
         "d"$0D"Quick Combolock"$0D"Power Deadbolt 1"$0D"Power Deadbolt 2"$0D"P"
         "lunger"$0D"Small zap"$0D"Keycard Sound"$0D"Squeaky"$0D"Squeaky Pneum"
         "atic"$0D"Ratchet Groan"$0D"Clean Ratchet"$0D"Gas Clunk"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"$0D"9"$0D"2"
         "1"$0D"22"$0D"23"$0D"24"$0D"25"
      }
      distance: =
      {
        txt = "&"
        hint = "Distance"
      }
      returnspeed: =
      {
        txt = "&"
        hint = "Auto-return speed"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Not Solid"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Toggle (Disable Auto Return)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "X Axis"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Y Axis"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1024"
        cap = "Use Activates"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2048"
        cap = "Starts locked"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8192"
        cap = "Jiggle when used while locked"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      startposition: =
      {
        txt = "&"
        hint = "Start Position"
      }
      startdirection: =
      {
        txt = "&"
        hint = "Start Direction"
        typ = "C"
        items = "Forward"$0D"Backward"
        values = "-1"$0D"1"
      }
      solidbsp: =
      {
        txt = "&"
        hint = "Solid BSP"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#Lock: =
      {
        txt = "&"
        hint = "Lock the button, preventing it from functioning."
      }
      input#Unlock: =
      {
        txt = "&"
        hint = "Unlock the button, allowing it to function."
      }
      input#SetPosition: =
      {
        txt = "&"
        hint = "Move to a position. The parameter must be a value between 0 an"
         "d 1, where 0 is the unrotated position and 1 is the rotated position"
         " + 'Distance'."
      }
      input#SetPositionImmediately: =
      {
        txt = "&"
        hint = "Immediately teleport to a position. The parameter must be a va"
         "lue between 0 and 1, where 0 is the unrotated position and 1 is the "
         "rotated position + 'Distance'."
      }
      output#Position: =
      {
        txt = "&"
        hint = "Fired whenever the button moves. The output is the position of"
         " button from 0 to 1, where 0 is the unrotated position and 1 is the "
         "rotated position + 'Distance'."
      }
      output#OnPressed: =
      {
        txt = "&"
        hint = "Fired when the button is first pressed."
      }
      output#OnUnpressed: =
      {
        txt = "&"
        hint = "Fired when the button is first released from being pressed."
      }
      output#OnFullyClosed: =
      {
        txt = "&"
        hint = "Fired when the button has reached position 1, the rotated posi"
         "tion + 'Distance'."
      }
      output#OnFullyOpen: =
      {
        txt = "&"
        hint = "Fired when the button has reached position 0, the unrotated st"
         "arting position."
      }
      output#OnReachedPosition: =
      {
        txt = "&"
        hint = "Fired whenever the button reaches a goal position: i.e. when i"
         "t becomes open, becomes closed, or reaches the point specified by a "
         "'SetPosition' input."
      }
    }
    t_Door:incl =
    {
      t_Targetname = !
      t_Parentname = !
      t_RenderFields = !
      t_Global = !
      t_Shadow = !
      speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      master: =
      {
        txt = "&"
        hint = "Master (Obsolete)"
      }
      noise1: =
      {
        txt = "&"
        hint = "Start Sound"
      }
      noise2: =
      {
        txt = "&"
        hint = "Stop Sound"
      }
      wait: =
      {
        txt = "&"
        hint = "Delay Before Reset (-1 stay)"
      }
      lip: =
      {
        txt = "&"
        hint = "Lip"
      }
      dmg: =
      {
        txt = "&"
        hint = "Blocking Damage"
      }
      forceclosed: =
      {
        txt = "&"
        hint = "Force Closed"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      message: =
      {
        txt = "&"
        hint = "Message If Triggered"
      }
      health: =
      {
        txt = "&"
        hint = "Health (shoot open)"
      }
      locked_sound: =
      {
        txt = "&"
        hint = "Locked Sound"
      }
      unlocked_sound: =
      {
        txt = "&"
        hint = "Unlocked Sound"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Starts Open"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Non-solid to Player"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Passable"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Toggle"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Use Opens"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "NPCs Can't"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1024"
        cap = "Touch Opens"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2048"
        cap = "Starts locked"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4096"
        cap = "Door Silent"
      }
      locked_sentence: =
      {
        txt = "&"
        hint = "Locked Sentence"
        typ = "C"
        items = "None"$0D"Gen. Access Denied"$0D"Security Lockout"$0D"Blast Do"
         "or"$0D"Fire Door"$0D"Chemical Door"$0D"Radiation Door"$0D"Gen. Conta"
         "inment"$0D"Maintenance Door"$0D"Broken Shut Door"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"$0D"9"
      }
      unlocked_sentence: =
      {
        txt = "&"
        hint = "Unlocked Sentence"
        typ = "C"
        items = "None"$0D"Gen. Access Granted"$0D"Security Disengaged"$0D"Blas"
         "t Door"$0D"Fire Door"$0D"Chemical Door"$0D"Radiation Door"$0D"Gen. C"
         "ontainment"$0D"Maintenance area"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      loopmovesound: =
      {
        txt = "&"
        hint = "Loop Moving Sound?"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      output#OnClose: =
      {
        txt = "&"
        hint = "Fired when the door starts closing."
      }
      output#OnOpen: =
      {
        txt = "&"
        hint = "Fired when the door starts opening."
      }
      output#OnFullyOpen: =
      {
        txt = "&"
        hint = "Fired when the door reaches the fully open position."
      }
      output#OnFullyClosed: =
      {
        txt = "&"
        hint = "Fired when the door reaches the fully closed position."
      }
      output#OnBlockedClosing: =
      {
        txt = "&"
        hint = "Fired when the door is blocked while closing."
      }
      output#OnBlockedOpening: =
      {
        txt = "&"
        hint = "Fired when the door is blocked while opening."
      }
      output#OnUnblockedClosing: =
      {
        txt = "&"
        hint = "Fired when the door is unblocked while closing."
      }
      output#OnUnblockedOpening: =
      {
        txt = "&"
        hint = "Fired when the door is unblocked while opening."
      }
      input#Open: =
      {
        txt = "&"
        hint = "Open the door, if it is not fully open."
      }
      input#Close: =
      {
        txt = "&"
        hint = "Close the door, if it is not fully closed."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the door between open and closed."
      }
      input#Lock: =
      {
        txt = "&"
        hint = "Lock the door."
      }
      input#Unlock: =
      {
        txt = "&"
        hint = "Unlock the door."
      }
      input#SetSpeed: =
      {
        txt = "&"
        hint = "Set the door speed."
      }
    }
    func_door:form =
    {
      t_Door = !
      t_Origin = !
      movedir: =
      {
        txt = "&"
        hint = "Move Direction (Pitch Yaw Roll)"
      }
      filtername: =
      {
        txt = "&"
        hint = "Block Filter Name"
      }
    }
    func_door_rotating:form =
    {
      t_Door = !
      t_Origin = !
      t_Angles = !
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Reverse Dir"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "One-way"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "X Axis"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Y Axis"
      }
      distance: =
      {
        txt = "&"
        hint = "Distance"
      }
      solidbsp: =
      {
        txt = "&"
        hint = "Solid Type"
        typ = "C"
        items = "VPhysics"$0D"BSP"
        values = "0"$0D"1"
      }
    }
    prop_door_rotating:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      t_Global = !
      t_Studiomodel = !
      hardware: =
      {
        txt = "&"
        hint = "Hardware Type"
        typ = "C"
        items = "<None>"$0D"Lever"$0D"Push bar"
        values = "0"$0D"1"$0D"2"
      }
      ajarangles: =
      {
        txt = "&"
        hint = "Ajar Angles (Pitch Yaw Roll)"
      }
      spawnpos: =
      {
        txt = "&"
        hint = "Spawn Position"
        typ = "C"
        items = "Closed"$0D"Open forward"$0D"Open back"$0D"Ajar (use Ajar Angl"
         "es)"
        values = "0"$0D"1"$0D"2"$0D"3"
      }
      axis: =
      {
        txt = "&"
        hint = "Hinge Axis"
      }
      distance: =
      {
        txt = "&"
        hint = "Rotation Distance (deg)"
      }
      speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      soundopenoverride: =
      {
        txt = "&"
        hint = "Fully Open Sound"
      }
      soundcloseoverride: =
      {
        txt = "&"
        hint = "Fully Closed Sound"
      }
      soundmoveoverride: =
      {
        txt = "&"
        hint = "Moving Sound"
      }
      returndelay: =
      {
        txt = "&"
        hint = "Delay Before close (-1 stay open)"
      }
      dmg: =
      {
        txt = "&"
        hint = "Damage Inflicted When Blocked"
      }
      health: =
      {
        txt = "&"
        hint = "Health (0 = Unbreakable)"
      }
      soundlockedoverride: =
      {
        txt = "&"
        hint = "Locked Sound"
      }
      soundunlockedoverride: =
      {
        txt = "&"
        hint = "Unlocked Sound"
      }
      forceclosed: =
      {
        txt = "&"
        hint = "Force Closed"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Starts Open"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2048"
        cap = "Starts locked"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4096"
        cap = "Door silent (No sound, and does not alert NPCs)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8192"
        cap = "Use closes"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16384"
        cap = "Door silent to NPCS (Does not alert NPCs)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32768"
        cap = "Ignore player +USE"
      }
      output#OnClose: =
      {
        txt = "&"
        hint = "Fired when the door is told to close."
      }
      output#OnOpen: =
      {
        txt = "&"
        hint = "Fired when the door is told to open."
      }
      output#OnFullyOpen: =
      {
        txt = "&"
        hint = "Fired when the door reaches the fully open position."
      }
      output#OnFullyClosed: =
      {
        txt = "&"
        hint = "Fired when the door reaches the fully closed position."
      }
      output#OnBlockedClosing: =
      {
        txt = "&"
        hint = "Fired when the door is blocked while closing."
      }
      output#OnBlockedOpening: =
      {
        txt = "&"
        hint = "Fired when the door is blocked while opening."
      }
      output#OnUnblockedClosing: =
      {
        txt = "&"
        hint = "Fired when the door is unblocked while closing."
      }
      output#OnUnblockedOpening: =
      {
        txt = "&"
        hint = "Fired when the door is unblocked while opening."
      }
      input#Open: =
      {
        txt = "&"
        hint = "Open the door, if it is not fully open."
      }
      input#OpenAwayFrom: =
      {
        txt = "&"
        hint = "Open the door away from the specified entity."
      }
      input#Close: =
      {
        txt = "&"
        hint = "Close the door, if it is not fully closed."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the door between open and closed."
      }
      input#Lock: =
      {
        txt = "&"
        hint = "Lock the door."
      }
      input#Unlock: =
      {
        txt = "&"
        hint = "Unlock the door."
      }
    }
    env_cubemap:form =
    {
      cubemapsize: =
      {
        txt = "&"
        hint = "Cubemap Size"
        typ = "C"
        items = "Default"$0D"1x1"$0D"2x2"$0D"4x4"$0D"8x8"$0D"16x16"$0D"32x32"$0D
         "64x64"$0D"128x128"$0D"256x256"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"$0D"9"
      }
      sides: =
      {
        txt = "&"
        hint = "Brush faces"
      }
    }
    t_BModelParticleSpawner:incl =
    {
      StartDisabled: =
      {
        txt = "&"
        hint = "Start Disabled"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      Color: =
      {
        txt = "&"
        hint = "Particle Color (R G B)"
      }
      Color: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Particle Color (R G B)"
      }
      SpawnRate: =
      {
        txt = "&"
        hint = "Particle Per Second"
      }
      SpeedMax: =
      {
        txt = "&"
        hint = "Maximum Particle Speed"
      }
      LifetimeMin: =
      {
        txt = "&"
        hint = "Minimum Particle Lifetime"
      }
      LifetimeMax: =
      {
        txt = "&"
        hint = "Maximum Particle Lifetime"
      }
      DistMax: =
      {
        txt = "&"
        hint = "Maximum Visible Distance"
      }
      Frozen: =
      {
        txt = "&"
        hint = "Frozen"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn on."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn off."
      }
    }
    func_dustmotes:form =
    {
      t_Targetname = !
      t_BModelParticleSpawner = !
      SizeMin: =
      {
        txt = "&"
        hint = "Minimum Particle Size"
      }
      SizeMax: =
      {
        txt = "&"
        hint = "Maximum Particle Size"
      }
      Alpha: =
      {
        txt = "&"
        hint = "Alpha"
      }
    }
    func_smokevolume:form =
    {
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Emissive"
      }
      Color1: =
      {
        txt = "&"
        hint = "Particle Color1 (R G B)"
      }
      Color1: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "light color (not the intensity, only the color)"
      }
      Color2: =
      {
        txt = "&"
        hint = "Particle Color2 (R G B)"
      }
      Color2: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "light color (not the intensity, only the color)"
      }
      material: =
      {
        txt = "&"
        hint = "Material"
        typ = "ET"
        Cap = "texture..."
      }
      ParticleDrawWidth: =
      {
        txt = "&"
        hint = "Particle Draw Width (units)"
      }
      ParticleSpacingDistance: =
      {
        txt = "&"
        hint = "Particle Spacing Distance (units)"
      }
      DensityRampSpeed: =
      {
        txt = "&"
        hint = "Density Ramp Speed (seconds)"
      }
      RotationSpeed: =
      {
        txt = "&"
        hint = "Rotation Speed (degrees/sec)"
      }
      MovementSpeed: =
      {
        txt = "&"
        hint = "Movement Speed (units/sec)"
      }
      Density: =
      {
        txt = "&"
        hint = "Density [0..1]"
      }
      input#SetRotationSpeed: =
      {
        txt = "&"
        hint = "Set the particle rotation speed (in degrees per second)."
      }
      input#SetMovementSpeed: =
      {
        txt = "&"
        hint = "Set the particle movement speed (in inches per second)."
      }
      input#SetDensity: =
      {
        txt = "&"
        hint = "Set the particle density. It should be a range from 0 to 1."
      }
    }
    func_dustcloud:form =
    {
      t_Targetname = !
      t_BModelParticleSpawner = !
      Alpha: =
      {
        txt = "&"
        hint = "Alpha"
      }
      SizeMin: =
      {
        txt = "&"
        hint = "Minimum Particle Size"
      }
      SizeMax: =
      {
        txt = "&"
        hint = "Maximum Particle Size"
      }
    }
    env_dustpuff:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      scale: =
      {
        txt = "&"
        hint = "Scale"
      }
      speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      color: =
      {
        txt = "&"
        hint = "Dust color"
      }
      color: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Dust color"
      }
      input#SpawnDust: =
      {
        txt = "&"
        hint = "Spawn a dust puff."
      }
    }
    env_particlescript:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      model: =
      {
        txt = "&"
        hint = "Script Model"
        typ = "B"
        Cap = "models..."
        form = "t_models_hl2_form:form"
      }
      input#SetSequence: =
      {
        txt = "&"
        hint = "Sets the script model's sequence."
      }
    }
    env_effectscript:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      model: =
      {
        txt = "&"
        hint = "Script Model"
        typ = "B"
        Cap = "models..."
        form = "t_models_hl2_form:form"
      }
      scriptfile: =
      {
        txt = "&"
        hint = "Script File"
      }
      input#SetSequence: =
      {
        txt = "&"
        hint = "Sets the script model's sequence."
      }
    }
    logic_auto:form =
    {
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Remove on fire"
      }
      globalstate: =
      {
        txt = "&"
        hint = "Global State to Read"
        typ = "C"
        items = "--- None ---"$0D"Gordon pre-criminal"$0D"Antlions are player "
         "allies"$0D"Suit sprint function not yet enabled"$0D"Super phys gun i"
         "s enabled"$0D"Friendly encounter sequence (lower weapons, etc.)"$0D"G"
         "ordon is invulnerable"$0D"Don't spawn seagulls on the jeep"
        values = $0D"gordon_precriminal"$0D"antlion_allied"$0D"suit_no_sprint"$0D
         "super_phys_gun"$0D"friendly_encounter"$0D"gordon_invulnerable"$0D"no"
         "_seagulls_on_jeep"
      }
      output#OnMapSpawn: =
      {
        txt = "&"
        hint = "Fired when the map is loaded for any reason."
      }
      output#OnNewGame: =
      {
        txt = "&"
        hint = "Fired when the map is loaded to start a new game."
      }
      output#OnLoadGame: =
      {
        txt = "&"
        hint = "Fired when the map is loaded from a saved game."
      }
      output#OnMapTransition: =
      {
        txt = "&"
        hint = "Fired when the map is loaded due to a level transition."
      }
      output#OnBackgroundMap: =
      {
        txt = "&"
        hint = "Fired when the map is loaded as a background to the main menu."
      }
    }
    point_viewcontrol:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      t_Angles = !
      t_Parentname = !
      target: =
      {
        txt = "&"
        hint = "Entity to Look At"
      }
      targetattachment: =
      {
        txt = "&"
        hint = "Target Attachment Name"
      }
      wait: =
      {
        txt = "&"
        hint = "Hold Time"
      }
      moveto: =
      {
        txt = "&"
        hint = "Path Corner"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start At Player"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Follow Player"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Freeze Player"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Infinite Hold Time"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Snap to goal angles"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Make Player non-solid"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Interruptable by Player"
      }
      speed: =
      {
        txt = "&"
        hint = "Initial Speed"
      }
      acceleration: =
      {
        txt = "&"
        hint = "Acceleration units/sec^2"
      }
      deceleration: =
      {
        txt = "&"
        hint = "Stop Deceleration units/sec^2"
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable the point_viewcontrol, and start controlling the player"
         "'s view."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable the point_viewcontrol, and stop controlling the player"
         "'s view."
      }
      output#OnEndFollow: =
      {
        txt = "&"
        hint = "Fired when the point_viewcontrol deactivates, due to the Disab"
         "le input being received, the Entity to Look At being destroyed, or t"
         "he Hold Time expiring."
      }
    }
    logic_compare:form =
    {
      t_Targetname = !
      InitialValue: =
      {
        txt = "&"
        hint = "Initial value"
      }
      CompareValue: =
      {
        txt = "&"
        hint = "Compare value"
      }
      input#SetValue: =
      {
        txt = "&"
        hint = "Set the value that will be compared against the compare value."
      }
      input#SetValueCompare: =
      {
        txt = "&"
        hint = "Set the value that will be compared against the compare value "
         "and performs the comparison."
      }
      input#SetCompareValue: =
      {
        txt = "&"
        hint = "Set the compare value."
      }
      input#Compare: =
      {
        txt = "&"
        hint = "Force a compare of the input value with the compare value."
      }
      output#OnLessThan: =
      {
        txt = "&"
        hint = "Fired when the input value is less than the compare value. Sen"
         "ds the input value as data."
      }
      output#OnEqualTo: =
      {
        txt = "&"
        hint = "Fired when the input value is equal to the compare value. Send"
         "s the input value as data."
      }
      output#OnNotEqualTo: =
      {
        txt = "&"
        hint = "Fired when the input value is different from the compare value"
         ". Sends the input value as data."
      }
      output#OnGreaterThan: =
      {
        txt = "&"
        hint = "Fired when the input value is greater than the compare value. "
         "Sends the input value as data."
      }
    }
    logic_branch:form =
    {
      t_Targetname = !
      InitialValue: =
      {
        txt = "&"
        hint = "Initial value"
      }
      input#SetValue: =
      {
        txt = "&"
        hint = "Set the boolean value without performing the comparison. Use t"
         "his to hold a value for a future test."
      }
      input#SetValueTest: =
      {
        txt = "&"
        hint = "Set the boolean value and test it, firing OnTrue or OnFalse ba"
         "sed on the new value."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the boolean value between true and false."
      }
      input#ToggleTest: =
      {
        txt = "&"
        hint = "Toggle the boolean value and tests it, firing OnTrue or OnFals"
         "e based on the new value."
      }
      input#Test: =
      {
        txt = "&"
        hint = "Test the input value and fire OnTrue or OnFalse based on the v"
         "alue."
      }
      output#OnTrue: =
      {
        txt = "&"
        hint = "Fired when the input value is true (nonzero)."
      }
      output#OnFalse: =
      {
        txt = "&"
        hint = "Fired when the input value is false (zero)."
      }
    }
    logic_case:form =
    {
      t_Targetname = !
      Case01: =
      {
        txt = "&"
        hint = "Case 01"
      }
      Case02: =
      {
        txt = "&"
        hint = "Case 02"
      }
      Case03: =
      {
        txt = "&"
        hint = "Case 03"
      }
      Case04: =
      {
        txt = "&"
        hint = "Case 04"
      }
      Case05: =
      {
        txt = "&"
        hint = "Case 05"
      }
      Case06: =
      {
        txt = "&"
        hint = "Case 06"
      }
      Case07: =
      {
        txt = "&"
        hint = "Case 07"
      }
      Case08: =
      {
        txt = "&"
        hint = "Case 08"
      }
      Case09: =
      {
        txt = "&"
        hint = "Case 09"
      }
      Case10: =
      {
        txt = "&"
        hint = "Case 10"
      }
      Case11: =
      {
        txt = "&"
        hint = "Case 11"
      }
      Case12: =
      {
        txt = "&"
        hint = "Case 12"
      }
      Case13: =
      {
        txt = "&"
        hint = "Case 13"
      }
      Case14: =
      {
        txt = "&"
        hint = "Case 14"
      }
      Case15: =
      {
        txt = "&"
        hint = "Case 15"
      }
      Case16: =
      {
        txt = "&"
        hint = "Case 16"
      }
      input#InValue: =
      {
        txt = "&"
        hint = "Compare the Input value to the case values, and fire the appro"
         "priate output, if any."
      }
      input#PickRandom: =
      {
        txt = "&"
        hint = "Fire a random OnCase output with at least one connection."
      }
      output#OnCase01: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case01 value."
      }
      output#OnCase02: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case02 value."
      }
      output#OnCase03: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case03 value."
      }
      output#OnCase04: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case04 value."
      }
      output#OnCase05: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case05 value."
      }
      output#OnCase06: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case06 value."
      }
      output#OnCase07: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case07 value."
      }
      output#OnCase08: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case08 value."
      }
      output#OnCase09: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case09 value."
      }
      output#OnCase10: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case10 value."
      }
      output#OnCase11: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case11 value."
      }
      output#OnCase12: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case12 value."
      }
      output#OnCase13: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case13 value."
      }
      output#OnCase14: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case14 value."
      }
      output#OnCase15: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case15 value."
      }
      output#OnCase16: =
      {
        txt = "&"
        hint = "Fired when the input value equals the Case16 value."
      }
      output#OnDefault: =
      {
        txt = "&"
        hint = "Fired when the input value does not equal any of the Case valu"
         "es."
      }
    }
    logic_multicompare:form =
    {
      t_Targetname = !
      IntegerValue: =
      {
        txt = "&"
        hint = "Integer Value (optional)"
      }
      ShouldComparetoValue: =
      {
        txt = "&"
        hint = "Should use Integer Value"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#InputValue: =
      {
        txt = "&"
        hint = "Input value"
      }
      input#CompareValues: =
      {
        txt = "&"
        hint = "Compares the values and fires appropriate outputs"
      }
      output#OnEqual: =
      {
        txt = "&"
        hint = "Fires if the values are equal"
      }
      output#OnNotEqual: =
      {
        txt = "&"
        hint = "Fires if the values are not equal"
      }
    }
    logic_relay:form =
    {
      t_Targetname = !
      t_EnableDisable = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Only trigger once"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Allow fast retrigger"
      }
      input#Trigger: =
      {
        txt = "&"
        hint = "Trigger the relay, causing its OnTrigger output to fire if it "
         "is enabled."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the relay between enabled and disabled."
      }
      input#CancelPending: =
      {
        txt = "&"
        hint = "Cancel any events fired by this relay that are currently pendi"
         "ng in the I/O event queue."
      }
      output#OnTrigger: =
      {
        txt = "&"
        hint = "Fired when the relay is triggered."
      }
    }
    logic_timer:form =
    {
      t_Targetname = !
      t_EnableDisable = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Oscillator (alternates between OnTimerHigh and OnTimerLow outpu"
         "ts)"
      }
      UseRandomTime: =
      {
        txt = "&"
        hint = "Use Random Time"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      LowerRandomBound: =
      {
        txt = "&"
        hint = "Minimum Random Interval"
      }
      UpperRandomBound: =
      {
        txt = "&"
        hint = "Maximum Random Interval"
      }
      RefireTime: =
      {
        txt = "&"
        hint = "Refire Interval"
      }
      input#RefireTime: =
      {
        txt = "&"
        hint = "Set a new Refire Interval."
      }
      input#FireTimer: =
      {
        txt = "&"
        hint = "Force the timer to fire immediately."
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable the timer."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable the timer."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the timer on/off."
      }
      input#LowerRandomBound: =
      {
        txt = "&"
        hint = "Set a new Minimum Random Interval."
      }
      input#UpperRandomBound: =
      {
        txt = "&"
        hint = "Set a new Maximum Random Interval."
      }
      output#OnTimer: =
      {
        txt = "&"
        hint = "Fired when the timer expires."
      }
      output#OnTimerHigh: =
      {
        txt = "&"
        hint = "Fired every other time for an oscillating timer."
      }
      output#OnTimerLow: =
      {
        txt = "&"
        hint = "Fired every other time for an oscillating timer."
      }
    }
    logic_collision_pair:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      attach1: =
      {
        txt = "&"
        hint = "Attachment 1"
      }
      attach2: =
      {
        txt = "&"
        hint = "Attachment 2"
      }
      startdisabled: =
      {
        txt = "&"
        hint = "Start with collisions disabled"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#EnableCollisions: =
      {
        txt = "&"
        hint = "Enable collisions between the first and second entity."
      }
      input#DisableCollisions: =
      {
        txt = "&"
        hint = "Disable collisions between the first and second entity."
      }
    }
    env_microphone:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_EnableDisable = !
      target: =
      {
        txt = "&"
        hint = "Measure target"
      }
      SpeakerName: =
      {
        txt = "&"
        hint = "Speaker"
      }
      ListenFilter: =
      {
        txt = "&"
        hint = "Listen Filter"
      }
      speaker_dsp_preset: =
      {
        txt = "&"
        hint = "Speaker DSP Preset"
        typ = "C"
        items = "Use Default"$0D"1 NO EFFECT"$0D"2 (DUPLICATE OF 1)"$0D"3 (DUP"
         "LICATE OF 1)"$0D"4 (DUPLICATE OF 1)"$0D"5 (DUPLICATE OF 1)"$0D"6 SPE"
         "AKER, LOUDER"$0D"7 SPEAKER VERY SMALL"$0D"8 LOUDSPEAKER, ECHO"$0D"9 "
         "SPEAKER SMALL"$0D"10 SPEAKER TINY"
        values = "0"$0D"50"$0D"51"$0D"52"$0D"53"$0D"54"$0D"55"$0D"56"$0D"57"$0D
         "58"$0D"59"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Hears combat sounds"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Hears world sounds"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Hears player sounds"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Hears bullet impacts"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Swallows sounds routed through speakers"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Hears explosions"
      }
      Sensitivity: =
      {
        txt = "&"
        hint = "Sensitivity (0 - 10)"
      }
      SmoothFactor: =
      {
        txt = "&"
        hint = "Smoothing (0 - 1)"
      }
      MaxRange: =
      {
        txt = "&"
        hint = "Maximum hearing range (0=infinite)"
      }
      input#SetSpeakerName: =
      {
        txt = "&"
        hint = "Set the microphone to output through a different speaker entit"
         "y."
      }
      output#SoundLevel: =
      {
        txt = "&"
        hint = "Fired in Measuring mode whenever the sound level changes."
      }
      output#OnRoutedSound: =
      {
        txt = "&"
        hint = "Fired whenever a sound is routed out through the specified spe"
         "aker (if any)."
      }
      output#OnHeardSound: =
      {
        txt = "&"
        hint = "Fired whenever this microphone hears any sound it cares about."
      }
    }
    math_remap:form =
    {
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Ignore out of range input values"
      }
      in1: =
      {
        txt = "&"
        hint = "Minimum Valid Input Value"
      }
      in2: =
      {
        txt = "&"
        hint = "Maximum Valid Input Value"
      }
      out1: =
      {
        txt = "&"
        hint = "Output Value When Input Is Min."
      }
      out2: =
      {
        txt = "&"
        hint = "Output Value When Input Is Max."
      }
      input#InValue: =
      {
        txt = "&"
        hint = "Input value and fire the output with the remapped value."
      }
      output#OutValue: =
      {
        txt = "&"
        hint = "Fired when the InValue input is received, with the remapped in"
         "put value as the parameter."
      }
    }
    math_colorblend:form =
    {
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Ignore out of range input values"
      }
      inmin: =
      {
        txt = "&"
        hint = "Minimum Valid Input Value"
      }
      inmax: =
      {
        txt = "&"
        hint = "Maximum Valid Input Value"
      }
      colormin: =
      {
        txt = "&"
        hint = "Output RGB color when input is min."
      }
      colormax: =
      {
        txt = "&"
        hint = "Output RGB color when input is max."
      }
      input#InValue: =
      {
        txt = "&"
        hint = "Input value and fire the output with the remapped value."
      }
      output#OutColor: =
      {
        txt = "&"
        hint = "Fired when the InValue input is received, with the remapped RG"
         "B color as the parameter."
      }
    }
    math_counter:form =
    {
      t_Targetname = !
      startvalue: =
      {
        txt = "&"
        hint = "Initial Value"
      }
      min: =
      {
        txt = "&"
        hint = "Minimum Legal Value"
      }
      max: =
      {
        txt = "&"
        hint = "Maximum Legal Value"
      }
      input#Add: =
      {
        txt = "&"
        hint = "Add an amount to the counter and fire the OutValue output with"
         " the result."
      }
      input#Divide: =
      {
        txt = "&"
        hint = "Divide the counter by an amount and fire the OutValue output w"
         "ith the result."
      }
      input#Multiply: =
      {
        txt = "&"
        hint = "Multiply the counter by an amount and fire the OutValue output"
         " with the result."
      }
      input#SetValue: =
      {
        txt = "&"
        hint = "Set the counter to a new value and fire the OutValue output wi"
         "th the result."
      }
      input#SetValueNoFire: =
      {
        txt = "&"
        hint = "Set the counter to a new value without firing any outputs."
      }
      input#Subtract: =
      {
        txt = "&"
        hint = "Subtract an amount from the counter and fire the OutValue outp"
         "ut with the result."
      }
      input#SetHitMax: =
      {
        txt = "&"
        hint = "Set the upper bound of the counter and fire the OutValue outpu"
         "t with the current value."
      }
      input#SetHitMin: =
      {
        txt = "&"
        hint = "Set the lower bound of the counter and fire the OutValue outpu"
         "t with the current value."
      }
      output#OutValue: =
      {
        txt = "&"
        hint = "Fired when the counter value changes."
      }
      output#OnHitMin: =
      {
        txt = "&"
        hint = "Fired when the counter value meets or goes below the min value"
         ". The counter must go back above the min value before the output wil"
         "l fire again."
      }
      output#OnHitMax: =
      {
        txt = "&"
        hint = "Fired when the counter value meets or exceeds the max value. T"
         "he counter must go below the max value before the output will fire a"
         "gain."
      }
    }
    logic_lineto:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      source: =
      {
        txt = "&"
        hint = "Start entity"
      }
      target: =
      {
        txt = "&"
        hint = "End entity"
      }
      output#Line: =
      {
        txt = "&"
        hint = "Fired when the vector, from the start entity to the end entity"
         ", changes. Passes along the vector as a parameter."
      }
    }
    logic_navigation:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      target: =
      {
        txt = "&"
        hint = "Navigation Entity"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start On"
      }
      navprop: =
      {
        txt = "&"
        hint = "Nav Property"
        typ = "C"
        items = "NPCs Ignore this when navigating (they'll bump into it)"
        values = "Ignore"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn on. The Navigation Entity will have its navigation proper"
         "ties set."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turn off. The Navigation Entity will have its navigation prope"
         "rties returned to the default settings."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle on/off."
      }
    }
    logic_autosave:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      NewLevelUnit: =
      {
        txt = "&"
        hint = "Force New Level Unit"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      input#Save: =
      {
        txt = "&"
        hint = "Force an autosave."
      }
    }
    point_template:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Don't remove template entities"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Preserve entity names (Don't do name fixup)"
      }
      Template01: =
      {
        txt = "&"
        hint = "Template 1"
      }
      Template02: =
      {
        txt = "&"
        hint = "Template 2"
      }
      Template03: =
      {
        txt = "&"
        hint = "Template 3"
      }
      Template04: =
      {
        txt = "&"
        hint = "Template 4"
      }
      Template05: =
      {
        txt = "&"
        hint = "Template 5"
      }
      Template06: =
      {
        txt = "&"
        hint = "Template 6"
      }
      Template07: =
      {
        txt = "&"
        hint = "Template 7"
      }
      Template08: =
      {
        txt = "&"
        hint = "Template 8"
      }
      Template09: =
      {
        txt = "&"
        hint = "Template 9"
      }
      Template10: =
      {
        txt = "&"
        hint = "Template 10"
      }
      Template11: =
      {
        txt = "&"
        hint = "Template 11"
      }
      Template12: =
      {
        txt = "&"
        hint = "Template 12"
      }
      Template13: =
      {
        txt = "&"
        hint = "Template 13"
      }
      Template14: =
      {
        txt = "&"
        hint = "Template 14"
      }
      Template15: =
      {
        txt = "&"
        hint = "Template 15"
      }
      Template16: =
      {
        txt = "&"
        hint = "Template 16"
      }
      input#ForceSpawn: =
      {
        txt = "&"
        hint = "Spawn an instance of the template at the original position."
      }
      output#OnEntitySpawned: =
      {
        txt = "&"
        hint = "Fired after spawning an instance of this template."
      }
    }
    env_entity_maker:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Enable AutoSpawn (will spawn whenever there's room)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "AutoSpawn: Wait for entity destruction"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "AutoSpawn: Even if the player is looking"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "ForceSpawn: Only if there's room"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "ForceSpawn: Only if the player isn't looking"
      }
      EntityTemplate: =
      {
        txt = "&"
        hint = "Point_template To Spawn"
      }
      input#ForceSpawn: =
      {
        txt = "&"
        hint = "Spawn an instance of the template at this origin and angle."
      }
      output#OnEntitySpawned: =
      {
        txt = "&"
        hint = "Fired when an instance of the entity template has been spawned"
         "."
      }
    }
    t_BaseFilter:incl =
    {
      t_Targetname = !
      Negated: =
      {
        txt = "&"
        hint = "Filter mode"
        typ = "C"
        items = "Allow entities that match criteria"$0D"Disallow entities that"
         " match criteria"
        values = "0"$0D"1"
      }
      input#TestActivator: =
      {
        txt = "&"
        hint = "Test the activator against the filter and fires OnPass or OnFa"
         "il output."
      }
      output#OnPass: =
      {
        txt = "&"
        hint = "Fired in response to TestActivator input if the activator pass"
         "es the filter."
      }
      output#OnFail: =
      {
        txt = "&"
        hint = "Fired in response to TestActivator input if the activator fail"
         "s to pass the filter."
      }
    }
    filter_multi:form =
    {
      t_BaseFilter = !
      filtertype: =
      {
        txt = "&"
        hint = "Logic Type"
        typ = "C"
        items = "AND (all filters must pass)"$0D"OR (any filter must pass)"
        values = "0"$0D"1"
      }
      Negated: =
      {
        txt = "&"
        hint = "Negate Outcome"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      Filter01: =
      {
        txt = "&"
        hint = "Filter 1"
      }
      Filter02: =
      {
        txt = "&"
        hint = "Filter 2"
      }
      Filter03: =
      {
        txt = "&"
        hint = "Filter 3"
      }
      Filter04: =
      {
        txt = "&"
        hint = "Filter 4"
      }
      Filter05: =
      {
        txt = "&"
        hint = "Filter 5"
      }
    }
    filter_activator_name:form =
    {
      t_BaseFilter = !
      filtername: =
      {
        txt = "&"
        hint = "Filter Name"
      }
    }
    filter_activator_class:form =
    {
      t_BaseFilter = !
      filterclass: =
      {
        txt = "&"
        hint = "Filter Classname"
      }
    }
    filter_damage_type:form =
    {
      t_BaseFilter = !
      damagetype: =
      {
        txt = "&"
        hint = "Damage type"
        typ = "C"
        items = "GENERIC"$0D"CRUSH"$0D"BULLET"$0D"SLASH"$0D"BURN"$0D"FREEZE"$0D
         "FALL"$0D"BLAST"$0D"CLUB"$0D"SHOCK"$0D"SONIC"$0D"ENERGYBEAM"$0D"DROWN"
         $0D"PARALYSE"$0D"NERVEGAS"$0D"POISON"$0D"RADIATION"$0D"DROWNRECOVER"$0D
         "CHEMICAL"$0D"SLOWBURN"$0D"SLOWFREEZE"
        values = "0"$0D"1"$0D"2"$0D"4"$0D"8"$0D"16"$0D"32"$0D"64"$0D"128"$0D"2"
         "56"$0D"512"$0D"1024"$0D"16384"$0D"32768"$0D"65536"$0D"131072"$0D"262"
         "144"$0D"524288"$0D"1048576"$0D"2097152"$0D"4194304"
      }
    }
    point_anglesensor:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_EnableDisable = !
      target: =
      {
        txt = "&"
        hint = "Target Entity Name"
      }
      lookatname: =
      {
        txt = "&"
        hint = "Look At Entity"
      }
      duration: =
      {
        txt = "&"
        hint = "Duration"
      }
      tolerance: =
      {
        txt = "&"
        hint = "Tolerance"
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the sensor between enabled and disabled."
      }
      input#Test: =
      {
        txt = "&"
        hint = "Check to see if the Target Entity is facing the Look At Entity"
         " within the specified tolerance, firing either the OnFacingLookat or"
         " OnNotFacingLookat output based on the result."
      }
      output#TargetDir: =
      {
        txt = "&"
        hint = "Fired when the forward direction of the Target Entity changes."
         " Passes the new forward direction as a parameter."
      }
      output#OnFacingLookat: =
      {
        txt = "&"
        hint = "Fired when the Target Entity points at the Look At Entity for "
         "more than the specified Duration, or in response to a Test input."
      }
      output#OnNotFacingLookat: =
      {
        txt = "&"
        hint = "Fires in response to a Test input when the Target Entity is no"
         "t pointing at the Look At Entity."
      }
    }
    point_angularvelocitysensor:form =
    {
      t_Targetname = !
      target: =
      {
        txt = "&"
        hint = "Target Entity Name"
      }
      threshold: =
      {
        txt = "&"
        hint = "Threshold Velocity"
      }
      input#Test: =
      {
        txt = "&"
        hint = "Checks to see if the Target Entity's angular velocity meets or"
         " exceeds the Threshold Velocity, firing either the OnGreaterThanOrEq"
         "ualTo or OnLessThan output based on the result."
      }
      output#AngularVelocity: =
      {
        txt = "&"
        hint = "Fired when the Target's Angular Velocity changes, passing the "
         "new magnitude of the angular velocity."
      }
      output#OnGreaterThan: =
      {
        txt = "&"
        hint = "Fired when the Target Entity goes from slower than the thresho"
         "ld angular velocity to faster than the threshold angular velocity."
      }
      output#OnGreaterThanOrEqualTo: =
      {
        txt = "&"
        hint = "Fired when the Target Entity goes from slower than the thresho"
         "ld angular velocity to faster than the threshold angular velocity."
      }
      output#OnLessThan: =
      {
        txt = "&"
        hint = "Fired when the Target Entity goes from faster than the thresho"
         "ld angular velocity to slower than the threshold angular velocity."
      }
      output#OnLessThanOrEqualTo: =
      {
        txt = "&"
        hint = "Fired when the Target Entity goes from faster than the thresho"
         "ld angular velocity to slower than the threshold angular velocity."
      }
      output#OnEqualTo: =
      {
        txt = "&"
        hint = "Fired when the Target Entity reaches the threshold angular vel"
         "ocity from a different velocity."
      }
    }
    point_teleport:form =
    {
      t_Targetname = !
      t_Angles = !
      target: =
      {
        txt = "&"
        hint = "Entity To Teleport"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Teleport Home"
      }
      input#Teleport: =
      {
        txt = "&"
        hint = "Teleport the target entity."
      }
    }
    point_hurt:form =
    {
      t_Targetname = !
      DamageTarget: =
      {
        txt = "&"
        hint = "Target Entity"
      }
      DamageRadius: =
      {
        txt = "&"
        hint = "Radius"
      }
      Damage: =
      {
        txt = "&"
        hint = "Damage"
      }
      DamageDelay: =
      {
        txt = "&"
        hint = "Delay"
      }
      DamageType: =
      {
        txt = "&"
        hint = "Damage Type"
        typ = "C"
        items = "GENERIC"$0D"CRUSH"$0D"BULLET"$0D"SLASH"$0D"BURN"$0D"FREEZE"$0D
         "FALL"$0D"BLAST"$0D"CLUB"$0D"SHOCK"$0D"SONIC"$0D"ENERGYBEAM"$0D"DROWN"
         $0D"PARALYSE"$0D"NERVEGAS"$0D"POISON"$0D"RADIATION"$0D"DROWNRECOVER"$0D
         "CHEMICAL"$0D"SLOWBURN"$0D"SLOWFREEZE"
        values = "0"$0D"1"$0D"2"$0D"4"$0D"8"$0D"16"$0D"32"$0D"64"$0D"128"$0D"2"
         "56"$0D"512"$0D"1024"$0D"16384"$0D"32768"$0D"65536"$0D"131072"$0D"262"
         "144"$0D"524288"$0D"1048576"$0D"2097152"$0D"4194304"
      }
      input#Hurt: =
      {
        txt = "&"
        hint = "Force a single fire, damaging either the Target Entity or all "
         "entities within the radius."
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Enable this entity. It will start damaging entities everytime "
         "it fires, and refire based upon the specified Delay."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Disable this entity. It will stop damaging entities."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle this entity between On/Off state."
      }
    }
    point_playermoveconstraint:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      radius: =
      {
        txt = "&"
        hint = "Radius"
      }
      width: =
      {
        txt = "&"
        hint = "Constraint Width"
      }
      speedfactor: =
      {
        txt = "&"
        hint = "Speed Factor"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Start constraining any players within the radius."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Stop constraining any players previously constrained."
      }
      output#OnConstraintBroken: =
      {
        txt = "&"
        hint = "Fired when a player breaks through the constraint."
      }
    }

    func_physbox:form =
    {
      t_BreakableBrush = !
      t_Targetname = !
      t_Origin = !
      t_RenderFields = !
      t_Shadow = !
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4096"
        cap = "Start Asleep"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8192"
        cap = "Ignore +USE for Pickup"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16384"
        cap = "Debris - Don't collide with the player or other debris"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32768"
        cap = "Motion Disabled"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Use Preferred Carry Angles"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X131072"
        cap = "Enable motion on Physcannon grab"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X262144"
        cap = "Not affected by rotor wash"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X524288"
        cap = "Generate output on +USE "
      }
      Damagetype: =
      {
        txt = "&"
        hint = "Impact Damage Type"
        typ = "C"
        items = "Blunt"$0D"Sharp"
        values = "0"$0D"1"
      }
      massScale: =
      {
        txt = "&"
        hint = "Mass Scale"
      }
      overridescript: =
      {
        txt = "&"
        hint = "Override Parameters"
      }
      damagetoenablemotion: =
      {
        txt = "&"
        hint = "Health Level to Override Motion"
      }
      forcetoenablemotion: =
      {
        txt = "&"
        hint = "Physics Impact Force to Override Motion"
      }
      health: =
      {
        txt = "&"
        hint = "Strength"
      }
      preferredcarryangles: =
      {
        txt = "&"
        hint = "Preferred Player-carry Angles"
      }
      notsolid: =
      {
        txt = "&"
        hint = "Not solid to world"
        typ = "C"
        items = "Solid to World"$0D"Passes through World"
        values = "0"$0D"1"
      }
      input#Wake: =
      {
        txt = "&"
        hint = "Wake up this physics object, if it is sleeping."
      }
      input#Sleep: =
      {
        txt = "&"
        hint = "Put this physics object to sleep. It will wake if given the Wa"
         "ke input, or if force is applied to it. Note that physics objects go"
         " to sleep automatically after coming to rest for a while, so you don"
         "'t really need to use this."
      }
      input#EnableMotion: =
      {
        txt = "&"
        hint = "Enable physics motion/collision response."
      }
      input#DisableMotion: =
      {
        txt = "&"
        hint = "Disable physics motion/collision response."
      }
      input#ForceDrop: =
      {
        txt = "&"
        hint = "If this object is being carried by a player, with the physgun "
         "or +USE, force it to be dropped."
      }
      output#OnDamaged: =
      {
        txt = "&"
        hint = "Fired when this entity is damaged."
      }
      output#OnAwakened: =
      {
        txt = "&"
        hint = "Fired when this entity becomes awake (collision/force is appli"
         "ed)."
      }
      output#OnMotionEnabled: =
      {
        txt = "&"
        hint = "Fired when motion is enabled due to damage/physcannon/force."
      }
      output#OnPhysGunPickup: =
      {
        txt = "&"
        hint = "Fired when a player picks this object up, either with the phys"
         "gun or +USE."
      }
      output#OnPhysGunDrop: =
      {
        txt = "&"
        hint = "Fired when a player drops this object."
      }
      output#OnPlayerUse: =
      {
        txt = "&"
        hint = "Fired when the player tries to +USE the physbox. This output w"
         "ill fire only if the Generate output on +USE spawnflag is set."
      }
    }


    t_func_physbox:incl =
    {
      t_BreakableBrush = !
      t_Targetname = !
      t_Origin = !
      t_RenderFields = !
      t_Shadow = !
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4096"
        cap = "Start Asleep"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8192"
        cap = "Ignore +USE for Pickup"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16384"
        cap = "Debris - Don't collide with the player or other debris"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32768"
        cap = "Motion Disabled"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X65536"
        cap = "Use Preferred Carry Angles"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X131072"
        cap = "Enable motion on Physcannon grab"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X262144"
        cap = "Not affected by rotor wash"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X524288"
        cap = "Generate output on +USE "
      }
      Damagetype: =
      {
        txt = "&"
        hint = "Impact Damage Type"
        typ = "C"
        items = "Blunt"$0D"Sharp"
        values = "0"$0D"1"
      }
      massScale: =
      {
        txt = "&"
        hint = "Mass Scale"
      }
      overridescript: =
      {
        txt = "&"
        hint = "Override Parameters"
      }
      damagetoenablemotion: =
      {
        txt = "&"
        hint = "Health Level to Override Motion"
      }
      forcetoenablemotion: =
      {
        txt = "&"
        hint = "Physics Impact Force to Override Motion"
      }
      health: =
      {
        txt = "&"
        hint = "Strength"
      }
      preferredcarryangles: =
      {
        txt = "&"
        hint = "Preferred Player-carry Angles"
      }
      notsolid: =
      {
        txt = "&"
        hint = "Not solid to world"
        typ = "C"
        items = "Solid to World"$0D"Passes through World"
        values = "0"$0D"1"
      }
      input#Wake: =
      {
        txt = "&"
        hint = "Wake up this physics object, if it is sleeping."
      }
      input#Sleep: =
      {
        txt = "&"
        hint = "Put this physics object to sleep. It will wake if given the Wa"
         "ke input, or if force is applied to it. Note that physics objects go"
         " to sleep automatically after coming to rest for a while, so you don"
         "'t really need to use this."
      }
      input#EnableMotion: =
      {
        txt = "&"
        hint = "Enable physics motion/collision response."
      }
      input#DisableMotion: =
      {
        txt = "&"
        hint = "Disable physics motion/collision response."
      }
      input#ForceDrop: =
      {
        txt = "&"
        hint = "If this object is being carried by a player, with the physgun "
         "or +USE, force it to be dropped."
      }
      output#OnDamaged: =
      {
        txt = "&"
        hint = "Fired when this entity is damaged."
      }
      output#OnAwakened: =
      {
        txt = "&"
        hint = "Fired when this entity becomes awake (collision/force is appli"
         "ed)."
      }
      output#OnMotionEnabled: =
      {
        txt = "&"
        hint = "Fired when motion is enabled due to damage/physcannon/force."
      }
      output#OnPhysGunPickup: =
      {
        txt = "&"
        hint = "Fired when a player picks this object up, either with the phys"
         "gun or +USE."
      }
      output#OnPhysGunDrop: =
      {
        txt = "&"
        hint = "Fired when a player drops this object."
      }
      output#OnPlayerUse: =
      {
        txt = "&"
        hint = "Fired when the player tries to +USE the physbox. This output w"
         "ill fire only if the Generate output on +USE spawnflag is set."
      }
    }


    t_TwoObjectPhysics:incl =
    {
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Collision until break"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Start inactive"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Change mass to keep stable attachment to world"
      }
      attach1: =
      {
        txt = "&"
        hint = "Entity 1"
      }
      attach2: =
      {
        txt = "&"
        hint = "Entity 2"
      }
      constraintsystem: =
      {
        txt = "&"
        hint = "Constraint System Manager"
      }
      forcelimit: =
      {
        txt = "&"
        hint = "Force Limit to Break (lbs)"
      }
      torquelimit: =
      {
        txt = "&"
        hint = "Torque Limit to Break (lbs * distance)"
      }
      breaksound: =
      {
        txt = "&"
        hint = "Play Sound on Break"
      }
      input#Break: =
      {
        txt = "&"
        hint = "Force the constraint to break."
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Enable the constraint.  Do this when the objects don't exist w"
         "hen the constraint spawns - or when you have deactivated the constra"
         "int.  Broken constraints can NOT be turned on.  They have been delet"
         "ed."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Disable this constraint."
      }
      output#OnBreak: =
      {
        txt = "&"
        hint = "Fired when the constraint breaks."
      }
    }
    phys_constraintsystem:form =
    {
      t_Targetname = !
      additionaliterations: =
      {
        txt = "&"
        hint = "Additional System Iterations"
      }
    }
    phys_keepupright:form =
    {
      t_Targetname = !
      t_Angles = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start inactive"
      }
      attach1: =
      {
        txt = "&"
        hint = "Target Entity"
      }
      angularlimit: =
      {
        txt = "&"
        hint = "Angular Limit"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Enable the controller."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Disable the controller."
      }
    }
    physics_cannister:form =
    {
      t_Targetname = !
      t_Angles = !
      t_modelselect = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start Asleep"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Explodes"
      }
      expdamage: =
      {
        txt = "&"
        hint = "Explosion Damage"
      }
      expradius: =
      {
        txt = "&"
        hint = "Explosion Radius"
      }
      health: =
      {
        txt = "&"
        hint = "Health"
      }
      thrust: =
      {
        txt = "&"
        hint = "Thrust"
      }
      fuel: =
      {
        txt = "&"
        hint = "Fuel Seconds"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Smoke Color (R G B)"
      }
      rendercolor: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Smoke Color (R G B)"
      }
      renderamt: =
      {
        txt = "&"
        hint = "Smoke Alpha (0 - 255)"
      }
      gassound: =
      {
        txt = "&"
        hint = "Thruster Sound"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Start gas escaping from the cannister."
      }
      input#Deactivate: =
      {
        txt = "&"
        hint = "Stop gas escaping from the cannister."
      }
      input#Explode: =
      {
        txt = "&"
        hint = "Force the cannister to explode."
      }
      input#Wake: =
      {
        txt = "&"
        hint = "Wakes up the cannister, if it is sleeping."
      }
      output#OnActivate: =
      {
        txt = "&"
        hint = "Fired when gas starts to escape from the cannister."
      }
    }
    info_constraint_anchor:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      t_Targetname = !
      t_Parentname = !
      massScale: =
      {
        txt = "&"
        hint = "Amount to scale the mass of this body in the constraint solver"
      }
    }
    info_mass_center:form =
    {
      bbox = '-4 -4 -4 4 4 4'
      target: =
      {
        txt = "&"
        hint = "Target object"
      }
    }
    phys_spring:form =
    {
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Force only on stretch"
      }
      attach1: =
      {
        txt = "&"
        hint = "Entity 1"
      }
      attach2: =
      {
        txt = "&"
        hint = "Entity 2"
      }
      springaxis: =
      {
        txt = "&"
        hint = "Spring Axis"
      }
      length: =
      {
        txt = "&"
        hint = "Spring Length"
      }
      constant: =
      {
        txt = "&"
        hint = "Spring Constant"
      }
      damping: =
      {
        txt = "&"
        hint = "Damping Constant"
      }
      relativedamping: =
      {
        txt = "&"
        hint = "Relative Damping Constant"
      }
      breaklength: =
      {
        txt = "&"
        hint = "Break on Length"
      }
      input#SetSpringConstant: =
      {
        txt = "&"
        hint = "Set the Spring Constant."
      }
      input#SetSpringLength: =
      {
        txt = "&"
        hint = "Set the Spring Length."
      }
      input#SetSpringDamping: =
      {
        txt = "&"
        hint = "Set the Spring Damping."
      }
    }
    phys_hinge:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_TwoObjectPhysics = !
      hingefriction: =
      {
        txt = "&"
        hint = "Friction"
      }
      hingeaxis: =
      {
        txt = "&"
        hint = "Hinge Axis"
      }
      SystemLoadScale: =
      {
        txt = "&"
        hint = "Load Scale"
      }
      input#SetAngularVelocity: =
      {
        txt = "&"
        hint = "Set angular velocity around the hinge (motor)"
      }
    }
    phys_ballsocket:form =
    {
      t_TwoObjectPhysics = !
    }
    phys_constraint:form =
    {
      t_TwoObjectPhysics = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Collision until break"
      }
    }
    phys_pulleyconstraint:form =
    {
      t_TwoObjectPhysics = !
      addlength: =
      {
        txt = "&"
        hint = "Additional Length"
      }
      gearratio: =
      {
        txt = "&"
        hint = "Pulley Gear Ratio"
      }
      position2: =
      {
        txt = "&"
        hint = "Pulley Position 2"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Collision until break"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Keep Rigid"
      }
    }
    phys_slideconstraint:form =
    {
      t_TwoObjectPhysics = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Collision until break"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Limit Endpoints"
      }
      slideaxis: =
      {
        txt = "&"
        hint = "Sliding Axis"
      }
      slidefriction: =
      {
        txt = "&"
        hint = "Friction"
      }
      SystemLoadScale: =
      {
        txt = "&"
        hint = "Load Scale"
      }
      input#SetVelocity: =
      {
        txt = "&"
        hint = "Set linear velocity along the constraint"
      }
    }
    phys_lengthconstraint:form =
    {
      t_TwoObjectPhysics = !
      addlength: =
      {
        txt = "&"
        hint = "Additional Length"
      }
      minlength: =
      {
        txt = "&"
        hint = "Minimum Length"
      }
      attachpoint: =
      {
        txt = "&"
        hint = "Attached object 2 point"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Collision until break"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Keep Rigid"
      }
    }
    phys_ragdollconstraint:form =
    {
      t_TwoObjectPhysics = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Collision until break"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Only limit rotation (free movement)"
      }
      xmin: =
      {
        txt = "&"
        hint = "X axis min limit"
      }
      xmax: =
      {
        txt = "&"
        hint = "X axis max limit"
      }
      ymin: =
      {
        txt = "&"
        hint = "Y axis min limit"
      }
      ymax: =
      {
        txt = "&"
        hint = "Y axis max limit"
      }
      zmin: =
      {
        txt = "&"
        hint = "Z axis min limit"
      }
      zmax: =
      {
        txt = "&"
        hint = "Z axis max limit"
      }
      xfriction: =
      {
        txt = "&"
        hint = "X axis friction"
      }
      yfriction: =
      {
        txt = "&"
        hint = "Y axis friction"
      }
      zfriction: =
      {
        txt = "&"
        hint = "Z axis friction"
      }
    }
    phys_convert:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Convert Asleep"
      }
      target: =
      {
        txt = "&"
        hint = "Entity to convert"
      }
      swapmodel: =
      {
        txt = "&"
        hint = "Model Swap Entity"
      }
      output#OnConvert: =
      {
        txt = "&"
        hint = "Fires after the conversion has taken place."
      }
      input#ConvertTarget: =
      {
        txt = "&"
        hint = "Converts this entity's target to a physically simulated object"
         "."
      }
    }
    t_ForceController:incl =
    {
      t_Targetname = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start On"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Apply Force"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Apply Torque"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Orient Locally"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Ignore Mass"
      }
      attach1: =
      {
        txt = "&"
        hint = "Attached Object"
      }
      forcetime: =
      {
        txt = "&"
        hint = "Time of Force (0=inf)"
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Turn the force on"
      }
      input#Deactivate: =
      {
        txt = "&"
        hint = "Turn the force off"
      }
      input#Scale: =
      {
        txt = "&"
        hint = "Set Force Scale"
      }
    }
    phys_thruster:form =
    {
      t_Angles = !
      t_ForceController = !
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Ignore Pos"
      }
      force: =
      {
        txt = "&"
        hint = "Force"
      }
    }
    phys_torque:form =
    {
      t_ForceController = !
      force: =
      {
        txt = "&"
        hint = "Angular Acceleration"
      }
      axis: =
      {
        txt = "&"
        hint = "Rotation Axis"
      }
    }
    phys_motor:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      speed: =
      {
        txt = "&"
        hint = "Rotation Speed"
      }
      spinup: =
      {
        txt = "&"
        hint = "Spin up time"
      }
      inertiafactor: =
      {
        txt = "&"
        hint = "System Interia Scale"
      }
      axis: =
      {
        txt = "&"
        hint = "Rotation Axis"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start On"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "No world collision"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Hinge Object"
      }
      attach1: =
      {
        txt = "&"
        hint = "Attached Object"
      }
      input#SetSpeed: =
      {
        txt = "&"
        hint = "Sets target speed"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turns motor on"
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Turns motor off"
      }
    }
    phys_magnet:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      t_Studiomodel = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start Asleep"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Motion Disabled"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Suck On Touch"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Allow Attached Rotation"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Coast jeep pickup hack"
      }
      forcelimit: =
      {
        txt = "&"
        hint = "Force Limit to Break (lbs)"
      }
      torquelimit: =
      {
        txt = "&"
        hint = "Torque Limit to Break (lbs * distance)"
      }
      massScale: =
      {
        txt = "&"
        hint = "Mass Scale"
      }
      overridescript: =
      {
        txt = "&"
        hint = "Override parameters"
      }
      maxobjects: =
      {
        txt = "&"
        hint = "Maximum Attached Objects"
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Turn the magnet on."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "The the magnet off. This will detach anything current stuck to"
         " the magnet."
      }
      output#OnAttach: =
      {
        txt = "&"
        hint = "Fired when an entity is grabbed by the magnet."
      }
      output#OnDetach: =
      {
        txt = "&"
        hint = "Fired when an entity is released by the magnet."
      }
    }
    t_prop_detail_base:incl =
    {
      model: =
      {
        txt = "&"
        hint = "World model"
        typ = "B"
        Cap = "models..."
        form = "t_models_hl2_form:form"
      }
    }
    t_prop_static_base:incl =
    {
      t_Angles = !
      t_DXLevelChoice = !
      t_modelselect = !
      skin: =
      {
        txt = "&"
        hint = "Skin"
      }
      solid: =
      {
        txt = "&"
        hint = "Collisions"
        typ = "C"
        items = "Not Solid"$0D"Use Bounding Box"$0D"Use VPhysics"
        values = "0"$0D"2"$0D"6"
      }
      disableshadows: =
      {
        txt = "&"
        hint = "Disable Shadows"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      screenspacefade: =
      {
        txt = "&"
        hint = "Screen Space Fade"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      fademindist: =
      {
        txt = "&"
        hint = "Start Fade Dist/Pixels"
      }
      fademaxdist: =
      {
        txt = "&"
        hint = "End Fade Dist/Pixels"
      }
      fadescale: =
      {
        txt = "&"
        hint = "Fade Scale"
      }
      lightingorigin: =
      {
        txt = "&"
        hint = "Lighting Origin"
      }
    }
    t_prop_dynamic_base:incl =
    {
      t_Parentname = !
      t_Global = !
      t_Angles = !
      t_Studiomodel = !
      t_BreakableProp = !
      t_DXLevelChoice = !
      solid: =
      {
        txt = "&"
        hint = "Collisions"
        typ = "C"
        items = "Not Solid"$0D"Use Bounding Box"$0D"Use VPhysics"
        values = "0"$0D"2"$0D"6"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Use Hitboxes for Renderbox"
      }
      DefaultAnim: =
      {
        txt = "&"
        hint = "Default Animation"
      }
      RandomAnimation: =
      {
        txt = "&"
        hint = "Randomly Animate"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      MinAnimTime: =
      {
        txt = "&"
        hint = "Min Random Anim Time"
      }
      MaxAnimTime: =
      {
        txt = "&"
        hint = "Max Random Anim Time"
      }
      SetBodyGroup: =
      {
        txt = "&"
        hint = "Body Group"
      }
      fademindist: =
      {
        txt = "&"
        hint = "Start Fade Dist"
      }
      fademaxdist: =
      {
        txt = "&"
        hint = "End Fade Dist"
      }
      fadescale: =
      {
        txt = "&"
        hint = "Fade Scale"
      }
      input#SetAnimation: =
      {
        txt = "&"
        hint = "Force the prop to play an animation. The parameter should be t"
         "he name of the animation."
      }
      input#SetDefaultAnimation: =
      {
        txt = "&"
        hint = "Set the Default Animation to the one specified in the paramete"
         "r."
      }
      input#SetBodyGroup: =
      {
        txt = "&"
        hint = "Set the visible bodygroup, by index."
      }
      input#TurnOn: =
      {
        txt = "&"
        hint = "Make the prop visible."
      }
      input#TurnOff: =
      {
        txt = "&"
        hint = "Make the prop invisible."
      }
      output#OnAnimationBegun: =
      {
        txt = "&"
        hint = "Fired whenever a new animation has begun playing."
      }
      output#OnAnimationDone: =
      {
        txt = "&"
        hint = "Fired whenever an animation is complete."
      }
    }
    prop_detail:form =
    {
      t_prop_detail_base = !
      t_modelselect = !
    }
    prop_static:form =
    {
      t_prop_static_base = !
    }
    prop_dynamic:form =
    {
      t_prop_dynamic_base = !
      t_EnableDisable = !
    }
    prop_dynamic_override:form =
    {
      t_prop_dynamic_base = !
      health: =
      {
        txt = "&"
        hint = "Health"
      }
    }
    t_BasePropPhysics:incl =
    {
      t_Targetname = !
      t_Global = !
      t_Angles = !
      t_Studiomodel = !
      t_BreakableProp = !
      t_DXLevelChoice = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Start Asleep"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Don't take physics damage"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Debris - Don't collide with the player or other debris"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Motion Disabled"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "Enable motion on Physcannon grab"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Not affected by rotor wash"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Generate output on +USE "
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Prevent pickup"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1024"
        cap = "Prevent motion enable on player bump"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4096"
        cap = "Debris with trigger interaction"
      }
      minhealthdmg: =
      {
        txt = "&"
        hint = "Min Damage to Hurt"
      }
      shadowcastdist: =
      {
        txt = "&"
        hint = "Shadow Cast Distance"
      }
      physdamagescale: =
      {
        txt = "&"
        hint = "Physics Impact Damage Scale"
      }
      Damagetype: =
      {
        txt = "&"
        hint = "Impact damage type"
        typ = "C"
        items = "Blunt"$0D"Sharp"
        values = "0"$0D"1"
      }
      nodamageforces: =
      {
        txt = "&"
        hint = "Damaging it Doesn't Push It"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
      inertiaScale: =
      {
        txt = "&"
        hint = "Scale Factor For Inertia"
      }
      massScale: =
      {
        txt = "&"
        hint = "Mass Scale"
      }
      overridescript: =
      {
        txt = "&"
        hint = "Override Parameters"
      }
      damagetoenablemotion: =
      {
        txt = "&"
        hint = "Health Level to Override Motion"
      }
      forcetoenablemotion: =
      {
        txt = "&"
        hint = "Physics Impact Force to Override Motion"
      }
      fademindist: =
      {
        txt = "&"
        hint = "Start Fade Dist"
      }
      fademaxdist: =
      {
        txt = "&"
        hint = "End Fade Dist"
      }
      fadescale: =
      {
        txt = "&"
        hint = "fade scale"
      }
      input#Wake: =
      {
        txt = "&"
        hint = "Wake up this physics object, if it is sleeping."
      }
      input#Sleep: =
      {
        txt = "&"
        hint = "Put this physics object to sleep. It will wake if given the Wa"
         "ke input, or if force is applied to it. Note that physics objects go"
         " to sleep automatically after coming to rest for a while, so you don"
         "'t really need to use this."
      }
      input#EnableMotion: =
      {
        txt = "&"
        hint = "Enable physics motion/collision response."
      }
      input#DisableMotion: =
      {
        txt = "&"
        hint = "Disable physics motion/collision response."
      }
      input#DisableFloating: =
      {
        txt = "&"
        hint = "Disable fluid/floating simulation to reduce cost."
      }
      input#SetBodyGroup: =
      {
        txt = "&"
        hint = "Set this prop's body group (from 0 - n)."
      }
      input#physdamagescale: =
      {
        txt = "&"
        hint = "Set the Physics Impact Damage Scale for this character. NOTE: "
         "0 means this feature is disabled for backwards compatibility."
      }
      input#EnableDamageForces: =
      {
        txt = "&"
        hint = "Damaging the entity applies physics forces to it."
      }
      input#DisableDamageForces: =
      {
        txt = "&"
        hint = "Damaging the entity does *not* apply physics forces to it."
      }
      output#OnMotionEnabled: =
      {
        txt = "&"
        hint = "Fired when motion is enabled on this prop, either via 'Health "
         "Level to Override Motion' or from the EnableMotion input."
      }
      output#OnAwakened: =
      {
        txt = "&"
        hint = "Fired when this entity becomes awake (collision/force is appli"
         "ed to it while it's asleep)."
      }
      output#OnPhysGunPickup: =
      {
        txt = "&"
        hint = "Fired when the player picks up the prop with the physcannon or"
         " +USE."
      }
      output#OnPhysGunDrop: =
      {
        txt = "&"
        hint = "Fired when the player drops the prop with the physcannon or US"
         "E."
      }
      output#OnPlayerUse: =
      {
        txt = "&"
        hint = "Fired when the player tries to +USE the physbox. This output w"
         "ill fire only if the Generate output on +USE spawnflag is set."
      }
    }
    prop_physics_override:form =
    {
      t_BasePropPhysics = !
      health: =
      {
        txt = "&"
        hint = "Health"
      }
      input#Ignite: =
      {
        txt = "&"
        hint = "Ignite, burst into flames."
      }
    }

    prop_physics:form =
    {
      t_BasePropPhysics = !
      input#Ignite: =
      {
        txt = "&"
        hint = "Ignite, burst into flames."
      }
    }

    t_prop_physics:incl =
    {
      t_BasePropPhysics = !
      input#Ignite: =
      {
        txt = "&"
        hint = "Ignite, burst into flames."
      }
    }
    prop_physics_multiplayer:form =
    {
      t_prop_physics = !
    }
    prop_ragdoll:form =
    {
      t_Angles = !
      t_Targetname = !
      t_Studiomodel = !
      t_DXLevelChoice = !
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Debris - Don't collide with the player or other debris"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8192"
        cap = "Allow Dissolve"
      }
      angleOverride: =
      {
        txt = "&"
        hint = "Override Animation"
      }
      fademindist: =
      {
        txt = "&"
        hint = "Start Fade Dist"
      }
      fademaxdist: =
      {
        txt = "&"
        hint = "End Fade Dist"
      }
      fadescale: =
      {
        txt = "&"
        hint = "fade scale"
      }
    }
    prop_dynamic_ornament:form =
    {
      t_prop_dynamic_base = !
      solid: =
      {
        txt = "&"
        hint = "Collisions"
        typ = "C"
        items = "Not Solid"
        values = "0"
      }
      InitialOwner: =
      {
        txt = "&"
        hint = "Target Entity"
      }
      input#SetAttached: =
      {
        txt = "&"
        hint = "Attach the ornament to a different entity. Parameter should be"
         " the name of entity to attach to."
      }
      input#Detach: =
      {
        txt = "&"
        hint = "Detach from the Target Entity and become invisible. The orname"
         "nt can be re-attached with the SetAttached input."
      }
    }
    func_areaportal:form =
    {
      t_Targetname = !
      target: =
      {
        txt = "&"
        hint = "Name of Linked Door"
      }
      StartOpen: =
      {
        txt = "&"
        hint = "Initial State"
        typ = "C"
        items = "Closed"$0D"Open"
        values = "0"$0D"1"
      }
      input#Open: =
      {
        txt = "&"
        hint = "Open the portal. When the portal is open is can be seen throug"
         "h."
      }
      input#Close: =
      {
        txt = "&"
        hint = "Close the portal. When the portal is closed it cannot be seen "
         "through."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the open/closed state of the portal."
      }
    }
    func_occluder:form =
    {
      t_Targetname = !
      StartActive: =
      {
        txt = "&"
        hint = "Initial State"
        typ = "C"
        items = "Inactive"$0D"Active"
        values = "0"$0D"1"
      }
      input#Deactivate: =
      {
        txt = "&"
        hint = "Deactivate the occluder, When inactive, it can be seen through"
         "."
      }
      input#Activate: =
      {
        txt = "&"
        hint = "Activate the occluder. When active, it cannot be seen through."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the active/inactive state of the occluder."
      }
    }
    func_breakable:form =
    {
      t_BreakableBrush = !
      t_Origin = !
      t_RenderFields = !
      t_Shadow = !
      minhealthdmg: =
      {
        txt = "&"
        hint = "Min Damage to Hurt"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      physdamagescale: =
      {
        txt = "&"
        hint = "Physics Impact Damage Scale"
      }
    }
    func_breakable_surf:form =
    {
      t_BreakableBrush = !
      t_RenderFields = !
      t_Shadow = !
      health: =
      {
        txt = "&"
        hint = "Health"
      }
      fragility: =
      {
        txt = "&"
        hint = "Fragility"
      }
      upperleft: = {txt = "&" hint = "corner for positioning of broken glass"}
      upperright: = {txt = "&" hint = "corner for positioning of broken glass"}
      lowerright: = {txt = "&" hint = "corner for positioning of broken glass"}
      lowerleft: = {txt = "&" hint = "corner for positioning of broken glass"}
      surfacetype: =
      {
        txt = "&"
        hint = "Surface Type"
        typ = "C"
        items = "Glass"$0D"Tile"
        values = "0"$0D"1"
      }
      input#Shatter: =
      {
        txt = "&"
        hint = "Shatter the window. Input a vector. First two coordinates are "
         "the X,Y center of the shattering (as values from from 0-1). The thir"
         "d coordinate is the radius of the shatter, in inches."
      }
    }
    func_conveyor:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_RenderFields = !
      t_Shadow = !
      movedir: =
      {
        txt = "&"
        hint = "Move Direction (Pitch Yaw Roll)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Push"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Not Solid"
      }
      speed: =
      {
        txt = "&"
        hint = "Conveyor Speed"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      input#ToggleDirection: =
      {
        txt = "&"
        hint = "ToggleDirection"
      }
      input#SetSpeed: =
      {
        txt = "&"
        hint = "SetSpeed"
      }
    }
    func_detail:form =
    {
      t_DXLevelChoice = !
    }
    func_illusionary:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_RenderFields = !
      t_Shadow = !
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
    }
    func_precipitation:form =
    {
      t_Targetname = !
      t_Parentname = !
      renderamt: =
      {
        txt = "&"
        hint = "Density (0-100%)"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "Color (R G B)"
      }
      rendercolor: =
      {
        Txt = "&"
        Typ = "LU3"
        Hint = "Color (R G B)"
      }
      preciptype: =
      {
        txt = "&"
        hint = "Precipitation Type"
        typ = "C"
        items = "Rain"$0D"Snow"
        values = "0"$0D"1"
      }
    }
    func_wall_toggle:form =
    {
      t_func_wall = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Starts Invisible"
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the brush on/off. When off, the brush will be non-solid"
         " and invisible."
      }
    }
    func_guntarget:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_RenderFields = !
      t_Global = !
      speed: =
      {
        txt = "&"
        hint = "Speed (units per second)"
      }
      target: =
      {
        txt = "&"
        hint = "First stop target"
      }
      health: =
      {
        txt = "&"
        hint = "Damage to Take"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      input#Start: =
      {
        txt = "&"
        hint = "Start the target moving."
      }
      input#Stop: =
      {
        txt = "&"
        hint = "Stop the target from moving."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the target between moving and stopped."
      }
      output#OnDeath: =
      {
        txt = "&"
        hint = "Fires when the target is killed."
      }
    }
    t_PlatSounds:incl =
    {
      movesnd: =
      {
        txt = "&"
        hint = "Move Sound"
        typ = "C"
        items = "No Sound"$0D"big elev 1"$0D"big elev 2"$0D"tech elev 1"$0D"te"
         "ch elev 2"$0D"tech elev 3"$0D"freight elev 1"$0D"freight elev 2"$0D"h"
         "eavy elev"$0D"rack elev"$0D"rail elev"$0D"squeek elev"$0D"odd elev 1"
         $0D"odd elev 2"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"$0D"9"$0D"1"
         "0"$0D"11"$0D"12"$0D"13"
      }
      stopsnd: =
      {
        txt = "&"
        hint = "Stop Sound"
        typ = "C"
        items = "No Sound"$0D"big elev stop1"$0D"big elev stop2"$0D"freight el"
         "ev stop"$0D"heavy elev stop"$0D"rack stop"$0D"rail stop"$0D"squeek s"
         "top"$0D"quick stop"
        values = "0"$0D"1"$0D"2"$0D"3"$0D"4"$0D"5"$0D"6"$0D"7"$0D"8"
      }
      volume: =
      {
        txt = "&"
        hint = "Sound Volume 0.0 - 1.0"
      }
    }
    t_Trackchange:incl =
    {
      t_Targetname = !
      t_Parentname = !
      t_RenderFields = !
      t_Global = !
      t_PlatSounds = !
      height: =
      {
        txt = "&"
        hint = "Travel Altitude"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Auto Activate train"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Relink track"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Start at Bottom"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Rotate Only"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X64"
        cap = "X Axis"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Y Axis"
      }
      rotation: =
      {
        txt = "&"
        hint = "Spin amount"
      }
      train: =
      {
        txt = "&"
        hint = "Train to Switch"
      }
      toptrack: =
      {
        txt = "&"
        hint = "Top Track"
      }
      bottomtrack: =
      {
        txt = "&"
        hint = "Bottom Track"
      }
      speed: =
      {
        txt = "&"
        hint = "Move/Rotate Speed"
      }
    }
    t_BaseTrain:incl =
    {
      t_Targetname = !
      t_Parentname = !
      t_Origin = !
      t_RenderFields = !
      t_Global = !
      t_Shadow = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "No Pitch (X-rot)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "No User Control"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Passable"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Fixed Orientation"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "HL1 Train"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Use max peed for pitch shifting move sound"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X512"
        cap = "Is unblockable by player"
      }
      target: =
      {
        txt = "&"
        hint = "First Stop Target"
      }
      startspeed: =
      {
        txt = "&"
        hint = "Max Speed (units / second)"
      }
      speed: =
      {
        txt = "&"
        hint = "Initial Speed (units / second)"
      }
      velocitytype: =
      {
        txt = "&"
        hint = "Change Velocity"
        typ = "C"
        items = "Instantaneously"$0D"Linear blend"$0D"Ease in/ease out"
        values = "0"$0D"1"$0D"2"
      }
      orientationtype: =
      {
        txt = "&"
        hint = "Change angles"
        typ = "C"
        items = "Never (fixed orientation)"$0D"Near path_tracks"$0D"Linear ble"
         "nd"$0D"Ease in/ease out"
        values = "0"$0D"1"$0D"2"$0D"3"
      }
      wheels: =
      {
        txt = "&"
        hint = "Distance Between the Wheels"
      }
      height: =
      {
        txt = "&"
        hint = "Height above track"
      }
      bank: =
      {
        txt = "&"
        hint = "Bank Angle on Turns"
      }
      dmg: =
      {
        txt = "&"
        hint = "Damage on Crush"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      MoveSound: =
      {
        txt = "&"
        hint = "Move Sound"
      }
      MovePingSound: =
      {
        txt = "&"
        hint = "Move Ping Sound"
      }
      StartSound: =
      {
        txt = "&"
        hint = "Start Sound"
      }
      StopSound: =
      {
        txt = "&"
        hint = "Stop Sound"
      }
      volume: =
      {
        txt = "&"
        hint = "Volume (10 = loudest)"
      }
      MoveSoundMinPitch: =
      {
        txt = "&"
        hint = "Min pitch (1-255, > 100 = higher)"
      }
      MoveSoundMaxPitch: =
      {
        txt = "&"
        hint = "Max pitch (1-255, > 100 = higher)"
      }
      MoveSoundMinTime: =
      {
        txt = "&"
        hint = "Min move sound interval"
      }
      MoveSoundMaxTime: =
      {
        txt = "&"
        hint = "Max move sound interval"
      }
      input#SetSpeed: =
      {
        txt = "&"
        hint = "Set the speed of the train, as a ratio of max speed [0, 1]"
      }
      input#SetSpeedDir: =
      {
        txt = "&"
        hint = "Set the speed of the train, as a ratio of max speed. Negative "
         "values reverse the direction [-1, 1]"
      }
      input#SetSpeedReal: =
      {
        txt = "&"
        hint = "Set the speed of the train. Must be a positive value from 0 to"
         " max speed."
      }
      input#Stop: =
      {
        txt = "&"
        hint = "Stop the train."
      }
      input#StartForward: =
      {
        txt = "&"
        hint = "Start the train moving forward."
      }
      input#StartBackward: =
      {
        txt = "&"
        hint = "Start the train moving backward."
      }
      input#Resume: =
      {
        txt = "&"
        hint = "Resume the train moving in the current direction after it was "
         "stopped via the 'Stop' or 'Toggle' input."
      }
      input#Reverse: =
      {
        txt = "&"
        hint = "Reverse the direction of the train."
      }
      input#Toggle: =
      {
        txt = "&"
        hint = "Toggle the train between start and stop."
      }
    }
    func_trackautochange:form =
    {
      t_Trackchange = !
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
      input#Trigger: =
      {
        txt = "&"
        hint = "Trigger the track change."
      }
    }
    func_trackchange:form =
    {
      t_Trackchange = !
      _minlight: =
      {
        txt = "&"
        hint = "Minimum Light Level"
      }
    }
    func_tracktrain:form =
    {
      t_BaseTrain = !
    }
    func_tanktrain:form =
    {
      t_BaseTrain = !
      health: =
      {
        txt = "&"
        hint = "Health"
      }
      output#OnDeath: =
      {
        txt = "&"
        hint = "Fired when the tank is killed."
      }
    }
    func_traincontrols:form =
    {
      t_Parentname = !
      t_Global = !
      target: =
      {
        txt = "&"
        hint = "Train Name"
      }
    }
    tanktrain_aitarget:form =
    {
      t_Targetname = !
      target: =
      {
        txt = "&"
        hint = "Tank AI Entity"
      }
      newtarget: =
      {
        txt = "&"
        hint = "New Target Entity"
      }
    }
    tanktrain_ai:form =
    {
      t_Targetname = !
      target: =
      {
        txt = "&"
        hint = "Train Name"
      }
      startsound: =
      {
        txt = "&"
        hint = "Start Moving Sound"
      }
      enginesound: =
      {
        txt = "&"
        hint = "Engine Loop Sound"
      }
      movementsound: =
      {
        txt = "&"
        hint = "Vehicle Movement Sound"
      }
    }
    path_track:form =
    {
      t_Targetname = !
      t_Parentname = !
      t_Angles = !
      spawnflags: =
      {
        txt = "&"
        typ = "X1"
        cap = "Disabled"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Fire once"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "Branch Reverse"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X8"
        cap = "Disable train"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "Teleport to THIS path track"
      }
      target: =
      {
        txt = "&"
        hint = "Next Stop Target"
      }
      altpath: =
      {
        txt = "&"
        hint = "Branch Path"
      }
      speed: =
      {
        txt = "&"
        hint = "New Train Speed"
      }
      radius: =
      {
        txt = "&"
        hint = "Path radius"
      }
      orientationtype: =
      {
        txt = "&"
        hint = "Orientation Type"
        typ = "C"
        items = "No change"$0D"Face direction of motion"$0D"Face this path_tra"
         "ck's angles"
        values = "0"$0D"1"$0D"2"
      }
      input#ToggleAlternatePath: =
      {
        txt = "&"
        hint = "Cause the track to toggle to/from its alternate path."
      }
      input#EnableAlternatePath: =
      {
        txt = "&"
        hint = "Enable the alternate path of the track."
      }
      input#DisableAlternatePath: =
      {
        txt = "&"
        hint = "Disable the alternate path of the track."
      }
      input#TogglePath: =
      {
        txt = "&"
        hint = "Cause the track to toggle on/off/"
      }
      input#EnablePath: =
      {
        txt = "&"
        hint = "Enable the track."
      }
      input#DisablePath: =
      {
        txt = "&"
        hint = "Disable the track."
      }
      output#OnPass: =
      {
        txt = "&"
        hint = "Fired when any entity following this path passes this path_tra"
         "ck node."
      }
    }
    test_traceline:form =
    {
      bbox = '-16 -16 -16 16 16 16'
      t_Angles = !
    }
    trigger_autosave:form =
    {
      t_Targetname = !
      master: =
      {
        txt = "&"
        hint = "Master"
      }
      NewLevelUnit: =
      {
        txt = "&"
        hint = "Force New Level Unit"
        typ = "C"
        items = "No"$0D"Yes"
        values = "0"$0D"1"
      }
    }
    trigger_changelevel:form =
    {
      targetname: =
      {
        txt = "&"
        hint = "Name"
      }
      map: =
      {
        txt = "&"
        hint = "New Map Name"
      }
      landmark: =
      {
        txt = "&"
        hint = "Landmark Name"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X2"
        cap = "Disable Touch"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X4"
        cap = "To Previous Chapter"
      }
      input#ChangeLevel: =
      {
        txt = "&"
        hint = "Cause the level change. Use this when triggering the level cha"
         "nge with a button, etc."
      }
      output#OnChangeLevel: =
      {
        txt = "&"
        hint = "Fired when the level changes."
      }
    }
    trigger_gravity:form =
    {
      t_Trigger = !
      gravity: =
      {
        txt = "&"
        hint = "Gravity (0-1)"
      }
    }
    trigger_playermovement:form =
    {
      t_Trigger = !
      spawnflags: =
      {
        txt = "&"
        typ = "X16"
        cap = "(OBSOLETE, Uncheck me)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Disable auto player movement"
      }
    }
    trigger_soundscape:form =
    {
      t_Trigger = !
      soundscape: =
      {
        txt = "&"
        hint = "Soundscape"
      }
    }
    trigger_hurt:form =
    {
      t_Trigger = !
      t_Targetname = !
      master: =
      {
        txt = "&"
        hint = "Master (Obsolete)"
      }
      damage: =
      {
        txt = "&"
        hint = "Damage"
      }
      damagecap: =
      {
        txt = "&"
        hint = "Damage Cap"
      }
      damagetype: =
      {
        txt = "&"
        hint = "Damage Type"
        typ = "C"
        items = "GENERIC"$0D"CRUSH"$0D"BULLET"$0D"SLASH"$0D"BURN"$0D"FREEZE"$0D
         "FALL"$0D"BLAST"$0D"CLUB"$0D"SHOCK"$0D"SONIC"$0D"ENERGYBEAM"$0D"DROWN"
         $0D"PARALYSE"$0D"NERVEGAS"$0D"POISON"$0D"RADIATION"$0D"DROWNRECOVER"$0D
         "CHEMICAL"$0D"SLOWBURN"$0D"SLOWFREEZE"
        values = "0"$0D"1"$0D"2"$0D"4"$0D"8"$0D"16"$0D"32"$0D"64"$0D"128"$0D"2"
         "56"$0D"512"$0D"1024"$0D"16384"$0D"32768"$0D"65536"$0D"131072"$0D"262"
         "144"$0D"524288"$0D"1048576"$0D"2097152"$0D"4194304"
      }
      damagemodel: =
      {
        txt = "&"
        hint = "Damage Model"
        typ = "C"
        items = "Normal"$0D"Doubling w/forgiveness"
        values = "0"$0D"1"
      }
      input#SetDamage: =
      {
        txt = "&"
        hint = "Set a new amount of damage for this trigger."
      }
      output#OnHurt: =
      {
        txt = "&"
        hint = "Fired whenever this trigger hurts something other than a playe"
         "r."
      }
      output#OnHurtPlayer: =
      {
        txt = "&"
        hint = "Fired whenever this trigger hurts a player."
      }
    }
    trigger_remove:form =
    {
      t_Trigger = !
      t_Targetname = !
      output#OnRemove: =
      {
        txt = "&"
        hint = "Fired whenever an entity is removed."
      }
    }
    trigger_multiple:form =
    {
      t_Trigger = !
      wait: =
      {
        txt = "&"
        hint = "Delay Before Reset"
      }
      output#OnTrigger: =
      {
        txt = "&"
        hint = "Fired whenever the trigger is activated."
      }
    }
    trigger_once:form =
    {
      t_TriggerOnce = !
      output#OnTrigger: =
      {
        txt = "&"
        hint = "Fired whenever the trigger is activated."
      }
    }
    trigger_look:form =
    {
      t_Trigger = !
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Fire Once"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Use Velocity instead of facing"
      }
      target: =
      {
        txt = "&"
        hint = "Look Target"
      }
      LookTime: =
      {
        txt = "&"
        hint = "LookTime"
      }
      FieldOfView: =
      {
        txt = "&"
        hint = "FieldOfView"
      }
      Timeout: =
      {
        txt = "&"
        hint = "Timeout"
      }
      output#OnTrigger: =
      {
        txt = "&"
        hint = "Fired when the trigger is activated."
      }
      output#OnTimeout: =
      {
        txt = "&"
        hint = "Fired after the timeout interval expires if the player never l"
         "ooked at the target."
      }
    }
    trigger_push:form =
    {
      t_Trigger = !
      pushdir: =
      {
        txt = "&"
        hint = "Push Direction (Pitch Yaw Roll)"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X128"
        cap = "Once Only"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X256"
        cap = "Affects Ladders (Half-Life 2)"
      }
      speed: =
      {
        txt = "&"
        hint = "Speed of Push"
      }
    }
    trigger_wind:form =
    {
      t_Trigger = !
      t_Angles = !
      Speed: =
      {
        txt = "&"
        hint = "Speed"
      }
      SpeedNoise: =
      {
        txt = "&"
        hint = "Speed Noise"
      }
      DirectionNoise: =
      {
        txt = "&"
        hint = "Direction Noise"
      }
      HoldTime: =
      {
        txt = "&"
        hint = "Hold Time"
      }
      HoldNoise: =
      {
        txt = "&"
        hint = "Hold Noise"
      }
      input#SetSpeed: =
      {
        txt = "&"
        hint = "Set the baseline for how hard the wind blows."
      }
    }
    trigger_impact:form =
    {
      t_Targetname = !
      t_Angles = !
      Magnitude: =
      {
        txt = "&"
        hint = "Magnitude"
      }
      noise: =
      {
        txt = "&"
        hint = "Noise"
      }
      viewkick: =
      {
        txt = "&"
        hint = "Viewkick"
      }
      input#Impact: =
      {
        txt = "&"
        hint = "Fire the impact, pushing all entities within the volume."
      }
      input#SetMagnitude: =
      {
        txt = "&"
        hint = "Set the magnitude of the impact."
      }
      output#ImpactForce: =
      {
        txt = "&"
        hint = "Fired after an impact. The parameter passed along is the force"
         " of the impact that was generated."
      }
    }
    trigger_proximity:form =
    {
      t_Trigger = !
      measuretarget: =
      {
        txt = "&"
        hint = "Point to Measure From"
      }
      radius: =
      {
        txt = "&"
        hint = "Radius to measure within"
      }
      output#NearestEntityDistance: =
      {
        txt = "&"
        hint = "Fired continuously when entities are touching the trigger volu"
         "me. The output parameter is the distance from the Point to Measure F"
         "rom to the nearest entity that passed the trigger filters. The dista"
         "nce is mapped to the radius distance, so it will be 0 when the entit"
         "y is on the point, and 1 when the entity is at the edge of the radiu"
         "s."
      }
    }
    trigger_teleport:form =
    {
      t_Trigger = !
      target: =
      {
        txt = "&"
        hint = "Remote Destination"
      }
      landmark: =
      {
        txt = "&"
        hint = "Local Destination Landmark"
      }
      spawnflags: =
      {
        txt = "&"
        typ = "X32"
        cap = "Preserve angles even when a local landmark is not specified"
      }
    }
    trigger_transition:form =
    {
      t_Targetname = !
    }
    ai_speechfilter:form =
    {
      t_Targetname = !
      t_ResponseContext = !
      subject: =
      {
        txt = "&"
        hint = "Subject(s)"
      }
      IdleModifier: =
      {
        txt = "&"
        hint = "Idle modifier."
      }
      NeverSayHello: =
      {
        txt = "&"
        hint = "Greet Player?"
        typ = "C"
        items = "Yes"$0D"No"
        values = "0"$0D"1"
      }
    }
    water_lod_control:form =
    {
      t_Targetname = !
      cheapwaterstartdistance: =
      {
        txt = "&"
        hint = "Start Transition to Cheap Water"
      }
      cheapwaterenddistance: =
      {
        txt = "&"
        hint = "End Transition to Cheap Water"
      }
      input#SetCheapWaterStartDistance: =
      {
        txt = "&"
        hint = "Set the distance that water starts transitioning to cheap wate"
         "r."
      }
      input#SetCheapWaterEndDistance: =
      {
        txt = "&"
        hint = "Set the distance that water finishes transitioning to cheap wa"
         "ter."
      }
      renderfx: =
      {
        txt = "&"
        hint = "Use 0 as your argument unless you know what your doing"
      }
      rendermode: =
      {
        txt = "&"
        hint = "Use 0 as your argument unless you know what your doing"
      }
      renderamt: =
      {
        txt = "&"
        hint = "Translucency"
      }
      rendercolor: =
      {
        txt = "&"
        hint = "RGB Color"
      }
      disableshadows: =
      {
        txt = "&"
        hint = "Use 0 as your argument unless you know what your doing"
      }
      disablereceiveshadows: =
      {
        txt = "&"
        hint = "Use 0 as your argument unless you know what your doing"
      }
      _minlight: =
      {
        txt = "&"
        hint = "Minimum light level"
      }
    }
    info_camera_link:form =
    {
      t_Targetname = !
      target: =
      {
        txt = "&"
        hint = "Entity Whose Material Uses _rt_camera"
      }
      PointCamera: =
      {
        txt = "&"
        hint = "Camera Name"
      }
      input#SetCamera: =
      {
        txt = "&"
        hint = "Set the camera to use. The parameter should be the name of a p"
         "oint_camera entity in the map."
      }
    }
    logic_measure_movement:form =
    {
      t_Targetname = !
      MeasureTarget: =
      {
        txt = "&"
        hint = "Entity to Measure"
      }
      MeasureReference: =
      {
        txt = "&"
        hint = "Measure Reference"
      }
      Target: =
      {
        txt = "&"
        hint = "Entity to Move"
      }
      TargetReference: =
      {
        txt = "&"
        hint = "Movement Reference"
      }
      TargetScale: =
      {
        txt = "&"
        hint = "Movement scale"
      }
      MeasureType: =
      {
        txt = "&"
        hint = "Measurement Type"
        typ = "C"
        items = "Position"$0D"Eye position"
        values = "0"$0D"1"
      }
      input#SetMeasureTarget: =
      {
        txt = "&"
        hint = "Set the Entity to Measure, whose movement should be measured."
      }
      input#SetMeasureReference: =
      {
        txt = "&"
        hint = "Set the Measure Reference entity."
      }
      input#Target: =
      {
        txt = "&"
        hint = "Set the Entity to Move, which will be moved to mimic the measu"
         "red entity."
      }
      input#SetTargetReference: =
      {
        txt = "&"
        hint = "Set the Movement Reference entity."
      }
      input#SetTargetScale: =
      {
        txt = "&"
        hint = "Set the scale to divide the measured movements by."
      }
      input#Enable: =
      {
        txt = "&"
        hint = "Enable the logic_measure_movement."
      }
      input#Disable: =
      {
        txt = "&"
        hint = "Disable the logic_measure_movement."
      }
    }
    npc_furniture:form =
    {
      t_BaseNPC = !
      model: =
      {
        txt = "&"
        hint = "Model"
        typ = "B"
        Cap = "models..."
        form = "t_models_hl2_form:form"
      }
    }
    env_credits:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Targetname = !
      input#RollCredits: =
      {
        txt = "&"
        hint = "Start the intro credits rolling."
      }
      input#RollOutroCredits: =
      {
        txt = "&"
        hint = "Start the outro credits rolling."
      }
      input#ShowLogo: =
      {
        txt = "&"
        hint = "Show the HL2 logo."
      }
      output#OnCreditsDone: =
      {
        txt = "&"
        hint = "Fired when the credits having finished rolling."
      }
    }
    material_modify_control:form =
    {
      bbox = '-8 -8 -8 8 8 8'
      t_Parentname = !
      t_Targetname = !
      materialName: =
      {
        txt = "&"
        hint = "Material to modify."
      }
      materialVar: =
      {
        txt = "&"
        hint = "Material variable to modify."
      }
      input#SetMaterialVar: =
      {
        txt = "&"
        hint = "Fire to modify a material variable. The argument is the value "
         "to set the variable to."
      }
      input#SetMaterialVarToCurrentTime: =
      {
        txt = "&"
        hint = "This sets the material variable to the current time on the ser"
         "ver."
      }
    }
    point_devshot_camera:form =
    {
      t_Angles = !
      cameraname: =
      {
        txt = "&"
        hint = "Camera Name"
      }
      FOV: =
      {
        txt = "&"
        hint = "Camera FOV"
      }
    }
  }
}
